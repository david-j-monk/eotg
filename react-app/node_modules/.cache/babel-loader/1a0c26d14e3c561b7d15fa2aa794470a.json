{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Models vector clock bases session token. Session token has the following format:\n * {Version}#{GlobalLSN}#{RegionId1}={LocalLsn1}#{RegionId2}={LocalLsn2}....#{RegionIdN}={LocalLsnN}\n * 'Version' captures the configuration number of the partition which returned this session token.\n * 'Version' is incremented everytime topology of the partition is updated (say due to Add/Remove/Failover).\n *\n * The choice of separators '#' and '=' is important. Separators ';' and ',' are used to delimit\n * per-partitionKeyRange session token\n * @hidden\n * @private\n *\n */\nexport class VectorSessionToken {\n  constructor(version, globalLsn, localLsnByregion, sessionToken) {\n    this.version = version;\n    this.globalLsn = globalLsn;\n    this.localLsnByregion = localLsnByregion;\n    this.sessionToken = sessionToken;\n\n    if (!this.sessionToken) {\n      const regionAndLocalLsn = [];\n\n      for (const [key, value] of this.localLsnByregion.entries()) {\n        regionAndLocalLsn.push(`${key}${VectorSessionToken.REGION_PROGRESS_SEPARATOR}${value}`);\n      }\n\n      const regionProgress = regionAndLocalLsn.join(VectorSessionToken.SEGMENT_SEPARATOR);\n\n      if (regionProgress === \"\") {\n        this.sessionToken = `${this.version}${VectorSessionToken.SEGMENT_SEPARATOR}${this.globalLsn}`;\n      } else {\n        this.sessionToken = `${this.version}${VectorSessionToken.SEGMENT_SEPARATOR}${this.globalLsn}${VectorSessionToken.SEGMENT_SEPARATOR}${regionProgress}`;\n      }\n    }\n  }\n\n  static create(sessionToken) {\n    if (!sessionToken) {\n      return null;\n    }\n\n    const [versionStr, globalLsnStr, ...regionSegments] = sessionToken.split(VectorSessionToken.SEGMENT_SEPARATOR);\n    const version = parseInt(versionStr, 10);\n    const globalLsn = parseFloat(globalLsnStr);\n\n    if (typeof version !== \"number\" || typeof globalLsn !== \"number\") {\n      return null;\n    }\n\n    const lsnByRegion = new Map();\n\n    for (const regionSegment of regionSegments) {\n      const [regionIdStr, localLsnStr] = regionSegment.split(VectorSessionToken.REGION_PROGRESS_SEPARATOR);\n\n      if (!regionIdStr || !localLsnStr) {\n        return null;\n      }\n\n      const regionId = parseInt(regionIdStr, 10);\n      let localLsn;\n\n      try {\n        localLsn = localLsnStr;\n      } catch (err) {\n        // TODO: log error\n        return null;\n      }\n\n      if (typeof regionId !== \"number\") {\n        return null;\n      }\n\n      lsnByRegion.set(regionId, localLsn);\n    }\n\n    return new VectorSessionToken(version, globalLsn, lsnByRegion, sessionToken);\n  }\n\n  equals(other) {\n    return !other ? false : this.version === other.version && this.globalLsn === other.globalLsn && this.areRegionProgressEqual(other.localLsnByregion);\n  }\n\n  merge(other) {\n    if (other == null) {\n      throw new Error(\"other (Vector Session Token) must not be null\");\n    }\n\n    if (this.version === other.version && this.localLsnByregion.size !== other.localLsnByregion.size) {\n      throw new Error(`Compared session tokens ${this.sessionToken} and ${other.sessionToken} have unexpected regions`);\n    }\n\n    const [higherVersionSessionToken, lowerVersionSessionToken] = this.version < other.version ? [other, this] : [this, other];\n    const highestLocalLsnByRegion = new Map();\n\n    for (const [regionId, highLocalLsn] of higherVersionSessionToken.localLsnByregion.entries()) {\n      const lowLocalLsn = lowerVersionSessionToken.localLsnByregion.get(regionId);\n\n      if (lowLocalLsn) {\n        highestLocalLsnByRegion.set(regionId, max(highLocalLsn, lowLocalLsn));\n      } else if (this.version === other.version) {\n        throw new Error(`Compared session tokens have unexpected regions. Session 1: ${this.sessionToken} - Session 2: ${this.sessionToken}`);\n      } else {\n        highestLocalLsnByRegion.set(regionId, highLocalLsn);\n      }\n    }\n\n    return new VectorSessionToken(Math.max(this.version, other.version), Math.max(this.globalLsn, other.globalLsn), highestLocalLsnByRegion);\n  }\n\n  toString() {\n    return this.sessionToken;\n  }\n\n  areRegionProgressEqual(other) {\n    if (this.localLsnByregion.size !== other.size) {\n      return false;\n    }\n\n    for (const [regionId, localLsn] of this.localLsnByregion.entries()) {\n      const otherLocalLsn = other.get(regionId);\n\n      if (localLsn !== otherLocalLsn) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\nVectorSessionToken.SEGMENT_SEPARATOR = \"#\";\nVectorSessionToken.REGION_PROGRESS_SEPARATOR = \"=\";\n/**\n * @ignore\n * @param int1\n * @param int2\n */\n\nfunction max(int1, int2) {\n  // NOTE: This only works for positive numbers\n  if (int1.length === int2.length) {\n    return int1 > int2 ? int1 : int2;\n  } else if (int1.length > int2.length) {\n    return int1;\n  } else {\n    return int2;\n  }\n}","map":{"version":3,"sources":["../../src/session/VectorSessionToken.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * Models vector clock bases session token. Session token has the following format:\n * {Version}#{GlobalLSN}#{RegionId1}={LocalLsn1}#{RegionId2}={LocalLsn2}....#{RegionIdN}={LocalLsnN}\n * 'Version' captures the configuration number of the partition which returned this session token.\n * 'Version' is incremented everytime topology of the partition is updated (say due to Add/Remove/Failover).\n *\n * The choice of separators '#' and '=' is important. Separators ';' and ',' are used to delimit\n * per-partitionKeyRange session token\n * @hidden\n * @private\n *\n */\nexport class VectorSessionToken {\n  private static readonly SEGMENT_SEPARATOR = \"#\";\n  private static readonly REGION_PROGRESS_SEPARATOR = \"=\";\n\n  constructor(\n    private readonly version: number,\n    private readonly globalLsn: number,\n    private readonly localLsnByregion: Map<number, string>,\n    private readonly sessionToken?: string\n  ) {\n    if (!this.sessionToken) {\n      const regionAndLocalLsn = [];\n      for (const [key, value] of this.localLsnByregion.entries()) {\n        regionAndLocalLsn.push(`${key}${VectorSessionToken.REGION_PROGRESS_SEPARATOR}${value}`);\n      }\n      const regionProgress = regionAndLocalLsn.join(VectorSessionToken.SEGMENT_SEPARATOR);\n      if (regionProgress === \"\") {\n        this.sessionToken = `${this.version}${VectorSessionToken.SEGMENT_SEPARATOR}${this.globalLsn}`;\n      } else {\n        this.sessionToken = `${this.version}${VectorSessionToken.SEGMENT_SEPARATOR}${this.globalLsn}${VectorSessionToken.SEGMENT_SEPARATOR}${regionProgress}`;\n      }\n    }\n  }\n\n  public static create(sessionToken: string): VectorSessionToken {\n    if (!sessionToken) {\n      return null;\n    }\n\n    const [versionStr, globalLsnStr, ...regionSegments] = sessionToken.split(\n      VectorSessionToken.SEGMENT_SEPARATOR\n    );\n\n    const version = parseInt(versionStr, 10);\n    const globalLsn = parseFloat(globalLsnStr);\n\n    if (typeof version !== \"number\" || typeof globalLsn !== \"number\") {\n      return null;\n    }\n\n    const lsnByRegion = new Map<number, string>();\n    for (const regionSegment of regionSegments) {\n      const [regionIdStr, localLsnStr] = regionSegment.split(\n        VectorSessionToken.REGION_PROGRESS_SEPARATOR\n      );\n\n      if (!regionIdStr || !localLsnStr) {\n        return null;\n      }\n\n      const regionId = parseInt(regionIdStr, 10);\n      let localLsn: string;\n      try {\n        localLsn = localLsnStr;\n      } catch (err) {\n        // TODO: log error\n        return null;\n      }\n      if (typeof regionId !== \"number\") {\n        return null;\n      }\n\n      lsnByRegion.set(regionId, localLsn);\n    }\n\n    return new VectorSessionToken(version, globalLsn, lsnByRegion, sessionToken);\n  }\n\n  public equals(other: VectorSessionToken): boolean {\n    return !other\n      ? false\n      : this.version === other.version &&\n          this.globalLsn === other.globalLsn &&\n          this.areRegionProgressEqual(other.localLsnByregion);\n  }\n\n  public merge(other: VectorSessionToken): VectorSessionToken {\n    if (other == null) {\n      throw new Error(\"other (Vector Session Token) must not be null\");\n    }\n\n    if (\n      this.version === other.version &&\n      this.localLsnByregion.size !== other.localLsnByregion.size\n    ) {\n      throw new Error(\n        `Compared session tokens ${this.sessionToken} and ${other.sessionToken} have unexpected regions`\n      );\n    }\n\n    const [higherVersionSessionToken, lowerVersionSessionToken]: [\n      VectorSessionToken,\n      VectorSessionToken\n    ] = this.version < other.version ? [other, this] : [this, other];\n\n    const highestLocalLsnByRegion = new Map<number, string>();\n\n    for (const [regionId, highLocalLsn] of higherVersionSessionToken.localLsnByregion.entries()) {\n      const lowLocalLsn = lowerVersionSessionToken.localLsnByregion.get(regionId);\n      if (lowLocalLsn) {\n        highestLocalLsnByRegion.set(regionId, max(highLocalLsn, lowLocalLsn));\n      } else if (this.version === other.version) {\n        throw new Error(\n          `Compared session tokens have unexpected regions. Session 1: ${this.sessionToken} - Session 2: ${this.sessionToken}`\n        );\n      } else {\n        highestLocalLsnByRegion.set(regionId, highLocalLsn);\n      }\n    }\n\n    return new VectorSessionToken(\n      Math.max(this.version, other.version),\n      Math.max(this.globalLsn, other.globalLsn),\n      highestLocalLsnByRegion\n    );\n  }\n\n  public toString() {\n    return this.sessionToken;\n  }\n\n  private areRegionProgressEqual(other: Map<number, string>): boolean {\n    if (this.localLsnByregion.size !== other.size) {\n      return false;\n    }\n\n    for (const [regionId, localLsn] of this.localLsnByregion.entries()) {\n      const otherLocalLsn = other.get(regionId);\n\n      if (localLsn !== otherLocalLsn) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\n/**\n * @ignore\n * @param int1\n * @param int2\n */\nfunction max(int1: string, int2: string) {\n  // NOTE: This only works for positive numbers\n  if (int1.length === int2.length) {\n    return int1 > int2 ? int1 : int2;\n  } else if (int1.length > int2.length) {\n    return int1;\n  } else {\n    return int2;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}