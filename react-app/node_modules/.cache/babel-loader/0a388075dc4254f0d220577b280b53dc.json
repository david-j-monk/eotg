{"ast":null,"code":"import { __awaiter } from \"tslib\"; // Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationType } from \"../common\";\nimport { TimeoutErrorCode } from \"../request/TimeoutError\";\n/**\n * @ignore\n */\n// Windows Socket Error Codes\n\nconst WindowsInterruptedFunctionCall = 10004;\n/**\n * @ignore\n */\n\nconst WindowsFileHandleNotValid = 10009;\n/**\n * @ignore\n */\n\nconst WindowsPermissionDenied = 10013;\n/**\n * @ignore\n */\n\nconst WindowsBadAddress = 10014;\n/**\n * @ignore\n */\n\nconst WindowsInvalidArgumnet = 10022;\n/**\n * @ignore\n */\n\nconst WindowsResourceTemporarilyUnavailable = 10035;\n/**\n * @ignore\n */\n\nconst WindowsOperationNowInProgress = 10036;\n/**\n * @ignore\n */\n\nconst WindowsAddressAlreadyInUse = 10048;\n/**\n * @ignore\n */\n\nconst WindowsConnectionResetByPeer = 10054;\n/**\n * @ignore\n */\n\nconst WindowsCannotSendAfterSocketShutdown = 10058;\n/**\n * @ignore\n */\n\nconst WindowsConnectionTimedOut = 10060;\n/**\n * @ignore\n */\n\nconst WindowsConnectionRefused = 10061;\n/**\n * @ignore\n */\n\nconst WindowsNameTooLong = 10063;\n/**\n * @ignore\n */\n\nconst WindowsHostIsDown = 10064;\n/**\n * @ignore\n */\n\nconst WindowsNoRouteTohost = 10065;\n/**\n * @ignore\n */\n// Linux Error Codes\n\n/**\n * @ignore\n */\n\nconst LinuxConnectionReset = \"ECONNRESET\"; // Node Error Codes\n\n/**\n * @ignore\n */\n\nconst BrokenPipe = \"EPIPE\";\n/**\n * @ignore\n */\n\nconst CONNECTION_ERROR_CODES = [WindowsInterruptedFunctionCall, WindowsFileHandleNotValid, WindowsPermissionDenied, WindowsBadAddress, WindowsInvalidArgumnet, WindowsResourceTemporarilyUnavailable, WindowsOperationNowInProgress, WindowsAddressAlreadyInUse, WindowsConnectionResetByPeer, WindowsCannotSendAfterSocketShutdown, WindowsConnectionTimedOut, WindowsConnectionRefused, WindowsNameTooLong, WindowsHostIsDown, WindowsNoRouteTohost, LinuxConnectionReset, TimeoutErrorCode, BrokenPipe];\n/**\n * @ignore\n */\n\nfunction needsRetry(operationType, code) {\n  if ((operationType === OperationType.Read || operationType === OperationType.Query) && CONNECTION_ERROR_CODES.indexOf(code) !== -1) {\n    return true;\n  } else {\n    return false;\n  }\n}\n/**\n * This class implements the default connection retry policy for requests.\n * @property {int} currentRetryAttemptCount           - Current retry attempt count.\n * @hidden\n * @ignore\n */\n\n\nexport class DefaultRetryPolicy {\n  constructor(operationType) {\n    this.operationType = operationType;\n    this.maxTries = 10;\n    this.currentRetryAttemptCount = 0;\n    this.retryAfterInMs = 1000;\n  }\n  /**\n   * Determines whether the request should be retried or not.\n   * @param {object} err - Error returned by the request.\n   */\n\n\n  shouldRetry(err) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (err) {\n        if (this.currentRetryAttemptCount < this.maxTries && needsRetry(this.operationType, err.code)) {\n          this.currentRetryAttemptCount++;\n          return true;\n        }\n      }\n\n      return false;\n    });\n  }\n\n}","map":{"version":3,"sources":["../../src/retry/defaultRetryPolicy.ts"],"names":[],"mappings":"mCAAA;AACA;;AACA,SAAS,aAAT,QAA8B,WAA9B;AAEA,SAAS,gBAAT,QAAiC,yBAAjC;AAGA;;;AAGA;;AACA,MAAM,8BAA8B,GAAG,KAAvC;AACA;;;;AAGA,MAAM,yBAAyB,GAAG,KAAlC;AACA;;;;AAGA,MAAM,uBAAuB,GAAG,KAAhC;AACA;;;;AAGA,MAAM,iBAAiB,GAAG,KAA1B;AACA;;;;AAGA,MAAM,sBAAsB,GAAG,KAA/B;AACA;;;;AAGA,MAAM,qCAAqC,GAAG,KAA9C;AACA;;;;AAGA,MAAM,6BAA6B,GAAG,KAAtC;AACA;;;;AAGA,MAAM,0BAA0B,GAAG,KAAnC;AACA;;;;AAGA,MAAM,4BAA4B,GAAG,KAArC;AACA;;;;AAGA,MAAM,oCAAoC,GAAG,KAA7C;AACA;;;;AAGA,MAAM,yBAAyB,GAAG,KAAlC;AACA;;;;AAGA,MAAM,wBAAwB,GAAG,KAAjC;AACA;;;;AAGA,MAAM,kBAAkB,GAAG,KAA3B;AACA;;;;AAGA,MAAM,iBAAiB,GAAG,KAA1B;AACA;;;;AAGA,MAAM,oBAAoB,GAAG,KAA7B;AACA;;;AAIA;;AACA;;;;AAGA,MAAM,oBAAoB,GAAG,YAA7B,C,CAEA;;AACA;;;;AAGA,MAAM,UAAU,GAAG,OAAnB;AAEA;;;;AAGA,MAAM,sBAAsB,GAAG,CAC7B,8BAD6B,EAE7B,yBAF6B,EAG7B,uBAH6B,EAI7B,iBAJ6B,EAK7B,sBAL6B,EAM7B,qCAN6B,EAO7B,6BAP6B,EAQ7B,0BAR6B,EAS7B,4BAT6B,EAU7B,oCAV6B,EAW7B,yBAX6B,EAY7B,wBAZ6B,EAa7B,kBAb6B,EAc7B,iBAd6B,EAe7B,oBAf6B,EAgB7B,oBAhB6B,EAiB7B,gBAjB6B,EAkB7B,UAlB6B,CAA/B;AAqBA;;;;AAGA,SAAS,UAAT,CAAoB,aAApB,EAAkD,IAAlD,EAAuE;AACrE,MACE,CAAC,aAAa,KAAK,aAAa,CAAC,IAAhC,IAAwC,aAAa,KAAK,aAAa,CAAC,KAAzE,KACA,sBAAsB,CAAC,OAAvB,CAA+B,IAA/B,MAAyC,CAAC,CAF5C,EAGE;AACA,WAAO,IAAP;AACD,GALD,MAKO;AACL,WAAO,KAAP;AACD;AACF;AAED;;;;;;;;AAMA,OAAM,MAAO,kBAAP,CAAyB;AAK7B,EAAA,WAAA,CAAoB,aAApB,EAAgD;AAA5B,SAAA,aAAA,GAAA,aAAA;AAJZ,SAAA,QAAA,GAAmB,EAAnB;AACA,SAAA,wBAAA,GAAmC,CAAnC;AACD,SAAA,cAAA,GAAyB,IAAzB;AAE6C;AACpD;;;;;;AAIa,EAAA,WAAW,CAAC,GAAD,EAAmB;;AACzC,UAAI,GAAJ,EAAS;AACP,YACE,KAAK,wBAAL,GAAgC,KAAK,QAArC,IACA,UAAU,CAAC,KAAK,aAAN,EAAqB,GAAG,CAAC,IAAzB,CAFZ,EAGE;AACA,eAAK,wBAAL;AACA,iBAAO,IAAP;AACD;AACF;;AACD,aAAO,KAAP;AACD,K;AAAA;;AArB4B","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { OperationType } from \"../common\";\nimport { ErrorResponse } from \"../request\";\nimport { TimeoutErrorCode } from \"../request/TimeoutError\";\nimport { RetryPolicy } from \"./RetryPolicy\";\n\n/**\n * @ignore\n */\n// Windows Socket Error Codes\nconst WindowsInterruptedFunctionCall = 10004;\n/**\n * @ignore\n */\nconst WindowsFileHandleNotValid = 10009;\n/**\n * @ignore\n */\nconst WindowsPermissionDenied = 10013;\n/**\n * @ignore\n */\nconst WindowsBadAddress = 10014;\n/**\n * @ignore\n */\nconst WindowsInvalidArgumnet = 10022;\n/**\n * @ignore\n */\nconst WindowsResourceTemporarilyUnavailable = 10035;\n/**\n * @ignore\n */\nconst WindowsOperationNowInProgress = 10036;\n/**\n * @ignore\n */\nconst WindowsAddressAlreadyInUse = 10048;\n/**\n * @ignore\n */\nconst WindowsConnectionResetByPeer = 10054;\n/**\n * @ignore\n */\nconst WindowsCannotSendAfterSocketShutdown = 10058;\n/**\n * @ignore\n */\nconst WindowsConnectionTimedOut = 10060;\n/**\n * @ignore\n */\nconst WindowsConnectionRefused = 10061;\n/**\n * @ignore\n */\nconst WindowsNameTooLong = 10063;\n/**\n * @ignore\n */\nconst WindowsHostIsDown = 10064;\n/**\n * @ignore\n */\nconst WindowsNoRouteTohost = 10065;\n/**\n * @ignore\n */\n\n// Linux Error Codes\n/**\n * @ignore\n */\nconst LinuxConnectionReset = \"ECONNRESET\";\n\n// Node Error Codes\n/**\n * @ignore\n */\nconst BrokenPipe = \"EPIPE\";\n\n/**\n * @ignore\n */\nconst CONNECTION_ERROR_CODES = [\n  WindowsInterruptedFunctionCall,\n  WindowsFileHandleNotValid,\n  WindowsPermissionDenied,\n  WindowsBadAddress,\n  WindowsInvalidArgumnet,\n  WindowsResourceTemporarilyUnavailable,\n  WindowsOperationNowInProgress,\n  WindowsAddressAlreadyInUse,\n  WindowsConnectionResetByPeer,\n  WindowsCannotSendAfterSocketShutdown,\n  WindowsConnectionTimedOut,\n  WindowsConnectionRefused,\n  WindowsNameTooLong,\n  WindowsHostIsDown,\n  WindowsNoRouteTohost,\n  LinuxConnectionReset,\n  TimeoutErrorCode,\n  BrokenPipe\n];\n\n/**\n * @ignore\n */\nfunction needsRetry(operationType: OperationType, code: number | string) {\n  if (\n    (operationType === OperationType.Read || operationType === OperationType.Query) &&\n    CONNECTION_ERROR_CODES.indexOf(code) !== -1\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * This class implements the default connection retry policy for requests.\n * @property {int} currentRetryAttemptCount           - Current retry attempt count.\n * @hidden\n * @ignore\n */\nexport class DefaultRetryPolicy implements RetryPolicy {\n  private maxTries: number = 10;\n  private currentRetryAttemptCount: number = 0;\n  public retryAfterInMs: number = 1000;\n\n  constructor(private operationType: OperationType) {}\n  /**\n   * Determines whether the request should be retried or not.\n   * @param {object} err - Error returned by the request.\n   */\n  public async shouldRetry(err: ErrorResponse): Promise<boolean> {\n    if (err) {\n      if (\n        this.currentRetryAttemptCount < this.maxTries &&\n        needsRetry(this.operationType, err.code)\n      ) {\n        this.currentRetryAttemptCount++;\n        return true;\n      }\n    }\n    return false;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}