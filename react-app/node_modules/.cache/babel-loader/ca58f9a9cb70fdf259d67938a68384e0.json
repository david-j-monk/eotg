{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport atob from \"../utils/atob\";\nimport { Constants, getContainerLink, OperationType, trimSlashes } from \"../common\";\nimport { VectorSessionToken } from \"./VectorSessionToken\";\n/** @hidden */\n\nexport class SessionContainer {\n  constructor(collectionNameToCollectionResourceId = new Map(), collectionResourceIdToSessionTokens = new Map()) {\n    this.collectionNameToCollectionResourceId = collectionNameToCollectionResourceId;\n    this.collectionResourceIdToSessionTokens = collectionResourceIdToSessionTokens;\n  }\n\n  get(request) {\n    if (!request) {\n      throw new Error(\"request cannot be null\");\n    }\n\n    const collectionName = getContainerLink(trimSlashes(request.resourceAddress));\n    const rangeIdToTokenMap = this.getPartitionKeyRangeIdToTokenMap(collectionName);\n    return SessionContainer.getCombinedSessionTokenString(rangeIdToTokenMap);\n  }\n\n  remove(request) {\n    let collectionResourceId;\n    const resourceAddress = trimSlashes(request.resourceAddress);\n    const collectionName = getContainerLink(resourceAddress);\n\n    if (collectionName) {\n      collectionResourceId = this.collectionNameToCollectionResourceId.get(collectionName);\n      this.collectionNameToCollectionResourceId.delete(collectionName);\n    }\n\n    if (collectionResourceId !== undefined) {\n      this.collectionResourceIdToSessionTokens.delete(collectionResourceId);\n    }\n  }\n\n  set(request, resHeaders) {\n    // TODO: we check the master logic a few different places. Might not need it.\n    if (!resHeaders || SessionContainer.isReadingFromMaster(request.resourceType, request.operationType)) {\n      return;\n    }\n\n    const sessionTokenString = resHeaders[Constants.HttpHeaders.SessionToken];\n\n    if (!sessionTokenString) {\n      return;\n    }\n\n    const containerName = this.getContainerName(request, resHeaders);\n    const ownerId = !request.isNameBased ? request.resourceId : resHeaders[Constants.HttpHeaders.OwnerId] || request.resourceId;\n\n    if (!ownerId) {\n      return;\n    }\n\n    if (containerName && this.validateOwnerID(ownerId)) {\n      if (!this.collectionResourceIdToSessionTokens.has(ownerId)) {\n        this.collectionResourceIdToSessionTokens.set(ownerId, new Map());\n      }\n\n      if (!this.collectionNameToCollectionResourceId.has(containerName)) {\n        this.collectionNameToCollectionResourceId.set(containerName, ownerId);\n      }\n\n      const containerSessionContainer = this.collectionResourceIdToSessionTokens.get(ownerId);\n      SessionContainer.compareAndSetToken(sessionTokenString, containerSessionContainer);\n    }\n  }\n\n  validateOwnerID(ownerId) {\n    // If ownerId contains exactly 8 bytes it represents a unique database+collection identifier. Otherwise it represents another resource\n    // The first 4 bytes are the database. The last 4 bytes are the collection.\n    // Cosmos rids potentially contain \"-\" which is an invalid character in the browser atob implementation\n    // See https://en.wikipedia.org/wiki/Base64#Filenames\n    return atob(ownerId.replace(/-/g, \"/\")).length === 8;\n  }\n\n  getPartitionKeyRangeIdToTokenMap(collectionName) {\n    let rangeIdToTokenMap = null;\n\n    if (collectionName && this.collectionNameToCollectionResourceId.has(collectionName)) {\n      rangeIdToTokenMap = this.collectionResourceIdToSessionTokens.get(this.collectionNameToCollectionResourceId.get(collectionName));\n    }\n\n    return rangeIdToTokenMap;\n  }\n\n  static getCombinedSessionTokenString(tokens) {\n    if (!tokens || tokens.size === 0) {\n      return SessionContainer.EMPTY_SESSION_TOKEN;\n    }\n\n    let result = \"\";\n\n    for (const [range, token] of tokens.entries()) {\n      result += range + SessionContainer.SESSION_TOKEN_PARTITION_SPLITTER + token.toString() + SessionContainer.SESSION_TOKEN_SEPARATOR;\n    }\n\n    return result.slice(0, -1);\n  }\n\n  static compareAndSetToken(newTokenString, containerSessionTokens) {\n    if (!newTokenString) {\n      return;\n    }\n\n    const partitionsParts = newTokenString.split(SessionContainer.SESSION_TOKEN_SEPARATOR);\n\n    for (const partitionPart of partitionsParts) {\n      const newTokenParts = partitionPart.split(SessionContainer.SESSION_TOKEN_PARTITION_SPLITTER);\n\n      if (newTokenParts.length !== 2) {\n        return;\n      }\n\n      const range = newTokenParts[0];\n      const newToken = VectorSessionToken.create(newTokenParts[1]);\n      const tokenForRange = !containerSessionTokens.get(range) ? newToken : containerSessionTokens.get(range).merge(newToken);\n      containerSessionTokens.set(range, tokenForRange);\n    }\n  } // TODO: have a assert if the type doesn't mastch known types\n\n\n  static isReadingFromMaster(resourceType, operationType) {\n    if (resourceType === Constants.Path.OffersPathSegment || resourceType === Constants.Path.DatabasesPathSegment || resourceType === Constants.Path.UsersPathSegment || resourceType === Constants.Path.PermissionsPathSegment || resourceType === Constants.Path.TopologyPathSegment || resourceType === Constants.Path.DatabaseAccountPathSegment || resourceType === Constants.Path.PartitionKeyRangesPathSegment || resourceType === Constants.Path.CollectionsPathSegment && operationType === OperationType.Query) {\n      return true;\n    }\n\n    return false;\n  }\n\n  getContainerName(request, headers) {\n    let ownerFullName = headers[Constants.HttpHeaders.OwnerFullName];\n\n    if (!ownerFullName) {\n      ownerFullName = trimSlashes(request.resourceAddress);\n    }\n\n    return getContainerLink(ownerFullName);\n  }\n\n}\nSessionContainer.EMPTY_SESSION_TOKEN = \"\";\nSessionContainer.SESSION_TOKEN_SEPARATOR = \",\";\nSessionContainer.SESSION_TOKEN_PARTITION_SPLITTER = \":\";","map":{"version":3,"sources":["../../src/session/sessionContainer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport atob from \"../utils/atob\";\nimport { Constants, getContainerLink, OperationType, ResourceType, trimSlashes } from \"../common\";\nimport { CosmosHeaders } from \"../queryExecutionContext\";\nimport { SessionContext } from \"./SessionContext\";\nimport { VectorSessionToken } from \"./VectorSessionToken\";\n\n/** @hidden */\nexport class SessionContainer {\n  private static readonly EMPTY_SESSION_TOKEN = \"\";\n  private static readonly SESSION_TOKEN_SEPARATOR = \",\";\n  private static readonly SESSION_TOKEN_PARTITION_SPLITTER = \":\";\n  constructor(\n    private collectionNameToCollectionResourceId = new Map<string, string>(),\n    private collectionResourceIdToSessionTokens = new Map<string, Map<string, VectorSessionToken>>()\n  ) {}\n\n  public get(request: SessionContext) {\n    if (!request) {\n      throw new Error(\"request cannot be null\");\n    }\n    const collectionName = getContainerLink(trimSlashes(request.resourceAddress));\n    const rangeIdToTokenMap = this.getPartitionKeyRangeIdToTokenMap(collectionName);\n    return SessionContainer.getCombinedSessionTokenString(rangeIdToTokenMap);\n  }\n\n  public remove(request: SessionContext) {\n    let collectionResourceId: string;\n    const resourceAddress = trimSlashes(request.resourceAddress);\n    const collectionName = getContainerLink(resourceAddress);\n    if (collectionName) {\n      collectionResourceId = this.collectionNameToCollectionResourceId.get(collectionName);\n      this.collectionNameToCollectionResourceId.delete(collectionName);\n    }\n    if (collectionResourceId !== undefined) {\n      this.collectionResourceIdToSessionTokens.delete(collectionResourceId);\n    }\n  }\n\n  public set(request: SessionContext, resHeaders: CosmosHeaders) {\n    // TODO: we check the master logic a few different places. Might not need it.\n    if (\n      !resHeaders ||\n      SessionContainer.isReadingFromMaster(request.resourceType, request.operationType)\n    ) {\n      return;\n    }\n\n    const sessionTokenString = resHeaders[Constants.HttpHeaders.SessionToken];\n    if (!sessionTokenString) {\n      return;\n    }\n\n    const containerName = this.getContainerName(request, resHeaders);\n\n    const ownerId = !request.isNameBased\n      ? request.resourceId\n      : resHeaders[Constants.HttpHeaders.OwnerId] || request.resourceId;\n\n    if (!ownerId) {\n      return;\n    }\n\n    if (containerName && this.validateOwnerID(ownerId)) {\n      if (!this.collectionResourceIdToSessionTokens.has(ownerId)) {\n        this.collectionResourceIdToSessionTokens.set(ownerId, new Map());\n      }\n\n      if (!this.collectionNameToCollectionResourceId.has(containerName)) {\n        this.collectionNameToCollectionResourceId.set(containerName, ownerId);\n      }\n\n      const containerSessionContainer = this.collectionResourceIdToSessionTokens.get(ownerId);\n      SessionContainer.compareAndSetToken(sessionTokenString, containerSessionContainer);\n    }\n  }\n\n  private validateOwnerID(ownerId: string) {\n    // If ownerId contains exactly 8 bytes it represents a unique database+collection identifier. Otherwise it represents another resource\n    // The first 4 bytes are the database. The last 4 bytes are the collection.\n    // Cosmos rids potentially contain \"-\" which is an invalid character in the browser atob implementation\n    // See https://en.wikipedia.org/wiki/Base64#Filenames\n    return atob(ownerId.replace(/-/g, \"/\")).length === 8;\n  }\n\n  private getPartitionKeyRangeIdToTokenMap(\n    collectionName: string\n  ): Map<string, VectorSessionToken> {\n    let rangeIdToTokenMap: Map<string, VectorSessionToken> = null;\n    if (collectionName && this.collectionNameToCollectionResourceId.has(collectionName)) {\n      rangeIdToTokenMap = this.collectionResourceIdToSessionTokens.get(\n        this.collectionNameToCollectionResourceId.get(collectionName)\n      );\n    }\n\n    return rangeIdToTokenMap;\n  }\n\n  private static getCombinedSessionTokenString(tokens: Map<string, VectorSessionToken>) {\n    if (!tokens || tokens.size === 0) {\n      return SessionContainer.EMPTY_SESSION_TOKEN;\n    }\n\n    let result = \"\";\n    for (const [range, token] of tokens.entries()) {\n      result +=\n        range +\n        SessionContainer.SESSION_TOKEN_PARTITION_SPLITTER +\n        token.toString() +\n        SessionContainer.SESSION_TOKEN_SEPARATOR;\n    }\n    return result.slice(0, -1);\n  }\n\n  private static compareAndSetToken(\n    newTokenString: string,\n    containerSessionTokens: Map<string, VectorSessionToken>\n  ) {\n    if (!newTokenString) {\n      return;\n    }\n\n    const partitionsParts = newTokenString.split(SessionContainer.SESSION_TOKEN_SEPARATOR);\n    for (const partitionPart of partitionsParts) {\n      const newTokenParts = partitionPart.split(SessionContainer.SESSION_TOKEN_PARTITION_SPLITTER);\n      if (newTokenParts.length !== 2) {\n        return;\n      }\n\n      const range = newTokenParts[0];\n      const newToken = VectorSessionToken.create(newTokenParts[1]);\n      const tokenForRange = !containerSessionTokens.get(range)\n        ? newToken\n        : containerSessionTokens.get(range).merge(newToken);\n      containerSessionTokens.set(range, tokenForRange);\n    }\n  }\n\n  // TODO: have a assert if the type doesn't mastch known types\n  private static isReadingFromMaster(\n    resourceType: ResourceType,\n    operationType: OperationType\n  ): boolean {\n    if (\n      resourceType === Constants.Path.OffersPathSegment ||\n      resourceType === Constants.Path.DatabasesPathSegment ||\n      resourceType === Constants.Path.UsersPathSegment ||\n      resourceType === Constants.Path.PermissionsPathSegment ||\n      resourceType === Constants.Path.TopologyPathSegment ||\n      resourceType === Constants.Path.DatabaseAccountPathSegment ||\n      resourceType === Constants.Path.PartitionKeyRangesPathSegment ||\n      (resourceType === Constants.Path.CollectionsPathSegment &&\n        operationType === OperationType.Query)\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private getContainerName(request: SessionContext, headers: CosmosHeaders) {\n    let ownerFullName = headers[Constants.HttpHeaders.OwnerFullName];\n    if (!ownerFullName) {\n      ownerFullName = trimSlashes(request.resourceAddress);\n    }\n\n    return getContainerLink(ownerFullName as string);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}