{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { createDocumentCollectionUri, getIdFromLink, getPathFromLink, isResourceValid, ResourceType } from \"../../common\";\nimport { ResourceResponse } from \"../../request\";\nimport { Conflict, Conflicts } from \"../Conflict\";\nimport { Item, Items } from \"../Item\";\nimport { Scripts } from \"../Script/Scripts\";\nimport { ContainerResponse } from \"./ContainerResponse\";\nimport { Offer } from \"../Offer\";\nimport { OfferResponse } from \"../Offer/OfferResponse\";\n/**\n * Operations for reading, replacing, or deleting a specific, existing container by id.\n *\n * @see {@link Containers} for creating new containers, and reading/querying all containers; use `.containers`.\n *\n * Note: all these operations make calls against a fixed budget.\n * You should design your system such that these calls scale sublinearly with your application.\n * For instance, do not call `container(id).read()` before every single `item.read()` call, to ensure the container exists;\n * do this once on application start up.\n */\n\nexport class Container {\n  /**\n   * Returns a container instance. Note: You should get this from `database.container(id)`, rather than creating your own object.\n   * @param database The parent {@link Database}.\n   * @param id The id of the given container.\n   * @hidden\n   */\n  constructor(database, id, clientContext) {\n    this.database = database;\n    this.id = id;\n    this.clientContext = clientContext;\n  }\n  /**\n   * Operations for creating new items, and reading/querying all items\n   *\n   * For reading, replacing, or deleting an existing item, use `.item(id)`.\n   *\n   * @example Create a new item\n   * ```typescript\n   * const {body: createdItem} = await container.items.create({id: \"<item id>\", properties: {}});\n   * ```\n   */\n\n\n  get items() {\n    if (!this.$items) {\n      this.$items = new Items(this, this.clientContext);\n    }\n\n    return this.$items;\n  }\n  /**\n   * All operations for Stored Procedures, Triggers, and User Defined Functions\n   */\n\n\n  get scripts() {\n    if (!this.$scripts) {\n      this.$scripts = new Scripts(this, this.clientContext);\n    }\n\n    return this.$scripts;\n  }\n  /**\n   * Opertaions for reading and querying conflicts for the given container.\n   *\n   * For reading or deleting a specific conflict, use `.conflict(id)`.\n   */\n\n\n  get conflicts() {\n    if (!this.$conflicts) {\n      this.$conflicts = new Conflicts(this, this.clientContext);\n    }\n\n    return this.$conflicts;\n  }\n  /**\n   * Returns a reference URL to the resource. Used for linking in Permissions.\n   */\n\n\n  get url() {\n    return createDocumentCollectionUri(this.database.id, this.id);\n  }\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Item} by id.\n   *\n   * Use `.items` for creating new items, or querying/reading all items.\n   *\n   * @param id The id of the {@link Item}.\n   * @param partitionKeyValue The value of the {@link Item} partition key\n   * @example Replace an item\n   * const {body: replacedItem} = await container.item(\"<item id>\", \"<partition key value>\").replace({id: \"<item id>\", title: \"Updated post\", authorID: 5});\n   */\n\n\n  item(id, partitionKeyValue) {\n    return new Item(this, id, partitionKeyValue, this.clientContext);\n  }\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Conflict} by id.\n   *\n   * Use `.conflicts` for creating new conflicts, or querying/reading all conflicts.\n   * @param id The id of the {@link Conflict}.\n   */\n\n\n  conflict(id) {\n    return new Conflict(this, id, this.clientContext);\n  }\n  /** Read the container's definition */\n\n\n  read(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n      const response = yield this.clientContext.read({\n        path,\n        resourceType: ResourceType.container,\n        resourceId: id,\n        options\n      });\n      this.clientContext.partitionKeyDefinitionCache[this.url] = response.result.partitionKey;\n      return new ContainerResponse(response.result, response.headers, response.code, this);\n    });\n  }\n  /** Replace the container's definition */\n\n\n  replace(body, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const err = {};\n\n      if (!isResourceValid(body, err)) {\n        throw err;\n      }\n\n      const path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n      const response = yield this.clientContext.replace({\n        body,\n        path,\n        resourceType: ResourceType.container,\n        resourceId: id,\n        options\n      });\n      return new ContainerResponse(response.result, response.headers, response.code, this);\n    });\n  }\n  /** Delete the container */\n\n\n  delete(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n      const response = yield this.clientContext.delete({\n        path,\n        resourceType: ResourceType.container,\n        resourceId: id,\n        options\n      });\n      return new ContainerResponse(response.result, response.headers, response.code, this);\n    });\n  }\n  /**\n   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.\n   * @deprecated This method has been renamed to readPartitionKeyDefinition.\n   * @param {string} collectionLink   - Link to the collection whose partition key needs to be extracted.\n   * @param {function} callback       - \\\n   * The arguments to the callback are(in order): error, partitionKeyDefinition, response object and response headers\n   */\n\n\n  getPartitionKeyDefinition() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.readPartitionKeyDefinition();\n    });\n  }\n  /**\n   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.\n   * @ignore\n   * @param {string} collectionLink   - Link to the collection whose partition key needs to be extracted.\n   * @param {function} callback       - \\\n   * The arguments to the callback are(in order): error, partitionKeyDefinition, response object and response headers\n   */\n\n\n  readPartitionKeyDefinition() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // $ISSUE-felixfan-2016-03-17: Make name based path and link based path use the same key\n      // $ISSUE-felixfan-2016-03-17: Refresh partitionKeyDefinitionCache when necessary\n      if (this.url in this.clientContext.partitionKeyDefinitionCache) {\n        return new ResourceResponse(this.clientContext.partitionKeyDefinitionCache[this.url], {}, 0);\n      }\n\n      const {\n        headers,\n        statusCode\n      } = yield this.read();\n      return new ResourceResponse(this.clientContext.partitionKeyDefinitionCache[this.url], headers, statusCode);\n    });\n  }\n  /**\n   * Gets offer on container. If none exists, returns an OfferResponse with undefined.\n   * @param options\n   */\n\n\n  readOffer(options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        resource: container\n      } = yield this.read();\n      const path = \"/offers\";\n      const url = container._self;\n      const response = yield this.clientContext.queryFeed({\n        path,\n        resourceId: \"\",\n        resourceType: ResourceType.offer,\n        query: `SELECT * from root where root.resource = \"${url}\"`,\n        resultFn: result => result.Offers,\n        options\n      });\n      const offer = response.result[0] ? new Offer(this.database.client, response.result[0].id, this.clientContext) : undefined;\n      return new OfferResponse(response.result[0], response.headers, response.code, offer);\n    });\n  }\n\n  getQueryPlan(query) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const path = getPathFromLink(this.url);\n      return this.clientContext.getQueryPlan(path + \"/docs\", ResourceType.item, getIdFromLink(this.url), query);\n    });\n  }\n\n  readPartitionKeyRanges(feedOptions) {\n    feedOptions = feedOptions || {};\n    return this.clientContext.queryPartitionKeyRanges(this.url, undefined, feedOptions);\n  }\n\n}","map":{"version":3,"sources":["../../../src/client/Container/Container.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ClientContext } from \"../../ClientContext\";\nimport {\n  createDocumentCollectionUri,\n  getIdFromLink,\n  getPathFromLink,\n  isResourceValid,\n  ResourceType\n} from \"../../common\";\nimport { PartitionKeyDefinition } from \"../../documents\";\nimport { SqlQuerySpec } from \"../../queryExecutionContext\";\nimport { QueryIterator } from \"../../queryIterator\";\nimport { FeedOptions, RequestOptions, ResourceResponse, Response } from \"../../request\";\nimport { PartitionedQueryExecutionInfo } from \"../../request/ErrorResponse\";\nimport { Conflict, Conflicts } from \"../Conflict\";\nimport { Database } from \"../Database\";\nimport { Item, Items } from \"../Item\";\nimport { Scripts } from \"../Script/Scripts\";\nimport { ContainerDefinition } from \"./ContainerDefinition\";\nimport { ContainerResponse } from \"./ContainerResponse\";\nimport { PartitionKeyRange } from \"./PartitionKeyRange\";\nimport { Offer, OfferDefinition } from \"../Offer\";\nimport { OfferResponse } from \"../Offer/OfferResponse\";\nimport { Resource } from \"../Resource\";\n\n/**\n * Operations for reading, replacing, or deleting a specific, existing container by id.\n *\n * @see {@link Containers} for creating new containers, and reading/querying all containers; use `.containers`.\n *\n * Note: all these operations make calls against a fixed budget.\n * You should design your system such that these calls scale sublinearly with your application.\n * For instance, do not call `container(id).read()` before every single `item.read()` call, to ensure the container exists;\n * do this once on application start up.\n */\nexport class Container {\n  private $items: Items;\n  /**\n   * Operations for creating new items, and reading/querying all items\n   *\n   * For reading, replacing, or deleting an existing item, use `.item(id)`.\n   *\n   * @example Create a new item\n   * ```typescript\n   * const {body: createdItem} = await container.items.create({id: \"<item id>\", properties: {}});\n   * ```\n   */\n  public get items(): Items {\n    if (!this.$items) {\n      this.$items = new Items(this, this.clientContext);\n    }\n    return this.$items;\n  }\n\n  private $scripts: Scripts;\n  /**\n   * All operations for Stored Procedures, Triggers, and User Defined Functions\n   */\n  public get scripts(): Scripts {\n    if (!this.$scripts) {\n      this.$scripts = new Scripts(this, this.clientContext);\n    }\n    return this.$scripts;\n  }\n\n  private $conflicts: Conflicts;\n  /**\n   * Opertaions for reading and querying conflicts for the given container.\n   *\n   * For reading or deleting a specific conflict, use `.conflict(id)`.\n   */\n  public get conflicts(): Conflicts {\n    if (!this.$conflicts) {\n      this.$conflicts = new Conflicts(this, this.clientContext);\n    }\n    return this.$conflicts;\n  }\n\n  /**\n   * Returns a reference URL to the resource. Used for linking in Permissions.\n   */\n  public get url() {\n    return createDocumentCollectionUri(this.database.id, this.id);\n  }\n\n  /**\n   * Returns a container instance. Note: You should get this from `database.container(id)`, rather than creating your own object.\n   * @param database The parent {@link Database}.\n   * @param id The id of the given container.\n   * @hidden\n   */\n  constructor(\n    public readonly database: Database,\n    public readonly id: string,\n    private readonly clientContext: ClientContext\n  ) {}\n\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Item} by id.\n   *\n   * Use `.items` for creating new items, or querying/reading all items.\n   *\n   * @param id The id of the {@link Item}.\n   * @param partitionKeyValue The value of the {@link Item} partition key\n   * @example Replace an item\n   * const {body: replacedItem} = await container.item(\"<item id>\", \"<partition key value>\").replace({id: \"<item id>\", title: \"Updated post\", authorID: 5});\n   */\n  public item(id: string, partitionKeyValue?: any): Item {\n    return new Item(this, id, partitionKeyValue, this.clientContext);\n  }\n\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Conflict} by id.\n   *\n   * Use `.conflicts` for creating new conflicts, or querying/reading all conflicts.\n   * @param id The id of the {@link Conflict}.\n   */\n  public conflict(id: string): Conflict {\n    return new Conflict(this, id, this.clientContext);\n  }\n\n  /** Read the container's definition */\n  public async read(options?: RequestOptions): Promise<ContainerResponse> {\n    const path = getPathFromLink(this.url);\n    const id = getIdFromLink(this.url);\n\n    const response = await this.clientContext.read<ContainerDefinition>({\n      path,\n      resourceType: ResourceType.container,\n      resourceId: id,\n      options\n    });\n    this.clientContext.partitionKeyDefinitionCache[this.url] = response.result.partitionKey;\n    return new ContainerResponse(response.result, response.headers, response.code, this);\n  }\n\n  /** Replace the container's definition */\n  public async replace(\n    body: ContainerDefinition,\n    options?: RequestOptions\n  ): Promise<ContainerResponse> {\n    const err = {};\n    if (!isResourceValid(body, err)) {\n      throw err;\n    }\n\n    const path = getPathFromLink(this.url);\n    const id = getIdFromLink(this.url);\n\n    const response = await this.clientContext.replace<ContainerDefinition>({\n      body,\n      path,\n      resourceType: ResourceType.container,\n      resourceId: id,\n      options\n    });\n    return new ContainerResponse(response.result, response.headers, response.code, this);\n  }\n\n  /** Delete the container */\n  public async delete(options?: RequestOptions): Promise<ContainerResponse> {\n    const path = getPathFromLink(this.url);\n    const id = getIdFromLink(this.url);\n\n    const response = await this.clientContext.delete<ContainerDefinition>({\n      path,\n      resourceType: ResourceType.container,\n      resourceId: id,\n      options\n    });\n    return new ContainerResponse(response.result, response.headers, response.code, this);\n  }\n\n  /**\n   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.\n   * @deprecated This method has been renamed to readPartitionKeyDefinition.\n   * @param {string} collectionLink   - Link to the collection whose partition key needs to be extracted.\n   * @param {function} callback       - \\\n   * The arguments to the callback are(in order): error, partitionKeyDefinition, response object and response headers\n   */\n  public async getPartitionKeyDefinition(): Promise<ResourceResponse<PartitionKeyDefinition>> {\n    return this.readPartitionKeyDefinition();\n  }\n\n  /**\n   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.\n   * @ignore\n   * @param {string} collectionLink   - Link to the collection whose partition key needs to be extracted.\n   * @param {function} callback       - \\\n   * The arguments to the callback are(in order): error, partitionKeyDefinition, response object and response headers\n   */\n  public async readPartitionKeyDefinition(): Promise<ResourceResponse<PartitionKeyDefinition>> {\n    // $ISSUE-felixfan-2016-03-17: Make name based path and link based path use the same key\n    // $ISSUE-felixfan-2016-03-17: Refresh partitionKeyDefinitionCache when necessary\n    if (this.url in this.clientContext.partitionKeyDefinitionCache) {\n      return new ResourceResponse<PartitionKeyDefinition>(\n        this.clientContext.partitionKeyDefinitionCache[this.url],\n        {},\n        0\n      );\n    }\n\n    const { headers, statusCode } = await this.read();\n    return new ResourceResponse<PartitionKeyDefinition>(\n      this.clientContext.partitionKeyDefinitionCache[this.url],\n      headers,\n      statusCode\n    );\n  }\n\n  /**\n   * Gets offer on container. If none exists, returns an OfferResponse with undefined.\n   * @param options\n   */\n  public async readOffer(options: RequestOptions = {}): Promise<OfferResponse> {\n    const { resource: container } = await this.read();\n    const path = \"/offers\";\n    const url = container._self;\n    const response = await this.clientContext.queryFeed<OfferDefinition & Resource[]>({\n      path,\n      resourceId: \"\",\n      resourceType: ResourceType.offer,\n      query: `SELECT * from root where root.resource = \"${url}\"`,\n      resultFn: (result) => result.Offers,\n      options\n    });\n    const offer = response.result[0]\n      ? new Offer(this.database.client, response.result[0].id, this.clientContext)\n      : undefined;\n    return new OfferResponse(response.result[0], response.headers, response.code, offer);\n  }\n\n  public async getQueryPlan(\n    query: string | SqlQuerySpec\n  ): Promise<Response<PartitionedQueryExecutionInfo>> {\n    const path = getPathFromLink(this.url);\n    return this.clientContext.getQueryPlan(\n      path + \"/docs\",\n      ResourceType.item,\n      getIdFromLink(this.url),\n      query\n    );\n  }\n\n  public readPartitionKeyRanges(feedOptions?: FeedOptions): QueryIterator<PartitionKeyRange> {\n    feedOptions = feedOptions || {};\n    return this.clientContext.queryPartitionKeyRanges(this.url, undefined, feedOptions);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}