{"ast":null,"code":"import { __awaiter } from \"tslib\"; // Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { v4 as uuid } from \"uuid\";\nimport { ChangeFeedIterator } from \"../../ChangeFeedIterator\";\nimport { getIdFromLink, getPathFromLink, isResourceValid, ResourceType } from \"../../common\";\nimport { extractPartitionKey } from \"../../extractPartitionKey\";\nimport { QueryIterator } from \"../../queryIterator\";\nimport { Item } from \"./Item\";\nimport { ItemResponse } from \"./ItemResponse\";\nimport { isKeyInRange, getPartitionKeyToHash, decorateOperation } from \"../../utils/batch\";\nimport { hashV1PartitionKey } from \"../../utils/hashing/v1\";\nimport { hashV2PartitionKey } from \"../../utils/hashing/v2\";\n/**\n * @ignore\n * @param options\n */\n\nfunction isChangeFeedOptions(options) {\n  const optionsType = typeof options;\n  return options && !(optionsType === \"string\" || optionsType === \"boolean\" || optionsType === \"number\");\n}\n/**\n * Operations for creating new items, and reading/querying all items\n *\n * @see {@link Item} for reading, replacing, or deleting an existing container; use `.item(id)`.\n */\n\n\nexport class Items {\n  /**\n   * Create an instance of {@link Items} linked to the parent {@link Container}.\n   * @param container The parent container.\n   * @hidden\n   */\n  constructor(container, clientContext) {\n    this.container = container;\n    this.clientContext = clientContext;\n  }\n\n  query(query, options = {}) {\n    const path = getPathFromLink(this.container.url, ResourceType.item);\n    const id = getIdFromLink(this.container.url);\n\n    const fetchFunction = innerOptions => {\n      return this.clientContext.queryFeed({\n        path,\n        resourceType: ResourceType.item,\n        resourceId: id,\n        resultFn: result => result ? result.Documents : [],\n        query,\n        options: innerOptions,\n        partitionKey: options.partitionKey\n      });\n    };\n\n    return new QueryIterator(this.clientContext, query, options, fetchFunction, this.container.url, ResourceType.item);\n  }\n\n  readChangeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions) {\n    if (isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {\n      return this.changeFeed(partitionKeyOrChangeFeedOptions);\n    } else {\n      return this.changeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions);\n    }\n  }\n\n  changeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions) {\n    let partitionKey;\n\n    if (!changeFeedOptions && isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {\n      partitionKey = undefined;\n      changeFeedOptions = partitionKeyOrChangeFeedOptions;\n    } else if (partitionKeyOrChangeFeedOptions !== undefined && !isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {\n      partitionKey = partitionKeyOrChangeFeedOptions;\n    }\n\n    if (!changeFeedOptions) {\n      changeFeedOptions = {};\n    }\n\n    const path = getPathFromLink(this.container.url, ResourceType.item);\n    const id = getIdFromLink(this.container.url);\n    return new ChangeFeedIterator(this.clientContext, id, path, partitionKey, changeFeedOptions);\n  }\n\n  readAll(options) {\n    return this.query(\"SELECT * from c\", options);\n  }\n  /**\n   * Create an item.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param body Represents the body of the item. Can contain any number of user defined properties.\n   * @param options Used for modifying the request (for instance, specifying the partition key).\n   */\n\n\n  create(body, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Generate random document id if the id is missing in the payload and\n      // options.disableAutomaticIdGeneration != true\n      if ((body.id === undefined || body.id === \"\") && !options.disableAutomaticIdGeneration) {\n        body.id = uuid();\n      }\n\n      const {\n        resource: partitionKeyDefinition\n      } = yield this.container.readPartitionKeyDefinition();\n      const partitionKey = extractPartitionKey(body, partitionKeyDefinition);\n      const err = {};\n\n      if (!isResourceValid(body, err)) {\n        throw err;\n      }\n\n      const path = getPathFromLink(this.container.url, ResourceType.item);\n      const id = getIdFromLink(this.container.url);\n      const response = yield this.clientContext.create({\n        body,\n        path,\n        resourceType: ResourceType.item,\n        resourceId: id,\n        options,\n        partitionKey\n      });\n      const ref = new Item(this.container, response.result.id, partitionKey, this.clientContext);\n      return new ItemResponse(response.result, response.headers, response.code, response.substatus, ref);\n    });\n  }\n\n  upsert(body, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        resource: partitionKeyDefinition\n      } = yield this.container.readPartitionKeyDefinition();\n      const partitionKey = extractPartitionKey(body, partitionKeyDefinition); // Generate random document id if the id is missing in the payload and\n      // options.disableAutomaticIdGeneration != true\n\n      if ((body.id === undefined || body.id === \"\") && !options.disableAutomaticIdGeneration) {\n        body.id = uuid();\n      }\n\n      const err = {};\n\n      if (!isResourceValid(body, err)) {\n        throw err;\n      }\n\n      const path = getPathFromLink(this.container.url, ResourceType.item);\n      const id = getIdFromLink(this.container.url);\n      const response = yield this.clientContext.upsert({\n        body,\n        path,\n        resourceType: ResourceType.item,\n        resourceId: id,\n        options,\n        partitionKey\n      });\n      const ref = new Item(this.container, response.result.id, partitionKey, this.clientContext);\n      return new ItemResponse(response.result, response.headers, response.code, response.substatus, ref);\n    });\n  }\n  /**\n   * Execute bulk operations on items.\n   *\n   * Bulk takes an array of Operations which are typed based on what the operation does.\n   * The choices are: Create, Upsert, Read, Replace, and Delete\n   *\n   * Usage example:\n   *\n   * // partitionKey is optional at the top level if present in the resourceBody\n   * const operations: OperationInput[] = [\n   *    {\n   *       operationType: \"Create\",\n   *       resourceBody: { id: \"doc1\", name: \"sample\", key: \"A\" }\n   *    },\n   *    {\n   *       operationType: \"Upsert\",\n   *       partitionKey: 'A',\n   *       resourceBody: { id: \"doc2\", name: \"other\", key: \"A\" }\n   *    }\n   * ]\n   *\n   * await database.container.items.bulk(operation)\n   *\n   * @param operations. List of operations. Limit 100\n   * @param options Used for modifying the request.\n   */\n\n\n  bulk(operations, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        resources: partitionKeyRanges\n      } = yield this.container.readPartitionKeyRanges().fetchAll();\n      const {\n        resource: definition\n      } = yield this.container.getPartitionKeyDefinition();\n      const batches = partitionKeyRanges.map(keyRange => {\n        return {\n          min: keyRange.minInclusive,\n          max: keyRange.maxExclusive,\n          rangeId: keyRange.id,\n          indexes: [],\n          operations: []\n        };\n      });\n      operations.map(operation => decorateOperation(operation, definition)).forEach((operation, index) => {\n        const partitionProp = definition.paths[0].replace(\"/\", \"\");\n        const isV2 = definition.version && definition.version === 2;\n        const toHashKey = getPartitionKeyToHash(operation, partitionProp);\n        const hashed = isV2 ? hashV2PartitionKey(toHashKey) : hashV1PartitionKey(toHashKey);\n        const batchForKey = batches.find(batch => {\n          return isKeyInRange(batch.min, batch.max, hashed);\n        });\n        batchForKey.operations.push(operation);\n        batchForKey.indexes.push(index);\n      });\n      const path = getPathFromLink(this.container.url, ResourceType.item);\n      const orderedResponses = [];\n      yield Promise.all(batches.filter(batch => batch.operations.length).map(batch => __awaiter(this, void 0, void 0, function* () {\n        if (batch.operations.length > 100) {\n          throw new Error(\"Cannot run bulk request with more than 100 operations per partition\");\n        }\n\n        try {\n          const response = yield this.clientContext.bulk({\n            body: batch.operations,\n            partitionKeyRangeId: batch.rangeId,\n            path,\n            resourceId: this.container.url,\n            options\n          });\n          response.result.forEach((operationResponse, index) => {\n            orderedResponses[batch.indexes[index]] = operationResponse;\n          });\n        } catch (err) {\n          // In the case of 410 errors, we need to recompute the partition key ranges\n          // and redo the batch request, however, 410 errors occur for unsupported\n          // partition key types as well since we don't support them, so for now we throw\n          if (err.code === 410) {\n            throw new Error(\"Partition key error. Either the partitions have split or an operation has an unsupported partitionKey type\");\n          }\n\n          throw new Error(`Bulk request errored with: ${err.message}`);\n        }\n      })));\n      return orderedResponses;\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/client/Item/Items.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { v4 as uuid } from \"uuid\";\nimport { ChangeFeedIterator } from \"../../ChangeFeedIterator\";\nimport { ChangeFeedOptions } from \"../../ChangeFeedOptions\";\nimport { ClientContext } from \"../../ClientContext\";\nimport { getIdFromLink, getPathFromLink, isResourceValid, ResourceType } from \"../../common\";\nimport { extractPartitionKey } from \"../../extractPartitionKey\";\nimport { FetchFunctionCallback, SqlQuerySpec } from \"../../queryExecutionContext\";\nimport { QueryIterator } from \"../../queryIterator\";\nimport { FeedOptions, RequestOptions } from \"../../request\";\nimport { Container, PartitionKeyRange } from \"../Container\";\nimport { Item } from \"./Item\";\nimport { ItemDefinition } from \"./ItemDefinition\";\nimport { ItemResponse } from \"./ItemResponse\";\nimport {\n  Batch,\n  isKeyInRange,\n  Operation,\n  getPartitionKeyToHash,\n  decorateOperation,\n  OperationResponse,\n  OperationInput\n} from \"../../utils/batch\";\nimport { hashV1PartitionKey } from \"../../utils/hashing/v1\";\nimport { hashV2PartitionKey } from \"../../utils/hashing/v2\";\n\n/**\n * @ignore\n * @param options\n */\nfunction isChangeFeedOptions(options: unknown): options is ChangeFeedOptions {\n  const optionsType = typeof options;\n  return (\n    options && !(optionsType === \"string\" || optionsType === \"boolean\" || optionsType === \"number\")\n  );\n}\n\n/**\n * Operations for creating new items, and reading/querying all items\n *\n * @see {@link Item} for reading, replacing, or deleting an existing container; use `.item(id)`.\n */\nexport class Items {\n  /**\n   * Create an instance of {@link Items} linked to the parent {@link Container}.\n   * @param container The parent container.\n   * @hidden\n   */\n  constructor(\n    public readonly container: Container,\n    private readonly clientContext: ClientContext\n  ) {}\n\n  /**\n   * Queries all items.\n   * @param query Query configuration for the operation. See {@link SqlQuerySpec} for more info on how to configure a query.\n   * @param options Used for modifying the request (for instance, specifying the partition key).\n   * @example Read all items to array.\n   * ```typescript\n   * const querySpec: SqlQuerySpec = {\n   *   query: \"SELECT * FROM Families f WHERE f.lastName = @lastName\",\n   *   parameters: [\n   *     {name: \"@lastName\", value: \"Hendricks\"}\n   *   ]\n   * };\n   * const {result: items} = await items.query(querySpec).fetchAll();\n   * ```\n   */\n  public query(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;\n  /**\n   * Queries all items.\n   * @param query Query configuration for the operation. See {@link SqlQuerySpec} for more info on how to configure a query.\n   * @param options Used for modifying the request (for instance, specifying the partition key).\n   * @example Read all items to array.\n   * ```typescript\n   * const querySpec: SqlQuerySpec = {\n   *   query: \"SELECT firstname FROM Families f WHERE f.lastName = @lastName\",\n   *   parameters: [\n   *     {name: \"@lastName\", value: \"Hendricks\"}\n   *   ]\n   * };\n   * const {result: items} = await items.query<{firstName: string}>(querySpec).fetchAll();\n   * ```\n   */\n  public query<T>(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;\n  public query<T>(query: string | SqlQuerySpec, options: FeedOptions = {}): QueryIterator<T> {\n    const path = getPathFromLink(this.container.url, ResourceType.item);\n    const id = getIdFromLink(this.container.url);\n\n    const fetchFunction: FetchFunctionCallback = (innerOptions: FeedOptions) => {\n      return this.clientContext.queryFeed({\n        path,\n        resourceType: ResourceType.item,\n        resourceId: id,\n        resultFn: (result) => (result ? result.Documents : []),\n        query,\n        options: innerOptions,\n        partitionKey: options.partitionKey\n      });\n    };\n\n    return new QueryIterator(\n      this.clientContext,\n      query,\n      options,\n      fetchFunction,\n      this.container.url,\n      ResourceType.item\n    );\n  }\n\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   *\n   * @param partitionKey\n   * @param changeFeedOptions\n   * @deprecated Use `changeFeed` instead.\n   *\n   * @example Read from the beginning of the change feed.\n   * ```javascript\n   * const iterator = items.readChangeFeed({ startFromBeginning: true });\n   * const firstPage = await iterator.fetchNext();\n   * const firstPageResults = firstPage.result\n   * const secondPage = await iterator.fetchNext();\n   * ```\n   */\n  public readChangeFeed(\n    partitionKey: string | number | boolean,\n    changeFeedOptions?: ChangeFeedOptions\n  ): ChangeFeedIterator<any>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `changeFeed` instead.\n   *\n   * @param changeFeedOptions\n   */\n  public readChangeFeed(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<any>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `changeFeed` instead.\n   *\n   * @param partitionKey\n   * @param changeFeedOptions\n   */\n  public readChangeFeed<T>(\n    partitionKey: string | number | boolean,\n    changeFeedOptions?: ChangeFeedOptions\n  ): ChangeFeedIterator<T>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `changeFeed` instead.\n   *\n   * @param changeFeedOptions\n   */\n  public readChangeFeed<T>(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<T>;\n  public readChangeFeed<T>(\n    partitionKeyOrChangeFeedOptions?: string | number | boolean | ChangeFeedOptions,\n    changeFeedOptions?: ChangeFeedOptions\n  ): ChangeFeedIterator<T> {\n    if (isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {\n      return this.changeFeed(partitionKeyOrChangeFeedOptions);\n    } else {\n      return this.changeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions);\n    }\n  }\n\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   *\n   * @param partitionKey\n   * @param changeFeedOptions\n   *\n   * @example Read from the beginning of the change feed.\n   * ```javascript\n   * const iterator = items.readChangeFeed({ startFromBeginning: true });\n   * const firstPage = await iterator.fetchNext();\n   * const firstPageResults = firstPage.result\n   * const secondPage = await iterator.fetchNext();\n   * ```\n   */\n  public changeFeed(\n    partitionKey: string | number | boolean,\n    changeFeedOptions?: ChangeFeedOptions\n  ): ChangeFeedIterator<any>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   *\n   * @param changeFeedOptions\n   */\n  public changeFeed(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<any>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   *\n   * @param partitionKey\n   * @param changeFeedOptions\n   */\n  public changeFeed<T>(\n    partitionKey: string | number | boolean,\n    changeFeedOptions?: ChangeFeedOptions\n  ): ChangeFeedIterator<T>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   *\n   * @param changeFeedOptions\n   */\n  public changeFeed<T>(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<T>;\n  public changeFeed<T>(\n    partitionKeyOrChangeFeedOptions?: string | number | boolean | ChangeFeedOptions,\n    changeFeedOptions?: ChangeFeedOptions\n  ): ChangeFeedIterator<T> {\n    let partitionKey: string | number | boolean;\n    if (!changeFeedOptions && isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {\n      partitionKey = undefined;\n      changeFeedOptions = partitionKeyOrChangeFeedOptions;\n    } else if (\n      partitionKeyOrChangeFeedOptions !== undefined &&\n      !isChangeFeedOptions(partitionKeyOrChangeFeedOptions)\n    ) {\n      partitionKey = partitionKeyOrChangeFeedOptions;\n    }\n\n    if (!changeFeedOptions) {\n      changeFeedOptions = {};\n    }\n\n    const path = getPathFromLink(this.container.url, ResourceType.item);\n    const id = getIdFromLink(this.container.url);\n    return new ChangeFeedIterator<T>(this.clientContext, id, path, partitionKey, changeFeedOptions);\n  }\n\n  /**\n   * Read all items.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param options Used for modifying the request (for instance, specifying the partition key).\n   * @example Read all items to array.\n   * ```typescript\n   * const {body: containerList} = await items.readAll().fetchAll();\n   * ```\n   */\n  public readAll(options?: FeedOptions): QueryIterator<ItemDefinition>;\n  /**\n   * Read all items.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param options Used for modifying the request (for instance, specifying the partition key).\n   * @example Read all items to array.\n   * ```typescript\n   * const {body: containerList} = await items.readAll().fetchAll();\n   * ```\n   */\n  public readAll<T extends ItemDefinition>(options?: FeedOptions): QueryIterator<T>;\n  public readAll<T extends ItemDefinition>(options?: FeedOptions): QueryIterator<T> {\n    return this.query<T>(\"SELECT * from c\", options);\n  }\n\n  /**\n   * Create an item.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param body Represents the body of the item. Can contain any number of user defined properties.\n   * @param options Used for modifying the request (for instance, specifying the partition key).\n   */\n  public async create<T extends ItemDefinition = any>(\n    body: T,\n    options: RequestOptions = {}\n  ): Promise<ItemResponse<T>> {\n    // Generate random document id if the id is missing in the payload and\n    // options.disableAutomaticIdGeneration != true\n    if ((body.id === undefined || body.id === \"\") && !options.disableAutomaticIdGeneration) {\n      body.id = uuid();\n    }\n\n    const { resource: partitionKeyDefinition } = await this.container.readPartitionKeyDefinition();\n    const partitionKey = extractPartitionKey(body, partitionKeyDefinition);\n\n    const err = {};\n    if (!isResourceValid(body, err)) {\n      throw err;\n    }\n\n    const path = getPathFromLink(this.container.url, ResourceType.item);\n    const id = getIdFromLink(this.container.url);\n\n    const response = await this.clientContext.create<T>({\n      body,\n      path,\n      resourceType: ResourceType.item,\n      resourceId: id,\n      options,\n      partitionKey\n    });\n\n    const ref = new Item(\n      this.container,\n      (response.result as any).id,\n      partitionKey,\n      this.clientContext\n    );\n    return new ItemResponse(\n      response.result,\n      response.headers,\n      response.code,\n      response.substatus,\n      ref\n    );\n  }\n\n  /**\n   * Upsert an item.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param body Represents the body of the item. Can contain any number of user defined properties.\n   * @param options Used for modifying the request (for instance, specifying the partition key).\n   */\n  public async upsert(body: any, options?: RequestOptions): Promise<ItemResponse<ItemDefinition>>;\n  /**\n   * Upsert an item.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param body Represents the body of the item. Can contain any number of user defined properties.\n   * @param options Used for modifying the request (for instance, specifying the partition key).\n   */\n  public async upsert<T extends ItemDefinition>(\n    body: T,\n    options?: RequestOptions\n  ): Promise<ItemResponse<T>>;\n  public async upsert<T extends ItemDefinition>(\n    body: T,\n    options: RequestOptions = {}\n  ): Promise<ItemResponse<T>> {\n    const { resource: partitionKeyDefinition } = await this.container.readPartitionKeyDefinition();\n    const partitionKey = extractPartitionKey(body, partitionKeyDefinition);\n\n    // Generate random document id if the id is missing in the payload and\n    // options.disableAutomaticIdGeneration != true\n    if ((body.id === undefined || body.id === \"\") && !options.disableAutomaticIdGeneration) {\n      body.id = uuid();\n    }\n\n    const err = {};\n    if (!isResourceValid(body, err)) {\n      throw err;\n    }\n\n    const path = getPathFromLink(this.container.url, ResourceType.item);\n    const id = getIdFromLink(this.container.url);\n\n    const response = await this.clientContext.upsert<T>({\n      body,\n      path,\n      resourceType: ResourceType.item,\n      resourceId: id,\n      options,\n      partitionKey\n    });\n\n    const ref = new Item(\n      this.container,\n      (response.result as any).id,\n      partitionKey,\n      this.clientContext\n    );\n    return new ItemResponse(\n      response.result,\n      response.headers,\n      response.code,\n      response.substatus,\n      ref\n    );\n  }\n\n  /**\n   * Execute bulk operations on items.\n   *\n   * Bulk takes an array of Operations which are typed based on what the operation does.\n   * The choices are: Create, Upsert, Read, Replace, and Delete\n   *\n   * Usage example:\n   *\n   * // partitionKey is optional at the top level if present in the resourceBody\n   * const operations: OperationInput[] = [\n   *    {\n   *       operationType: \"Create\",\n   *       resourceBody: { id: \"doc1\", name: \"sample\", key: \"A\" }\n   *    },\n   *    {\n   *       operationType: \"Upsert\",\n   *       partitionKey: 'A',\n   *       resourceBody: { id: \"doc2\", name: \"other\", key: \"A\" }\n   *    }\n   * ]\n   *\n   * await database.container.items.bulk(operation)\n   *\n   * @param operations. List of operations. Limit 100\n   * @param options Used for modifying the request.\n   */\n  public async bulk(\n    operations: OperationInput[],\n    options?: RequestOptions\n  ): Promise<OperationResponse[]> {\n    const {\n      resources: partitionKeyRanges\n    } = await this.container.readPartitionKeyRanges().fetchAll();\n    const { resource: definition } = await this.container.getPartitionKeyDefinition();\n    const batches: Batch[] = partitionKeyRanges.map((keyRange: PartitionKeyRange) => {\n      return {\n        min: keyRange.minInclusive,\n        max: keyRange.maxExclusive,\n        rangeId: keyRange.id,\n        indexes: [],\n        operations: []\n      };\n    });\n    operations\n      .map((operation) => decorateOperation(operation, definition))\n      .forEach((operation: Operation, index: number) => {\n        const partitionProp = definition.paths[0].replace(\"/\", \"\");\n        const isV2 = definition.version && definition.version === 2;\n        const toHashKey = getPartitionKeyToHash(operation, partitionProp);\n        const hashed = isV2 ? hashV2PartitionKey(toHashKey) : hashV1PartitionKey(toHashKey);\n        const batchForKey = batches.find((batch: Batch) => {\n          return isKeyInRange(batch.min, batch.max, hashed);\n        });\n        batchForKey.operations.push(operation);\n        batchForKey.indexes.push(index);\n      });\n\n    const path = getPathFromLink(this.container.url, ResourceType.item);\n\n    const orderedResponses: OperationResponse[] = [];\n    await Promise.all(\n      batches\n        .filter((batch: Batch) => batch.operations.length)\n        .map(async (batch: Batch) => {\n          if (batch.operations.length > 100) {\n            throw new Error(\"Cannot run bulk request with more than 100 operations per partition\");\n          }\n          try {\n            const response = await this.clientContext.bulk({\n              body: batch.operations,\n              partitionKeyRangeId: batch.rangeId,\n              path,\n              resourceId: this.container.url,\n              options\n            });\n            response.result.forEach((operationResponse: OperationResponse, index: number) => {\n              orderedResponses[batch.indexes[index]] = operationResponse;\n            });\n          } catch (err) {\n            // In the case of 410 errors, we need to recompute the partition key ranges\n            // and redo the batch request, however, 410 errors occur for unsupported\n            // partition key types as well since we don't support them, so for now we throw\n            if (err.code === 410) {\n              throw new Error(\n                \"Partition key error. Either the partitions have split or an operation has an unsupported partitionKey type\"\n              );\n            }\n            throw new Error(`Bulk request errored with: ${err.message}`);\n          }\n        })\n    );\n    return orderedResponses;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}