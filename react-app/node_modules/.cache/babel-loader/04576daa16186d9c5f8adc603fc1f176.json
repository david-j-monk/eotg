{"ast":null,"code":"import { __awaiter } from \"tslib\"; // Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationType, ResourceType, isReadRequest } from \"./common\";\n/**\n * @hidden\n * This internal class implements the logic for endpoint management for geo-replicated database accounts.\n * @property {object} client                       - The document client instance.\n * @property {string} defaultEndpoint              - The endpoint used to create the client instance.\n * @property {bool} enableEndpointDiscovery        - Flag to enable/disable automatic redirecting of requests\n *                                                   based on read/write operations.\n * @property {Array} preferredLocations            - List of azure regions to be used as preferred locations\n *                                                   for read requests.\n * @property {bool} isEndpointCacheInitialized     - Flag to determine whether the endpoint cache is initialized or not.\n */\n\nexport class GlobalEndpointManager {\n  /**\n   * @constructor GlobalEndpointManager\n   * @param {object} options                          - The document client instance.\n   */\n  constructor(options, readDatabaseAccount) {\n    this.readDatabaseAccount = readDatabaseAccount;\n    this.options = options;\n    this.defaultEndpoint = options.endpoint;\n    this.enableEndpointDiscovery = options.connectionPolicy.enableEndpointDiscovery;\n    this.isRefreshing = false;\n    this.preferredLocations = this.options.connectionPolicy.preferredLocations;\n  }\n  /**\n   * Gets the current read endpoint from the endpoint cache.\n   */\n\n\n  getReadEndpoint() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.resolveServiceEndpoint(ResourceType.item, OperationType.Read);\n    });\n  }\n  /**\n   * Gets the current write endpoint from the endpoint cache.\n   */\n\n\n  getWriteEndpoint() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.resolveServiceEndpoint(ResourceType.item, OperationType.Replace);\n    });\n  }\n\n  getReadEndpoints() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.readableLocations.map(loc => loc.databaseAccountEndpoint);\n    });\n  }\n\n  getWriteEndpoints() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.writeableLocations.map(loc => loc.databaseAccountEndpoint);\n    });\n  }\n\n  markCurrentLocationUnavailableForRead(endpoint) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.refreshEndpointList();\n      const location = this.readableLocations.find(loc => loc.databaseAccountEndpoint === endpoint);\n\n      if (location) {\n        location.unavailable = true;\n      }\n    });\n  }\n\n  markCurrentLocationUnavailableForWrite(endpoint) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.refreshEndpointList();\n      const location = this.writeableLocations.find(loc => loc.databaseAccountEndpoint === endpoint);\n\n      if (location) {\n        location.unavailable = true;\n      }\n    });\n  }\n\n  canUseMultipleWriteLocations(resourceType, operationType) {\n    let canUse = this.options.connectionPolicy.useMultipleWriteLocations;\n\n    if (resourceType) {\n      canUse = canUse && (resourceType === ResourceType.item || resourceType === ResourceType.sproc && operationType === OperationType.Execute);\n    }\n\n    return canUse;\n  }\n\n  resolveServiceEndpoint(resourceType, operationType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // If endpoint discovery is disabled, always use the user provided endpoint\n      if (!this.options.connectionPolicy.enableEndpointDiscovery) {\n        return this.defaultEndpoint;\n      } // If getting the database account, always use the user provided endpoint\n\n\n      if (resourceType === ResourceType.none) {\n        return this.defaultEndpoint;\n      }\n\n      if (!this.readableLocations || !this.writeableLocations) {\n        const {\n          resource: databaseAccount\n        } = yield this.readDatabaseAccount({\n          urlConnection: this.defaultEndpoint\n        });\n        this.writeableLocations = databaseAccount.writableLocations;\n        this.readableLocations = databaseAccount.readableLocations;\n      }\n\n      const locations = isReadRequest(operationType) ? this.readableLocations : this.writeableLocations;\n      let location; // If we have preferred locations, try each one in order and use the first available one\n\n      if (this.preferredLocations && this.preferredLocations.length > 0) {\n        for (const preferredLocation of this.preferredLocations) {\n          location = locations.find(loc => loc.unavailable !== true && normalizeEndpoint(loc.name) === normalizeEndpoint(preferredLocation));\n\n          if (location) {\n            break;\n          }\n        }\n      } // If no preferred locations or one did not match, just grab the first one that is available\n\n\n      if (!location) {\n        location = locations.find(loc => {\n          return loc.unavailable !== true;\n        });\n      }\n\n      return location ? location.databaseAccountEndpoint : this.defaultEndpoint;\n    });\n  }\n  /**\n   * Refreshes the endpoint list by retrieving the writable and readable locations\n   *  from the geo-replicated database account and then updating the locations cache.\n   *   We skip the refreshing if enableEndpointDiscovery is set to False\n   */\n\n\n  refreshEndpointList() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isRefreshing && this.enableEndpointDiscovery) {\n        this.isRefreshing = true;\n        const databaseAccount = yield this.getDatabaseAccountFromAnyEndpoint();\n\n        if (databaseAccount) {\n          this.refreshEndpoints(databaseAccount);\n        }\n\n        this.isRefreshing = false;\n      }\n    });\n  }\n\n  refreshEndpoints(databaseAccount) {\n    for (const location of databaseAccount.writableLocations) {\n      const existingLocation = this.writeableLocations.find(loc => loc.name === location.name);\n\n      if (!existingLocation) {\n        this.writeableLocations.push(location);\n      }\n    }\n\n    for (const location of databaseAccount.writableLocations) {\n      const existingLocation = this.readableLocations.find(loc => loc.name === location.name);\n\n      if (!existingLocation) {\n        this.readableLocations.push(location);\n      }\n    }\n  }\n  /**\n   * Gets the database account first by using the default endpoint, and if that doesn't returns\n   * use the endpoints for the preferred locations in the order they are specified to get\n   * the database account.\n   * @memberof GlobalEndpointManager\n   * @instance\n   * @param {function} callback        - The callback function which takes databaseAccount(object) as an argument.\n   */\n\n\n  getDatabaseAccountFromAnyEndpoint() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const options = {\n          urlConnection: this.defaultEndpoint\n        };\n        const {\n          resource: databaseAccount\n        } = yield this.readDatabaseAccount(options);\n        return databaseAccount; // If for any reason(non - globaldb related), we are not able to get the database\n        // account from the above call to readDatabaseAccount,\n        // we would try to get this information from any of the preferred locations that the user\n        // might have specified (by creating a locational endpoint)\n        // and keeping eating the exception until we get the database account and return None at the end,\n        // if we are not able to get that info from any endpoints\n      } catch (err) {// TODO: Tracing\n      }\n\n      if (this.preferredLocations) {\n        for (const location of this.preferredLocations) {\n          try {\n            const locationalEndpoint = GlobalEndpointManager.getLocationalEndpoint(this.defaultEndpoint, location);\n            const options = {\n              urlConnection: locationalEndpoint\n            };\n            const {\n              resource: databaseAccount\n            } = yield this.readDatabaseAccount(options);\n\n            if (databaseAccount) {\n              return databaseAccount;\n            }\n          } catch (err) {// TODO: Tracing\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Gets the locational endpoint using the location name passed to it using the default endpoint.\n   * @memberof GlobalEndpointManager\n   * @instance\n   * @param {string} defaultEndpoint - The default endpoint to use for the endpoint.\n   * @param {string} locationName    - The location name for the azure region like \"East US\".\n   */\n\n\n  static getLocationalEndpoint(defaultEndpoint, locationName) {\n    // For defaultEndpoint like 'https://contoso.documents.azure.com:443/' parse it to generate URL format\n    // This defaultEndpoint should be global endpoint(and cannot be a locational endpoint)\n    // and we agreed to document that\n    const endpointUrl = new URL(defaultEndpoint); // hostname attribute in endpointUrl will return 'contoso.documents.azure.com'\n\n    if (endpointUrl.hostname) {\n      const hostnameParts = endpointUrl.hostname.toString().toLowerCase().split(\".\");\n\n      if (hostnameParts) {\n        // globalDatabaseAccountName will return 'contoso'\n        const globalDatabaseAccountName = hostnameParts[0]; // Prepare the locationalDatabaseAccountName as contoso-EastUS for location_name 'East US'\n\n        const locationalDatabaseAccountName = globalDatabaseAccountName + \"-\" + locationName.replace(\" \", \"\"); // Replace 'contoso' with 'contoso-EastUS' and\n        // return locationalEndpoint as https://contoso-EastUS.documents.azure.com:443/\n\n        const locationalEndpoint = defaultEndpoint.toLowerCase().replace(globalDatabaseAccountName, locationalDatabaseAccountName);\n        return locationalEndpoint;\n      }\n    }\n\n    return null;\n  }\n\n}\n\nfunction normalizeEndpoint(endpoint) {\n  return endpoint.split(\" \").join(\"\").toLowerCase();\n}","map":{"version":3,"sources":["../src/globalEndpointManager.ts"],"names":[],"mappings":"mCAAA;AACA;;AACA,SAAS,aAAT,EAAwB,YAAxB,EAAsC,aAAtC,QAA2D,UAA3D;AAMA;;;;;;;;;;;;AAWA,OAAM,MAAO,qBAAP,CAA4B;AAShC;;;;AAIA,EAAA,WAAA,CACE,OADF,EAEU,mBAFV,EAIiD;AAFvC,SAAA,mBAAA,GAAA,mBAAA;AAIR,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,eAAL,GAAuB,OAAO,CAAC,QAA/B;AACA,SAAK,uBAAL,GAA+B,OAAO,CAAC,gBAAR,CAAyB,uBAAxD;AACA,SAAK,YAAL,GAAoB,KAApB;AACA,SAAK,kBAAL,GAA0B,KAAK,OAAL,CAAa,gBAAb,CAA8B,kBAAxD;AACD;AAED;;;;;AAGa,EAAA,eAAe,GAAA;;AAC1B,aAAO,KAAK,sBAAL,CAA4B,YAAY,CAAC,IAAzC,EAA+C,aAAa,CAAC,IAA7D,CAAP;AACD,K;AAAA;AAED;;;;;AAGa,EAAA,gBAAgB,GAAA;;AAC3B,aAAO,KAAK,sBAAL,CAA4B,YAAY,CAAC,IAAzC,EAA+C,aAAa,CAAC,OAA7D,CAAP;AACD,K;AAAA;;AAEY,EAAA,gBAAgB,GAAA;;AAC3B,aAAO,KAAK,iBAAL,CAAuB,GAAvB,CAA4B,GAAD,IAAS,GAAG,CAAC,uBAAxC,CAAP;AACD,K;AAAA;;AAEY,EAAA,iBAAiB,GAAA;;AAC5B,aAAO,KAAK,kBAAL,CAAwB,GAAxB,CAA6B,GAAD,IAAS,GAAG,CAAC,uBAAzC,CAAP;AACD,K;AAAA;;AAEY,EAAA,qCAAqC,CAAC,QAAD,EAAiB;;AACjE,YAAM,KAAK,mBAAL,EAAN;AACA,YAAM,QAAQ,GAAG,KAAK,iBAAL,CAAuB,IAAvB,CAA6B,GAAD,IAAS,GAAG,CAAC,uBAAJ,KAAgC,QAArE,CAAjB;;AACA,UAAI,QAAJ,EAAc;AACZ,QAAA,QAAQ,CAAC,WAAT,GAAuB,IAAvB;AACD;AACF,K;AAAA;;AAEY,EAAA,sCAAsC,CAAC,QAAD,EAAiB;;AAClE,YAAM,KAAK,mBAAL,EAAN;AACA,YAAM,QAAQ,GAAG,KAAK,kBAAL,CAAwB,IAAxB,CACd,GAAD,IAAS,GAAG,CAAC,uBAAJ,KAAgC,QAD1B,CAAjB;;AAGA,UAAI,QAAJ,EAAc;AACZ,QAAA,QAAQ,CAAC,WAAT,GAAuB,IAAvB;AACD;AACF,K;AAAA;;AAEM,EAAA,4BAA4B,CACjC,YADiC,EAEjC,aAFiC,EAEJ;AAE7B,QAAI,MAAM,GAAG,KAAK,OAAL,CAAa,gBAAb,CAA8B,yBAA3C;;AAEA,QAAI,YAAJ,EAAkB;AAChB,MAAA,MAAM,GACJ,MAAM,KACL,YAAY,KAAK,YAAY,CAAC,IAA9B,IACE,YAAY,KAAK,YAAY,CAAC,KAA9B,IAAuC,aAAa,KAAK,aAAa,CAAC,OAFpE,CADR;AAID;;AAED,WAAO,MAAP;AACD;;AAEY,EAAA,sBAAsB,CAAC,YAAD,EAA6B,aAA7B,EAAyD;;AAC1F;AACA,UAAI,CAAC,KAAK,OAAL,CAAa,gBAAb,CAA8B,uBAAnC,EAA4D;AAC1D,eAAO,KAAK,eAAZ;AACD,O,CAED;;;AACA,UAAI,YAAY,KAAK,YAAY,CAAC,IAAlC,EAAwC;AACtC,eAAO,KAAK,eAAZ;AACD;;AAED,UAAI,CAAC,KAAK,iBAAN,IAA2B,CAAC,KAAK,kBAArC,EAAyD;AACvD,cAAM;AAAE,UAAA,QAAQ,EAAE;AAAZ,YAAgC,MAAM,KAAK,mBAAL,CAAyB;AACnE,UAAA,aAAa,EAAE,KAAK;AAD+C,SAAzB,CAA5C;AAGA,aAAK,kBAAL,GAA0B,eAAe,CAAC,iBAA1C;AACA,aAAK,iBAAL,GAAyB,eAAe,CAAC,iBAAzC;AACD;;AAED,YAAM,SAAS,GAAG,aAAa,CAAC,aAAD,CAAb,GACd,KAAK,iBADS,GAEd,KAAK,kBAFT;AAIA,UAAI,QAAJ,C,CACA;;AACA,UAAI,KAAK,kBAAL,IAA2B,KAAK,kBAAL,CAAwB,MAAxB,GAAiC,CAAhE,EAAmE;AACjE,aAAK,MAAM,iBAAX,IAAgC,KAAK,kBAArC,EAAyD;AACvD,UAAA,QAAQ,GAAG,SAAS,CAAC,IAAV,CACR,GAAD,IACE,GAAG,CAAC,WAAJ,KAAoB,IAApB,IACA,iBAAiB,CAAC,GAAG,CAAC,IAAL,CAAjB,KAAgC,iBAAiB,CAAC,iBAAD,CAH1C,CAAX;;AAKA,cAAI,QAAJ,EAAc;AACZ;AACD;AACF;AACF,O,CAED;;;AACA,UAAI,CAAC,QAAL,EAAe;AACb,QAAA,QAAQ,GAAG,SAAS,CAAC,IAAV,CAAgB,GAAD,IAAQ;AAChC,iBAAO,GAAG,CAAC,WAAJ,KAAoB,IAA3B;AACD,SAFU,CAAX;AAGD;;AAED,aAAO,QAAQ,GAAG,QAAQ,CAAC,uBAAZ,GAAsC,KAAK,eAA1D;AACD,K;AAAA;AAED;;;;;;;AAKa,EAAA,mBAAmB,GAAA;;AAC9B,UAAI,CAAC,KAAK,YAAN,IAAsB,KAAK,uBAA/B,EAAwD;AACtD,aAAK,YAAL,GAAoB,IAApB;AACA,cAAM,eAAe,GAAG,MAAM,KAAK,iCAAL,EAA9B;;AACA,YAAI,eAAJ,EAAqB;AACnB,eAAK,gBAAL,CAAsB,eAAtB;AACD;;AAED,aAAK,YAAL,GAAoB,KAApB;AACD;AACF,K;AAAA;;AAEO,EAAA,gBAAgB,CAAC,eAAD,EAAiC;AACvD,SAAK,MAAM,QAAX,IAAuB,eAAe,CAAC,iBAAvC,EAA0D;AACxD,YAAM,gBAAgB,GAAG,KAAK,kBAAL,CAAwB,IAAxB,CAA8B,GAAD,IAAS,GAAG,CAAC,IAAJ,KAAa,QAAQ,CAAC,IAA5D,CAAzB;;AACA,UAAI,CAAC,gBAAL,EAAuB;AACrB,aAAK,kBAAL,CAAwB,IAAxB,CAA6B,QAA7B;AACD;AACF;;AACD,SAAK,MAAM,QAAX,IAAuB,eAAe,CAAC,iBAAvC,EAA0D;AACxD,YAAM,gBAAgB,GAAG,KAAK,iBAAL,CAAuB,IAAvB,CAA6B,GAAD,IAAS,GAAG,CAAC,IAAJ,KAAa,QAAQ,CAAC,IAA3D,CAAzB;;AACA,UAAI,CAAC,gBAAL,EAAuB;AACrB,aAAK,iBAAL,CAAuB,IAAvB,CAA4B,QAA5B;AACD;AACF;AACF;AAED;;;;;;;;;;AAQc,EAAA,iCAAiC,GAAA;;AAC7C,UAAI;AACF,cAAM,OAAO,GAAG;AAAE,UAAA,aAAa,EAAE,KAAK;AAAtB,SAAhB;AACA,cAAM;AAAE,UAAA,QAAQ,EAAE;AAAZ,YAAgC,MAAM,KAAK,mBAAL,CAAyB,OAAzB,CAA5C;AACA,eAAO,eAAP,CAHE,CAIF;AACA;AACA;AACA;AACA;AACA;AACD,OAVD,CAUE,OAAO,GAAP,EAAY,CACZ;AACD;;AAED,UAAI,KAAK,kBAAT,EAA6B;AAC3B,aAAK,MAAM,QAAX,IAAuB,KAAK,kBAA5B,EAAgD;AAC9C,cAAI;AACF,kBAAM,kBAAkB,GAAG,qBAAqB,CAAC,qBAAtB,CACzB,KAAK,eADoB,EAEzB,QAFyB,CAA3B;AAIA,kBAAM,OAAO,GAAG;AAAE,cAAA,aAAa,EAAE;AAAjB,aAAhB;AACA,kBAAM;AAAE,cAAA,QAAQ,EAAE;AAAZ,gBAAgC,MAAM,KAAK,mBAAL,CAAyB,OAAzB,CAA5C;;AACA,gBAAI,eAAJ,EAAqB;AACnB,qBAAO,eAAP;AACD;AACF,WAVD,CAUE,OAAO,GAAP,EAAY,CACZ;AACD;AACF;AACF;AACF,K;AAAA;AAED;;;;;;;;;AAOQ,SAAO,qBAAP,CAA6B,eAA7B,EAAsD,YAAtD,EAA0E;AAChF;AACA;AACA;AACA,UAAM,WAAW,GAAG,IAAI,GAAJ,CAAQ,eAAR,CAApB,CAJgF,CAMhF;;AACA,QAAI,WAAW,CAAC,QAAhB,EAA0B;AACxB,YAAM,aAAa,GAAG,WAAW,CAAC,QAAZ,CACnB,QADmB,GAEnB,WAFmB,GAGnB,KAHmB,CAGb,GAHa,CAAtB;;AAIA,UAAI,aAAJ,EAAmB;AACjB;AACA,cAAM,yBAAyB,GAAG,aAAa,CAAC,CAAD,CAA/C,CAFiB,CAIjB;;AACA,cAAM,6BAA6B,GACjC,yBAAyB,GAAG,GAA5B,GAAkC,YAAY,CAAC,OAAb,CAAqB,GAArB,EAA0B,EAA1B,CADpC,CALiB,CAQjB;AACA;;AACA,cAAM,kBAAkB,GAAG,eAAe,CACvC,WADwB,GAExB,OAFwB,CAEhB,yBAFgB,EAEW,6BAFX,CAA3B;AAGA,eAAO,kBAAP;AACD;AACF;;AAED,WAAO,IAAP;AACD;;AAjP+B;;AAoPlC,SAAS,iBAAT,CAA2B,QAA3B,EAA2C;AACzC,SAAO,QAAQ,CACZ,KADI,CACE,GADF,EAEJ,IAFI,CAEC,EAFD,EAGJ,WAHI,EAAP;AAID","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { OperationType, ResourceType, isReadRequest } from \"./common\";\nimport { CosmosClientOptions } from \"./CosmosClientOptions\";\nimport { Location, DatabaseAccount } from \"./documents\";\nimport { RequestOptions } from \"./index\";\nimport { ResourceResponse } from \"./request\";\n\n/**\n * @hidden\n * This internal class implements the logic for endpoint management for geo-replicated database accounts.\n * @property {object} client                       - The document client instance.\n * @property {string} defaultEndpoint              - The endpoint used to create the client instance.\n * @property {bool} enableEndpointDiscovery        - Flag to enable/disable automatic redirecting of requests\n *                                                   based on read/write operations.\n * @property {Array} preferredLocations            - List of azure regions to be used as preferred locations\n *                                                   for read requests.\n * @property {bool} isEndpointCacheInitialized     - Flag to determine whether the endpoint cache is initialized or not.\n */\nexport class GlobalEndpointManager {\n  private defaultEndpoint: string;\n  public enableEndpointDiscovery: boolean;\n  private isRefreshing: boolean;\n  private options: CosmosClientOptions;\n  private preferredLocations: string[];\n  private writeableLocations: Location[];\n  private readableLocations: Location[];\n\n  /**\n   * @constructor GlobalEndpointManager\n   * @param {object} options                          - The document client instance.\n   */\n  constructor(\n    options: CosmosClientOptions,\n    private readDatabaseAccount: (\n      opts: RequestOptions\n    ) => Promise<ResourceResponse<DatabaseAccount>>\n  ) {\n    this.options = options;\n    this.defaultEndpoint = options.endpoint;\n    this.enableEndpointDiscovery = options.connectionPolicy.enableEndpointDiscovery;\n    this.isRefreshing = false;\n    this.preferredLocations = this.options.connectionPolicy.preferredLocations;\n  }\n\n  /**\n   * Gets the current read endpoint from the endpoint cache.\n   */\n  public async getReadEndpoint(): Promise<string> {\n    return this.resolveServiceEndpoint(ResourceType.item, OperationType.Read);\n  }\n\n  /**\n   * Gets the current write endpoint from the endpoint cache.\n   */\n  public async getWriteEndpoint(): Promise<string> {\n    return this.resolveServiceEndpoint(ResourceType.item, OperationType.Replace);\n  }\n\n  public async getReadEndpoints(): Promise<ReadonlyArray<string>> {\n    return this.readableLocations.map((loc) => loc.databaseAccountEndpoint);\n  }\n\n  public async getWriteEndpoints(): Promise<ReadonlyArray<string>> {\n    return this.writeableLocations.map((loc) => loc.databaseAccountEndpoint);\n  }\n\n  public async markCurrentLocationUnavailableForRead(endpoint: string) {\n    await this.refreshEndpointList();\n    const location = this.readableLocations.find((loc) => loc.databaseAccountEndpoint === endpoint);\n    if (location) {\n      location.unavailable = true;\n    }\n  }\n\n  public async markCurrentLocationUnavailableForWrite(endpoint: string) {\n    await this.refreshEndpointList();\n    const location = this.writeableLocations.find(\n      (loc) => loc.databaseAccountEndpoint === endpoint\n    );\n    if (location) {\n      location.unavailable = true;\n    }\n  }\n\n  public canUseMultipleWriteLocations(\n    resourceType?: ResourceType,\n    operationType?: OperationType\n  ): boolean {\n    let canUse = this.options.connectionPolicy.useMultipleWriteLocations;\n\n    if (resourceType) {\n      canUse =\n        canUse &&\n        (resourceType === ResourceType.item ||\n          (resourceType === ResourceType.sproc && operationType === OperationType.Execute));\n    }\n\n    return canUse;\n  }\n\n  public async resolveServiceEndpoint(resourceType: ResourceType, operationType: OperationType) {\n    // If endpoint discovery is disabled, always use the user provided endpoint\n    if (!this.options.connectionPolicy.enableEndpointDiscovery) {\n      return this.defaultEndpoint;\n    }\n\n    // If getting the database account, always use the user provided endpoint\n    if (resourceType === ResourceType.none) {\n      return this.defaultEndpoint;\n    }\n\n    if (!this.readableLocations || !this.writeableLocations) {\n      const { resource: databaseAccount } = await this.readDatabaseAccount({\n        urlConnection: this.defaultEndpoint\n      });\n      this.writeableLocations = databaseAccount.writableLocations;\n      this.readableLocations = databaseAccount.readableLocations;\n    }\n\n    const locations = isReadRequest(operationType)\n      ? this.readableLocations\n      : this.writeableLocations;\n\n    let location;\n    // If we have preferred locations, try each one in order and use the first available one\n    if (this.preferredLocations && this.preferredLocations.length > 0) {\n      for (const preferredLocation of this.preferredLocations) {\n        location = locations.find(\n          (loc) =>\n            loc.unavailable !== true &&\n            normalizeEndpoint(loc.name) === normalizeEndpoint(preferredLocation)\n        );\n        if (location) {\n          break;\n        }\n      }\n    }\n\n    // If no preferred locations or one did not match, just grab the first one that is available\n    if (!location) {\n      location = locations.find((loc) => {\n        return loc.unavailable !== true;\n      });\n    }\n\n    return location ? location.databaseAccountEndpoint : this.defaultEndpoint;\n  }\n\n  /**\n   * Refreshes the endpoint list by retrieving the writable and readable locations\n   *  from the geo-replicated database account and then updating the locations cache.\n   *   We skip the refreshing if enableEndpointDiscovery is set to False\n   */\n  public async refreshEndpointList(): Promise<void> {\n    if (!this.isRefreshing && this.enableEndpointDiscovery) {\n      this.isRefreshing = true;\n      const databaseAccount = await this.getDatabaseAccountFromAnyEndpoint();\n      if (databaseAccount) {\n        this.refreshEndpoints(databaseAccount);\n      }\n\n      this.isRefreshing = false;\n    }\n  }\n\n  private refreshEndpoints(databaseAccount: DatabaseAccount) {\n    for (const location of databaseAccount.writableLocations) {\n      const existingLocation = this.writeableLocations.find((loc) => loc.name === location.name);\n      if (!existingLocation) {\n        this.writeableLocations.push(location);\n      }\n    }\n    for (const location of databaseAccount.writableLocations) {\n      const existingLocation = this.readableLocations.find((loc) => loc.name === location.name);\n      if (!existingLocation) {\n        this.readableLocations.push(location);\n      }\n    }\n  }\n\n  /**\n   * Gets the database account first by using the default endpoint, and if that doesn't returns\n   * use the endpoints for the preferred locations in the order they are specified to get\n   * the database account.\n   * @memberof GlobalEndpointManager\n   * @instance\n   * @param {function} callback        - The callback function which takes databaseAccount(object) as an argument.\n   */\n  private async getDatabaseAccountFromAnyEndpoint(): Promise<DatabaseAccount> {\n    try {\n      const options = { urlConnection: this.defaultEndpoint };\n      const { resource: databaseAccount } = await this.readDatabaseAccount(options);\n      return databaseAccount;\n      // If for any reason(non - globaldb related), we are not able to get the database\n      // account from the above call to readDatabaseAccount,\n      // we would try to get this information from any of the preferred locations that the user\n      // might have specified (by creating a locational endpoint)\n      // and keeping eating the exception until we get the database account and return None at the end,\n      // if we are not able to get that info from any endpoints\n    } catch (err) {\n      // TODO: Tracing\n    }\n\n    if (this.preferredLocations) {\n      for (const location of this.preferredLocations) {\n        try {\n          const locationalEndpoint = GlobalEndpointManager.getLocationalEndpoint(\n            this.defaultEndpoint,\n            location\n          );\n          const options = { urlConnection: locationalEndpoint };\n          const { resource: databaseAccount } = await this.readDatabaseAccount(options);\n          if (databaseAccount) {\n            return databaseAccount;\n          }\n        } catch (err) {\n          // TODO: Tracing\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets the locational endpoint using the location name passed to it using the default endpoint.\n   * @memberof GlobalEndpointManager\n   * @instance\n   * @param {string} defaultEndpoint - The default endpoint to use for the endpoint.\n   * @param {string} locationName    - The location name for the azure region like \"East US\".\n   */\n  private static getLocationalEndpoint(defaultEndpoint: string, locationName: string) {\n    // For defaultEndpoint like 'https://contoso.documents.azure.com:443/' parse it to generate URL format\n    // This defaultEndpoint should be global endpoint(and cannot be a locational endpoint)\n    // and we agreed to document that\n    const endpointUrl = new URL(defaultEndpoint);\n\n    // hostname attribute in endpointUrl will return 'contoso.documents.azure.com'\n    if (endpointUrl.hostname) {\n      const hostnameParts = endpointUrl.hostname\n        .toString()\n        .toLowerCase()\n        .split(\".\");\n      if (hostnameParts) {\n        // globalDatabaseAccountName will return 'contoso'\n        const globalDatabaseAccountName = hostnameParts[0];\n\n        // Prepare the locationalDatabaseAccountName as contoso-EastUS for location_name 'East US'\n        const locationalDatabaseAccountName =\n          globalDatabaseAccountName + \"-\" + locationName.replace(\" \", \"\");\n\n        // Replace 'contoso' with 'contoso-EastUS' and\n        // return locationalEndpoint as https://contoso-EastUS.documents.azure.com:443/\n        const locationalEndpoint = defaultEndpoint\n          .toLowerCase()\n          .replace(globalDatabaseAccountName, locationalDatabaseAccountName);\n        return locationalEndpoint;\n      }\n    }\n\n    return null;\n  }\n}\n\nfunction normalizeEndpoint(endpoint: string) {\n  return endpoint\n    .split(\" \")\n    .join(\"\")\n    .toLowerCase();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}