{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { Constants } from \"../common/constants\";\nimport { PartitionKeyRangeCache } from \"./partitionKeyRangeCache\";\nimport { QueryRange } from \"./QueryRange\";\n/** @hidden */\n\nexport const PARITIONKEYRANGE = Constants.PartitionKeyRange;\n/** @hidden */\n\nexport class SmartRoutingMapProvider {\n  constructor(clientContext) {\n    this.partitionKeyRangeCache = new PartitionKeyRangeCache(clientContext);\n  }\n\n  static _secondRangeIsAfterFirstRange(range1, range2) {\n    if (typeof range1.max === \"undefined\") {\n      throw new Error(\"range1 must have max\");\n    }\n\n    if (typeof range2.min === \"undefined\") {\n      throw new Error(\"range2 must have min\");\n    }\n\n    if (range1.max > range2.min) {\n      // r.min < #previous_r.max\n      return false;\n    } else {\n      if (range1.max === range2.min && range1.isMaxInclusive && range2.isMinInclusive) {\n        // the inclusive ending endpoint of previous_r is the same as the inclusive beginning endpoint of r\n        // they share a point\n        return false;\n      }\n\n      return true;\n    }\n  }\n\n  static _isSortedAndNonOverlapping(ranges) {\n    for (let idx = 1; idx < ranges.length; idx++) {\n      const previousR = ranges[idx - 1];\n      const r = ranges[idx];\n\n      if (!this._secondRangeIsAfterFirstRange(previousR, r)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  static _stringMax(a, b) {\n    return a >= b ? a : b;\n  }\n\n  static _stringCompare(a, b) {\n    return a === b ? 0 : a > b ? 1 : -1;\n  }\n\n  static _subtractRange(r, partitionKeyRange) {\n    const left = this._stringMax(partitionKeyRange[PARITIONKEYRANGE.MaxExclusive], r.min);\n\n    const leftInclusive = this._stringCompare(left, r.min) === 0 ? r.isMinInclusive : false;\n    return new QueryRange(left, r.max, leftInclusive, r.isMaxInclusive);\n  }\n  /**\n   * Given the sorted ranges and a collection, invokes the callback on the list of overlapping partition key ranges\n   * @param {callback} callback - Function execute on the overlapping partition key ranges result,\n   *                              takes two parameters error, partition key ranges\n   * @param collectionLink\n   * @param sortedRanges\n   * @ignore\n   */\n\n\n  getOverlappingRanges(collectionLink, sortedRanges) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // validate if the list is non- overlapping and sorted                             TODO: any PartitionKeyRanges\n      if (!SmartRoutingMapProvider._isSortedAndNonOverlapping(sortedRanges)) {\n        throw new Error(\"the list of ranges is not a non-overlapping sorted ranges\");\n      }\n\n      let partitionKeyRanges = []; // TODO: any ParitionKeyRanges\n\n      if (sortedRanges.length === 0) {\n        return partitionKeyRanges;\n      }\n\n      const collectionRoutingMap = yield this.partitionKeyRangeCache.onCollectionRoutingMap(collectionLink);\n      let index = 0;\n      let currentProvidedRange = sortedRanges[index];\n\n      while (true) {\n        if (currentProvidedRange.isEmpty()) {\n          // skip and go to the next item\n          if (++index >= sortedRanges.length) {\n            return partitionKeyRanges;\n          }\n\n          currentProvidedRange = sortedRanges[index];\n          continue;\n        }\n\n        let queryRange;\n\n        if (partitionKeyRanges.length > 0) {\n          queryRange = SmartRoutingMapProvider._subtractRange(currentProvidedRange, partitionKeyRanges[partitionKeyRanges.length - 1]);\n        } else {\n          queryRange = currentProvidedRange;\n        }\n\n        const overlappingRanges = collectionRoutingMap.getOverlappingRanges(queryRange);\n\n        if (overlappingRanges.length <= 0) {\n          throw new Error(`error: returned overlapping ranges for queryRange ${queryRange} is empty`);\n        }\n\n        partitionKeyRanges = partitionKeyRanges.concat(overlappingRanges);\n        const lastKnownTargetRange = QueryRange.parsePartitionKeyRange(partitionKeyRanges[partitionKeyRanges.length - 1]);\n\n        if (!lastKnownTargetRange) {\n          throw new Error(\"expected lastKnowTargetRange to be truthy\");\n        } // the overlapping ranges must contain the requested range\n\n\n        if (SmartRoutingMapProvider._stringCompare(currentProvidedRange.max, lastKnownTargetRange.max) > 0) {\n          throw new Error(`error: returned overlapping ranges ${overlappingRanges} \\\n        does not contain the requested range ${queryRange}`);\n        } // the current range is contained in partitionKeyRanges just move forward\n\n\n        if (++index >= sortedRanges.length) {\n          return partitionKeyRanges;\n        }\n\n        currentProvidedRange = sortedRanges[index];\n\n        while (SmartRoutingMapProvider._stringCompare(currentProvidedRange.max, lastKnownTargetRange.max) <= 0) {\n          // the current range is covered too.just move forward\n          if (++index >= sortedRanges.length) {\n            return partitionKeyRanges;\n          }\n\n          currentProvidedRange = sortedRanges[index];\n        }\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../../src/routing/smartRoutingMapProvider.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ClientContext } from \"../ClientContext\";\nimport { Constants } from \"../common/constants\";\nimport { PartitionKeyRangeCache } from \"./partitionKeyRangeCache\";\nimport { QueryRange } from \"./QueryRange\";\n\n/** @hidden */\nexport const PARITIONKEYRANGE = Constants.PartitionKeyRange;\n\n/** @hidden */\nexport class SmartRoutingMapProvider {\n  private partitionKeyRangeCache: PartitionKeyRangeCache;\n\n  constructor(clientContext: ClientContext) {\n    this.partitionKeyRangeCache = new PartitionKeyRangeCache(clientContext);\n  }\n  private static _secondRangeIsAfterFirstRange(range1: QueryRange, range2: QueryRange) {\n    if (typeof range1.max === \"undefined\") {\n      throw new Error(\"range1 must have max\");\n    }\n\n    if (typeof range2.min === \"undefined\") {\n      throw new Error(\"range2 must have min\");\n    }\n\n    if (range1.max > range2.min) {\n      // r.min < #previous_r.max\n      return false;\n    } else {\n      if (range1.max === range2.min && range1.isMaxInclusive && range2.isMinInclusive) {\n        // the inclusive ending endpoint of previous_r is the same as the inclusive beginning endpoint of r\n        // they share a point\n        return false;\n      }\n      return true;\n    }\n  }\n\n  private static _isSortedAndNonOverlapping(ranges: QueryRange[]) {\n    for (let idx = 1; idx < ranges.length; idx++) {\n      const previousR = ranges[idx - 1];\n      const r = ranges[idx];\n      if (!this._secondRangeIsAfterFirstRange(previousR, r)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static _stringMax(a: string, b: string) {\n    return a >= b ? a : b;\n  }\n\n  private static _stringCompare(a: string, b: string) {\n    return a === b ? 0 : a > b ? 1 : -1;\n  }\n\n  private static _subtractRange(r: QueryRange, partitionKeyRange: any) {\n    const left = this._stringMax(partitionKeyRange[PARITIONKEYRANGE.MaxExclusive], r.min);\n    const leftInclusive = this._stringCompare(left, r.min) === 0 ? r.isMinInclusive : false;\n    return new QueryRange(left, r.max, leftInclusive, r.isMaxInclusive);\n  }\n\n  /**\n   * Given the sorted ranges and a collection, invokes the callback on the list of overlapping partition key ranges\n   * @param {callback} callback - Function execute on the overlapping partition key ranges result,\n   *                              takes two parameters error, partition key ranges\n   * @param collectionLink\n   * @param sortedRanges\n   * @ignore\n   */\n  public async getOverlappingRanges(\n    collectionLink: string,\n    sortedRanges: QueryRange[]\n  ): Promise<any[]> {\n    // validate if the list is non- overlapping and sorted                             TODO: any PartitionKeyRanges\n    if (!SmartRoutingMapProvider._isSortedAndNonOverlapping(sortedRanges)) {\n      throw new Error(\"the list of ranges is not a non-overlapping sorted ranges\");\n    }\n\n    let partitionKeyRanges: any[] = []; // TODO: any ParitionKeyRanges\n\n    if (sortedRanges.length === 0) {\n      return partitionKeyRanges;\n    }\n\n    const collectionRoutingMap = await this.partitionKeyRangeCache.onCollectionRoutingMap(\n      collectionLink\n    );\n\n    let index = 0;\n    let currentProvidedRange = sortedRanges[index];\n    while (true) {\n      if (currentProvidedRange.isEmpty()) {\n        // skip and go to the next item\n        if (++index >= sortedRanges.length) {\n          return partitionKeyRanges;\n        }\n        currentProvidedRange = sortedRanges[index];\n        continue;\n      }\n\n      let queryRange;\n      if (partitionKeyRanges.length > 0) {\n        queryRange = SmartRoutingMapProvider._subtractRange(\n          currentProvidedRange,\n          partitionKeyRanges[partitionKeyRanges.length - 1]\n        );\n      } else {\n        queryRange = currentProvidedRange;\n      }\n\n      const overlappingRanges = collectionRoutingMap.getOverlappingRanges(queryRange);\n      if (overlappingRanges.length <= 0) {\n        throw new Error(`error: returned overlapping ranges for queryRange ${queryRange} is empty`);\n      }\n      partitionKeyRanges = partitionKeyRanges.concat(overlappingRanges);\n\n      const lastKnownTargetRange = QueryRange.parsePartitionKeyRange(\n        partitionKeyRanges[partitionKeyRanges.length - 1]\n      );\n      if (!lastKnownTargetRange) {\n        throw new Error(\"expected lastKnowTargetRange to be truthy\");\n      }\n      // the overlapping ranges must contain the requested range\n\n      if (\n        SmartRoutingMapProvider._stringCompare(currentProvidedRange.max, lastKnownTargetRange.max) >\n        0\n      ) {\n        throw new Error(`error: returned overlapping ranges ${overlappingRanges} \\\n        does not contain the requested range ${queryRange}`);\n      }\n\n      // the current range is contained in partitionKeyRanges just move forward\n      if (++index >= sortedRanges.length) {\n        return partitionKeyRanges;\n      }\n      currentProvidedRange = sortedRanges[index];\n\n      while (\n        SmartRoutingMapProvider._stringCompare(\n          currentProvidedRange.max,\n          lastKnownTargetRange.max\n        ) <= 0\n      ) {\n        // the current range is covered too.just move forward\n        if (++index >= sortedRanges.length) {\n          return partitionKeyRanges;\n        }\n        currentProvidedRange = sortedRanges[index];\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}