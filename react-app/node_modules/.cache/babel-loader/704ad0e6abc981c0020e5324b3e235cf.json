{"ast":null,"code":"import JSBI from \"jsbi\";\nimport { BytePrefix } from \"./prefix\";\nexport function writeNumberForBinaryEncodingJSBI(hash) {\n  let payload = encodeNumberAsUInt64JSBI(hash);\n  let outputStream = Buffer.from(BytePrefix.Number, \"hex\");\n  const firstChunk = JSBI.asUintN(64, JSBI.signedRightShift(payload, JSBI.BigInt(56)));\n  outputStream = Buffer.concat([outputStream, Buffer.from(firstChunk.toString(16), \"hex\")]);\n  payload = JSBI.asUintN(64, JSBI.leftShift(JSBI.BigInt(payload), JSBI.BigInt(0x8)));\n  let byteToWrite = JSBI.BigInt(0);\n  let firstIteration = false;\n  let shifted;\n  let padded;\n\n  do {\n    if (!firstIteration) {\n      // we pad because after shifting because we will produce characters like \"f\" or similar,\n      // which cannot be encoded as hex in a buffer because they are invalid hex\n      // https://github.com/nodejs/node/issues/24491\n      padded = byteToWrite.toString(16).padStart(2, \"0\");\n\n      if (padded !== \"00\") {\n        outputStream = Buffer.concat([outputStream, Buffer.from(padded, \"hex\")]);\n      }\n    } else {\n      firstIteration = false;\n    }\n\n    shifted = JSBI.asUintN(64, JSBI.signedRightShift(payload, JSBI.BigInt(56)));\n    byteToWrite = JSBI.asUintN(64, JSBI.bitwiseOr(shifted, JSBI.BigInt(0x01)));\n    payload = JSBI.asUintN(64, JSBI.leftShift(payload, JSBI.BigInt(7)));\n  } while (JSBI.notEqual(payload, JSBI.BigInt(0)));\n\n  const lastChunk = JSBI.asUintN(64, JSBI.bitwiseAnd(byteToWrite, JSBI.BigInt(0xfe))); // we pad because after shifting because we will produce characters like \"f\" or similar,\n  // which cannot be encoded as hex in a buffer because they are invalid hex\n  // https://github.com/nodejs/node/issues/24491\n\n  padded = lastChunk.toString(16).padStart(2, \"0\");\n\n  if (padded !== \"00\") {\n    outputStream = Buffer.concat([outputStream, Buffer.from(padded, \"hex\")]);\n  }\n\n  return outputStream;\n}\n\nfunction encodeNumberAsUInt64JSBI(value) {\n  const rawValueBits = getRawBitsJSBI(value);\n  const mask = JSBI.BigInt(0x8000000000000000);\n  const returned = rawValueBits < mask ? JSBI.bitwiseXor(rawValueBits, mask) : JSBI.add(JSBI.bitwiseNot(rawValueBits), JSBI.BigInt(1));\n  return returned;\n}\n\nexport function doubleToByteArrayJSBI(double) {\n  const output = Buffer.alloc(8);\n  const lng = getRawBitsJSBI(double);\n\n  for (let i = 0; i < 8; i++) {\n    output[i] = JSBI.toNumber(JSBI.bitwiseAnd(JSBI.signedRightShift(lng, JSBI.multiply(JSBI.BigInt(i), JSBI.BigInt(8))), JSBI.BigInt(0xff)));\n  }\n\n  return output;\n}\n\nfunction getRawBitsJSBI(value) {\n  const view = new DataView(new ArrayBuffer(8));\n  view.setFloat64(0, value);\n  return JSBI.BigInt(`0x${buf2hex(view.buffer)}`);\n}\n\nfunction buf2hex(buffer) {\n  return Array.prototype.map.call(new Uint8Array(buffer), x => (\"00\" + x.toString(16)).slice(-2)).join(\"\");\n}","map":{"version":3,"sources":["../../../../src/utils/hashing/encoding/number.ts"],"names":[],"mappings":"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","sourcesContent":["import JSBI from \"jsbi\";\nimport { BytePrefix } from \"./prefix\";\n\nexport function writeNumberForBinaryEncodingJSBI(hash: number) {\n  let payload = encodeNumberAsUInt64JSBI(hash);\n  let outputStream = Buffer.from(BytePrefix.Number, \"hex\");\n  const firstChunk = JSBI.asUintN(64, JSBI.signedRightShift(payload, JSBI.BigInt(56)));\n\n  outputStream = Buffer.concat([outputStream, Buffer.from(firstChunk.toString(16), \"hex\")]);\n  payload = JSBI.asUintN(64, JSBI.leftShift(JSBI.BigInt(payload), JSBI.BigInt(0x8)));\n\n  let byteToWrite = JSBI.BigInt(0);\n  let firstIteration = false;\n  let shifted: JSBI;\n  let padded: string;\n\n  do {\n    if (!firstIteration) {\n      // we pad because after shifting because we will produce characters like \"f\" or similar,\n      // which cannot be encoded as hex in a buffer because they are invalid hex\n      // https://github.com/nodejs/node/issues/24491\n      padded = byteToWrite.toString(16).padStart(2, \"0\");\n      if (padded !== \"00\") {\n        outputStream = Buffer.concat([outputStream, Buffer.from(padded, \"hex\")]);\n      }\n    } else {\n      firstIteration = false;\n    }\n\n    shifted = JSBI.asUintN(64, JSBI.signedRightShift(payload, JSBI.BigInt(56)));\n    byteToWrite = JSBI.asUintN(64, JSBI.bitwiseOr(shifted, JSBI.BigInt(0x01)));\n    payload = JSBI.asUintN(64, JSBI.leftShift(payload, JSBI.BigInt(7)));\n  } while (JSBI.notEqual(payload, JSBI.BigInt(0)));\n\n  const lastChunk = JSBI.asUintN(64, JSBI.bitwiseAnd(byteToWrite, JSBI.BigInt(0xfe)));\n  // we pad because after shifting because we will produce characters like \"f\" or similar,\n  // which cannot be encoded as hex in a buffer because they are invalid hex\n  // https://github.com/nodejs/node/issues/24491\n  padded = lastChunk.toString(16).padStart(2, \"0\");\n  if (padded !== \"00\") {\n    outputStream = Buffer.concat([outputStream, Buffer.from(padded, \"hex\")]);\n  }\n\n  return outputStream;\n}\n\nfunction encodeNumberAsUInt64JSBI(value: number) {\n  const rawValueBits = getRawBitsJSBI(value);\n  const mask = JSBI.BigInt(0x8000000000000000);\n  const returned =\n    rawValueBits < mask\n      ? JSBI.bitwiseXor(rawValueBits, mask)\n      : JSBI.add(JSBI.bitwiseNot(rawValueBits), JSBI.BigInt(1));\n  return returned;\n}\n\nexport function doubleToByteArrayJSBI(double: number) {\n  const output: Buffer = Buffer.alloc(8);\n  const lng = getRawBitsJSBI(double);\n  for (let i = 0; i < 8; i++) {\n    output[i] = JSBI.toNumber(\n      JSBI.bitwiseAnd(\n        JSBI.signedRightShift(lng, JSBI.multiply(JSBI.BigInt(i), JSBI.BigInt(8))),\n        JSBI.BigInt(0xff)\n      )\n    );\n  }\n  return output;\n}\n\nfunction getRawBitsJSBI(value: number) {\n  const view = new DataView(new ArrayBuffer(8));\n  view.setFloat64(0, value);\n  return JSBI.BigInt(`0x${buf2hex(view.buffer)}`);\n}\n\nfunction buf2hex(buffer: ArrayBuffer) {\n  return Array.prototype.map\n    .call(new Uint8Array(buffer), (x: number) => (\"00\" + x.toString(16)).slice(-2))\n    .join(\"\");\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}