{"ast":null,"code":"import { doubleToByteArrayJSBI, writeNumberForBinaryEncodingJSBI } from \"./encoding/number\";\nimport { writeStringForBinaryEncoding } from \"./encoding/string\";\nimport { BytePrefix } from \"./encoding/prefix\";\nimport MurmurHash from \"./murmurHash\";\nconst MAX_STRING_CHARS = 100;\nexport function hashV1PartitionKey(partitionKey) {\n  const toHash = prefixKeyByType(partitionKey);\n  const hash = MurmurHash.x86.hash32(toHash);\n  const encodedJSBI = writeNumberForBinaryEncodingJSBI(hash);\n  const encodedValue = encodeByType(partitionKey);\n  return Buffer.concat([encodedJSBI, encodedValue]).toString(\"hex\").toUpperCase();\n}\n\nfunction prefixKeyByType(key) {\n  let bytes;\n\n  switch (typeof key) {\n    case \"string\":\n      const truncated = key.substr(0, MAX_STRING_CHARS);\n      bytes = Buffer.concat([Buffer.from(BytePrefix.String, \"hex\"), Buffer.from(truncated), Buffer.from(BytePrefix.Undefined, \"hex\")]);\n      return bytes;\n\n    case \"number\":\n      const numberBytes = doubleToByteArrayJSBI(key);\n      bytes = Buffer.concat([Buffer.from(BytePrefix.Number, \"hex\"), numberBytes]);\n      return bytes;\n\n    case \"boolean\":\n      const prefix = key ? BytePrefix.True : BytePrefix.False;\n      return Buffer.from(prefix, \"hex\");\n\n    case \"object\":\n      if (key === null) {\n        return Buffer.from(BytePrefix.Null, \"hex\");\n      }\n\n      return Buffer.from(BytePrefix.Undefined, \"hex\");\n\n    case \"undefined\":\n      return Buffer.from(BytePrefix.Undefined, \"hex\");\n  }\n}\n\nfunction encodeByType(key) {\n  switch (typeof key) {\n    case \"string\":\n      const truncated = key.substr(0, MAX_STRING_CHARS);\n      return writeStringForBinaryEncoding(truncated);\n\n    case \"number\":\n      const encodedJSBI = writeNumberForBinaryEncodingJSBI(key);\n      return encodedJSBI;\n\n    case \"boolean\":\n      const prefix = key ? BytePrefix.True : BytePrefix.False;\n      return Buffer.from(prefix, \"hex\");\n\n    case \"object\":\n      if (key === null) {\n        return Buffer.from(BytePrefix.Null, \"hex\");\n      }\n\n      return Buffer.from(BytePrefix.Undefined, \"hex\");\n\n    case \"undefined\":\n      return Buffer.from(BytePrefix.Undefined, \"hex\");\n  }\n}","map":{"version":3,"sources":["../../../src/utils/hashing/v1.ts"],"names":[],"mappings":"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","sourcesContent":["import { doubleToByteArrayJSBI, writeNumberForBinaryEncodingJSBI } from \"./encoding/number\";\nimport { writeStringForBinaryEncoding } from \"./encoding/string\";\nimport { BytePrefix } from \"./encoding/prefix\";\nimport MurmurHash from \"./murmurHash\";\n\nconst MAX_STRING_CHARS = 100;\n\ntype v1Key = string | number | null | {} | undefined;\n\nexport function hashV1PartitionKey(partitionKey: v1Key): string {\n  const toHash = prefixKeyByType(partitionKey);\n  const hash = MurmurHash.x86.hash32(toHash);\n  const encodedJSBI = writeNumberForBinaryEncodingJSBI(hash);\n  const encodedValue = encodeByType(partitionKey);\n  return Buffer.concat([encodedJSBI, encodedValue])\n    .toString(\"hex\")\n    .toUpperCase();\n}\n\nfunction prefixKeyByType(key: v1Key) {\n  let bytes: Buffer;\n  switch (typeof key) {\n    case \"string\":\n      const truncated = key.substr(0, MAX_STRING_CHARS);\n      bytes = Buffer.concat([\n        Buffer.from(BytePrefix.String, \"hex\"),\n        Buffer.from(truncated),\n        Buffer.from(BytePrefix.Undefined, \"hex\")\n      ]);\n      return bytes;\n    case \"number\":\n      const numberBytes = doubleToByteArrayJSBI(key);\n      bytes = Buffer.concat([Buffer.from(BytePrefix.Number, \"hex\"), numberBytes]);\n      return bytes;\n    case \"boolean\":\n      const prefix = key ? BytePrefix.True : BytePrefix.False;\n      return Buffer.from(prefix, \"hex\");\n    case \"object\":\n      if (key === null) {\n        return Buffer.from(BytePrefix.Null, \"hex\");\n      }\n      return Buffer.from(BytePrefix.Undefined, \"hex\");\n    case \"undefined\":\n      return Buffer.from(BytePrefix.Undefined, \"hex\");\n  }\n}\n\nfunction encodeByType(key: v1Key) {\n  switch (typeof key) {\n    case \"string\":\n      const truncated = key.substr(0, MAX_STRING_CHARS);\n      return writeStringForBinaryEncoding(truncated);\n    case \"number\":\n      const encodedJSBI = writeNumberForBinaryEncodingJSBI(key);\n      return encodedJSBI;\n    case \"boolean\":\n      const prefix = key ? BytePrefix.True : BytePrefix.False;\n      return Buffer.from(prefix, \"hex\");\n    case \"object\":\n      if (key === null) {\n        return Buffer.from(BytePrefix.Null, \"hex\");\n      }\n      return Buffer.from(BytePrefix.Undefined, \"hex\");\n    case \"undefined\":\n      return Buffer.from(BytePrefix.Undefined, \"hex\");\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}