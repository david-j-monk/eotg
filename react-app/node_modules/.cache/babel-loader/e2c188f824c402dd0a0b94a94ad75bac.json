{"ast":null,"code":"import { __awaiter } from \"tslib\"; // Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isReadRequest } from \"../common\";\n/**\n * This class implements the retry policy for session consistent reads.\n * @hidden\n */\n\nexport class SessionRetryPolicy {\n  /**\n   * @constructor SessionReadRetryPolicy\n   * @param {object} globalEndpointManager                           - The GlobalEndpointManager instance.\n   * @property {object} request                                      - The Http request information\n   */\n  constructor(globalEndpointManager, resourceType, operationType, connectionPolicy) {\n    this.globalEndpointManager = globalEndpointManager;\n    this.resourceType = resourceType;\n    this.operationType = operationType;\n    this.connectionPolicy = connectionPolicy;\n    /** Current retry attempt count. */\n\n    this.currentRetryAttemptCount = 0;\n    /** Retry interval in milliseconds. */\n\n    this.retryAfterInMs = 0;\n  }\n  /**\n   * Determines whether the request should be retried or not.\n   * @param {object} err - Error returned by the request.\n   * @param {function} callback - The callback function which takes bool argument which specifies whether the request\\\n   * will be retried or not.\n   */\n\n\n  shouldRetry(err, retryContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!err) {\n        return false;\n      }\n\n      if (!retryContext) {\n        return false;\n      }\n\n      if (!this.connectionPolicy.enableEndpointDiscovery) {\n        return false;\n      }\n\n      if (this.globalEndpointManager.canUseMultipleWriteLocations(this.resourceType, this.operationType)) {\n        // If we can write to multiple locations, we should against every write endpoint until we succeed\n        const endpoints = isReadRequest(this.operationType) ? yield this.globalEndpointManager.getReadEndpoints() : yield this.globalEndpointManager.getWriteEndpoints();\n\n        if (this.currentRetryAttemptCount > endpoints.length) {\n          return false;\n        } else {\n          retryContext.retryCount = ++this.currentRetryAttemptCount - 1;\n          retryContext.retryRequestOnPreferredLocations = this.currentRetryAttemptCount > 1;\n          retryContext.clearSessionTokenNotAvailable = this.currentRetryAttemptCount === endpoints.length;\n          return true;\n        }\n      } else {\n        if (this.currentRetryAttemptCount > 1) {\n          return false;\n        } else {\n          retryContext.retryCount = ++this.currentRetryAttemptCount - 1;\n          retryContext.retryRequestOnPreferredLocations = false; // Forces all operations to primary write endpoint\n\n          retryContext.clearSessionTokenNotAvailable = true;\n          return true;\n        }\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../../src/retry/sessionRetryPolicy.ts"],"names":[],"mappings":"mCAAA;AACA;;AACA,SAAS,aAAT,QAA2D,WAA3D;AAOA;;;;;AAIA,OAAM,MAAO,kBAAP,CAAyB;AAM7B;;;;;AAKA,EAAA,WAAA,CACU,qBADV,EAEU,YAFV,EAGU,aAHV,EAIU,gBAJV,EAI4C;AAHlC,SAAA,qBAAA,GAAA,qBAAA;AACA,SAAA,YAAA,GAAA,YAAA;AACA,SAAA,aAAA,GAAA,aAAA;AACA,SAAA,gBAAA,GAAA,gBAAA;AAdV;;AACO,SAAA,wBAAA,GAA2B,CAA3B;AACP;;AACO,SAAA,cAAA,GAAiB,CAAjB;AAYH;AAEJ;;;;;;;;AAMa,EAAA,WAAW,CAAC,GAAD,EAAqB,YAArB,EAAgD;;AACtE,UAAI,CAAC,GAAL,EAAU;AACR,eAAO,KAAP;AACD;;AAED,UAAI,CAAC,YAAL,EAAmB;AACjB,eAAO,KAAP;AACD;;AAED,UAAI,CAAC,KAAK,gBAAL,CAAsB,uBAA3B,EAAoD;AAClD,eAAO,KAAP;AACD;;AAED,UACE,KAAK,qBAAL,CAA2B,4BAA3B,CAAwD,KAAK,YAA7D,EAA2E,KAAK,aAAhF,CADF,EAEE;AACA;AACA,cAAM,SAAS,GAAG,aAAa,CAAC,KAAK,aAAN,CAAb,GACd,MAAM,KAAK,qBAAL,CAA2B,gBAA3B,EADQ,GAEd,MAAM,KAAK,qBAAL,CAA2B,iBAA3B,EAFV;;AAGA,YAAI,KAAK,wBAAL,GAAgC,SAAS,CAAC,MAA9C,EAAsD;AACpD,iBAAO,KAAP;AACD,SAFD,MAEO;AACL,UAAA,YAAY,CAAC,UAAb,GAA0B,EAAE,KAAK,wBAAP,GAAkC,CAA5D;AACA,UAAA,YAAY,CAAC,gCAAb,GAAgD,KAAK,wBAAL,GAAgC,CAAhF;AACA,UAAA,YAAY,CAAC,6BAAb,GACE,KAAK,wBAAL,KAAkC,SAAS,CAAC,MAD9C;AAEA,iBAAO,IAAP;AACD;AACF,OAhBD,MAgBO;AACL,YAAI,KAAK,wBAAL,GAAgC,CAApC,EAAuC;AACrC,iBAAO,KAAP;AACD,SAFD,MAEO;AACL,UAAA,YAAY,CAAC,UAAb,GAA0B,EAAE,KAAK,wBAAP,GAAkC,CAA5D;AACA,UAAA,YAAY,CAAC,gCAAb,GAAgD,KAAhD,CAFK,CAEkD;;AACvD,UAAA,YAAY,CAAC,6BAAb,GAA6C,IAA7C;AACA,iBAAO,IAAP;AACD;AACF;AACF,K;AAAA;;AA/D4B","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { isReadRequest, OperationType, ResourceType } from \"../common\";\nimport { ConnectionPolicy } from \"../documents\";\nimport { GlobalEndpointManager } from \"../globalEndpointManager\";\nimport { ErrorResponse } from \"../request\";\nimport { RetryContext } from \"./RetryContext\";\nimport { RetryPolicy } from \"./RetryPolicy\";\n\n/**\n * This class implements the retry policy for session consistent reads.\n * @hidden\n */\nexport class SessionRetryPolicy implements RetryPolicy {\n  /** Current retry attempt count. */\n  public currentRetryAttemptCount = 0;\n  /** Retry interval in milliseconds. */\n  public retryAfterInMs = 0;\n\n  /**\n   * @constructor SessionReadRetryPolicy\n   * @param {object} globalEndpointManager                           - The GlobalEndpointManager instance.\n   * @property {object} request                                      - The Http request information\n   */\n  constructor(\n    private globalEndpointManager: GlobalEndpointManager,\n    private resourceType: ResourceType,\n    private operationType: OperationType,\n    private connectionPolicy: ConnectionPolicy\n  ) {}\n\n  /**\n   * Determines whether the request should be retried or not.\n   * @param {object} err - Error returned by the request.\n   * @param {function} callback - The callback function which takes bool argument which specifies whether the request\\\n   * will be retried or not.\n   */\n  public async shouldRetry(err: ErrorResponse, retryContext?: RetryContext): Promise<boolean> {\n    if (!err) {\n      return false;\n    }\n\n    if (!retryContext) {\n      return false;\n    }\n\n    if (!this.connectionPolicy.enableEndpointDiscovery) {\n      return false;\n    }\n\n    if (\n      this.globalEndpointManager.canUseMultipleWriteLocations(this.resourceType, this.operationType)\n    ) {\n      // If we can write to multiple locations, we should against every write endpoint until we succeed\n      const endpoints = isReadRequest(this.operationType)\n        ? await this.globalEndpointManager.getReadEndpoints()\n        : await this.globalEndpointManager.getWriteEndpoints();\n      if (this.currentRetryAttemptCount > endpoints.length) {\n        return false;\n      } else {\n        retryContext.retryCount = ++this.currentRetryAttemptCount - 1;\n        retryContext.retryRequestOnPreferredLocations = this.currentRetryAttemptCount > 1;\n        retryContext.clearSessionTokenNotAvailable =\n          this.currentRetryAttemptCount === endpoints.length;\n        return true;\n      }\n    } else {\n      if (this.currentRetryAttemptCount > 1) {\n        return false;\n      } else {\n        retryContext.retryCount = ++this.currentRetryAttemptCount - 1;\n        retryContext.retryRequestOnPreferredLocations = false; // Forces all operations to primary write endpoint\n        retryContext.clearSessionTokenNotAvailable = true;\n        return true;\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}