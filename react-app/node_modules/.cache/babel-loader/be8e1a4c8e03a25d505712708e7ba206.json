{"ast":null,"code":"import { extractPartitionKey } from \"../extractPartitionKey\";\nimport { v4 as uuid } from \"uuid\";\nexport function isKeyInRange(min, max, key) {\n  const isAfterMinInclusive = key.localeCompare(min) >= 0;\n  const isBeforeMax = key.localeCompare(max) < 0;\n  return isAfterMinInclusive && isBeforeMax;\n}\nexport const BulkOperationType = {\n  Create: \"Create\",\n  Upsert: \"Upsert\",\n  Read: \"Read\",\n  Delete: \"Delete\",\n  Replace: \"Replace\"\n};\nexport function hasResource(operation) {\n  return operation.resourceBody !== undefined;\n}\nexport function getPartitionKeyToHash(operation, partitionProperty) {\n  const toHashKey = hasResource(operation) ? operation.resourceBody[partitionProperty] : operation.partitionKey.replace(/[\\[\\]\\\"\\']/g, \"\"); // We check for empty object since replace will stringify the value\n  // The second check avoids cases where the partitionKey value is actually the string '{}'\n\n  if (toHashKey === \"{}\" && operation.partitionKey === \"[{}]\") {\n    return {};\n  }\n\n  return toHashKey;\n}\nexport function decorateOperation(operation, definition, options = {}) {\n  if (operation.operationType === BulkOperationType.Create) {\n    if ((operation.resourceBody.id === undefined || operation.resourceBody.id === \"\") && !options.disableAutomaticIdGeneration) {\n      operation.resourceBody.id = uuid();\n    }\n  }\n\n  if (operation.partitionKey) {\n    const extracted = extractPartitionKey(operation, {\n      paths: [\"/partitionKey\"]\n    });\n    return Object.assign(Object.assign({}, operation), {\n      partitionKey: JSON.stringify(extracted)\n    });\n  } else if (operation.operationType === BulkOperationType.Create || operation.operationType === BulkOperationType.Replace || operation.operationType === BulkOperationType.Upsert) {\n    const pk = extractPartitionKey(operation.resourceBody, definition);\n    return Object.assign(Object.assign({}, operation), {\n      partitionKey: JSON.stringify(pk)\n    });\n  }\n\n  return operation;\n}","map":{"version":3,"sources":["../../src/utils/batch.ts"],"names":[],"mappings":"AACA,SAAS,mBAAT,QAAoC,wBAApC;AAGA,SAAS,EAAE,IAAI,IAAf,QAA2B,MAA3B;AAwBA,OAAM,SAAU,YAAV,CAAuB,GAAvB,EAAoC,GAApC,EAAiD,GAAjD,EAA4D;AAChE,QAAM,mBAAmB,GAAG,GAAG,CAAC,aAAJ,CAAkB,GAAlB,KAA0B,CAAtD;AACA,QAAM,WAAW,GAAG,GAAG,CAAC,aAAJ,CAAkB,GAAlB,IAAyB,CAA7C;AACA,SAAO,mBAAmB,IAAI,WAA9B;AACD;AAQD,OAAO,MAAM,iBAAiB,GAAG;AAC/B,EAAA,MAAM,EAAE,QADuB;AAE/B,EAAA,MAAM,EAAE,QAFuB;AAG/B,EAAA,IAAI,EAAE,MAHyB;AAI/B,EAAA,MAAM,EAAE,QAJuB;AAK/B,EAAA,OAAO,EAAE;AALsB,CAA1B;AA+EP,OAAM,SAAU,WAAV,CACJ,SADI,EACgB;AAEpB,SAAQ,SAA+B,CAAC,YAAhC,KAAiD,SAAzD;AACD;AAED,OAAM,SAAU,qBAAV,CAAgC,SAAhC,EAAsD,iBAAtD,EAA+E;AACnF,QAAM,SAAS,GAAG,WAAW,CAAC,SAAD,CAAX,GACb,SAAS,CAAC,YAAV,CAA+B,iBAA/B,CADa,GAEd,SAAS,CAAC,YAAV,CAAuB,OAAvB,CAA+B,aAA/B,EAA8C,EAA9C,CAFJ,CADmF,CAInF;AACA;;AACA,MAAI,SAAS,KAAK,IAAd,IAAsB,SAAS,CAAC,YAAV,KAA2B,MAArD,EAA6D;AAC3D,WAAO,EAAP;AACD;;AACD,SAAO,SAAP;AACD;AAED,OAAM,SAAU,iBAAV,CACJ,SADI,EAEJ,UAFI,EAGJ,OAAA,GAA0B,EAHtB,EAGwB;AAE5B,MAAI,SAAS,CAAC,aAAV,KAA4B,iBAAiB,CAAC,MAAlD,EAA0D;AACxD,QACE,CAAC,SAAS,CAAC,YAAV,CAAuB,EAAvB,KAA8B,SAA9B,IAA2C,SAAS,CAAC,YAAV,CAAuB,EAAvB,KAA8B,EAA1E,KACA,CAAC,OAAO,CAAC,4BAFX,EAGE;AACA,MAAA,SAAS,CAAC,YAAV,CAAuB,EAAvB,GAA4B,IAAI,EAAhC;AACD;AACF;;AACD,MAAI,SAAS,CAAC,YAAd,EAA4B;AAC1B,UAAM,SAAS,GAAG,mBAAmB,CAAC,SAAD,EAAY;AAAE,MAAA,KAAK,EAAE,CAAC,eAAD;AAAT,KAAZ,CAArC;AACA,WAAO,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAK,SAAL,CAAA,EAAc;AAAE,MAAA,YAAY,EAAE,IAAI,CAAC,SAAL,CAAe,SAAf;AAAhB,KAAd,CAAP;AACD,GAHD,MAGO,IACL,SAAS,CAAC,aAAV,KAA4B,iBAAiB,CAAC,MAA9C,IACA,SAAS,CAAC,aAAV,KAA4B,iBAAiB,CAAC,OAD9C,IAEA,SAAS,CAAC,aAAV,KAA4B,iBAAiB,CAAC,MAHzC,EAIL;AACA,UAAM,EAAE,GAAG,mBAAmB,CAAC,SAAS,CAAC,YAAX,EAAyB,UAAzB,CAA9B;AACA,WAAO,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAK,SAAL,CAAA,EAAc;AAAE,MAAA,YAAY,EAAE,IAAI,CAAC,SAAL,CAAe,EAAf;AAAhB,KAAd,CAAP;AACD;;AACD,SAAO,SAAP;AACD","sourcesContent":["import { JSONObject } from \"../queryExecutionContext\";\nimport { extractPartitionKey } from \"../extractPartitionKey\";\nimport { PartitionKeyDefinition } from \"../documents\";\nimport { RequestOptions } from \"..\";\nimport { v4 as uuid } from \"uuid\";\n\nexport type Operation =\n  | CreateOperation\n  | UpsertOperation\n  | ReadOperation\n  | DeleteOperation\n  | ReplaceOperation;\n\nexport interface Batch {\n  min: string;\n  max: string;\n  rangeId: string;\n  indexes: number[];\n  operations: Operation[];\n}\n\nexport interface OperationResponse {\n  statusCode: number;\n  requestCharge: number;\n  eTag?: string;\n  resourceBody?: JSONObject;\n}\n\nexport function isKeyInRange(min: string, max: string, key: string) {\n  const isAfterMinInclusive = key.localeCompare(min) >= 0;\n  const isBeforeMax = key.localeCompare(max) < 0;\n  return isAfterMinInclusive && isBeforeMax;\n}\n\nexport interface OperationBase {\n  partitionKey?: string;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n}\n\nexport const BulkOperationType = {\n  Create: \"Create\",\n  Upsert: \"Upsert\",\n  Read: \"Read\",\n  Delete: \"Delete\",\n  Replace: \"Replace\"\n} as const;\n\n// TODO Make operationInput CreateOperationInput | ...\nexport type OperationInput =\n  | CreateOperationInput\n  | UpsertOperationInput\n  | ReadOperationInput\n  | DeleteOperationInput\n  | ReplaceOperationInput;\n\nexport interface CreateOperationInput {\n  partitionKey?: string | number | null | {} | undefined;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Create;\n  resourceBody: JSONObject;\n}\n\nexport interface UpsertOperationInput {\n  partitionKey?: string | number | null | {} | undefined;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Upsert;\n  resourceBody: JSONObject;\n}\n\nexport interface ReadOperationInput {\n  partitionKey?: string | number | null | {} | undefined;\n  operationType: typeof BulkOperationType.Read;\n  id: string;\n}\n\nexport interface DeleteOperationInput {\n  partitionKey?: string | number | null | {} | undefined;\n  operationType: typeof BulkOperationType.Delete;\n  id: string;\n}\n\nexport interface ReplaceOperationInput {\n  partitionKey?: string | number | null | {} | undefined;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Replace;\n  resourceBody: JSONObject;\n}\n\nexport type OperationWithItem = OperationBase & {\n  resourceBody: JSONObject;\n};\n\nexport type CreateOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Create;\n};\n\nexport type UpsertOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Upsert;\n};\n\nexport type ReadOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Read;\n  id: string;\n};\n\nexport type DeleteOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Delete;\n  id: string;\n};\n\nexport type ReplaceOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Replace;\n  id: string;\n};\n\nexport function hasResource(\n  operation: Operation\n): operation is CreateOperation | UpsertOperation | ReplaceOperation {\n  return (operation as OperationWithItem).resourceBody !== undefined;\n}\n\nexport function getPartitionKeyToHash(operation: Operation, partitionProperty: string) {\n  const toHashKey = hasResource(operation)\n    ? (operation.resourceBody as any)[partitionProperty]\n    : operation.partitionKey.replace(/[\\[\\]\\\"\\']/g, \"\");\n  // We check for empty object since replace will stringify the value\n  // The second check avoids cases where the partitionKey value is actually the string '{}'\n  if (toHashKey === \"{}\" && operation.partitionKey === \"[{}]\") {\n    return {};\n  }\n  return toHashKey;\n}\n\nexport function decorateOperation(\n  operation: OperationInput,\n  definition: PartitionKeyDefinition,\n  options: RequestOptions = {}\n): Operation {\n  if (operation.operationType === BulkOperationType.Create) {\n    if (\n      (operation.resourceBody.id === undefined || operation.resourceBody.id === \"\") &&\n      !options.disableAutomaticIdGeneration\n    ) {\n      operation.resourceBody.id = uuid();\n    }\n  }\n  if (operation.partitionKey) {\n    const extracted = extractPartitionKey(operation, { paths: [\"/partitionKey\"] });\n    return { ...operation, partitionKey: JSON.stringify(extracted) } as Operation;\n  } else if (\n    operation.operationType === BulkOperationType.Create ||\n    operation.operationType === BulkOperationType.Replace ||\n    operation.operationType === BulkOperationType.Upsert\n  ) {\n    const pk = extractPartitionKey(operation.resourceBody, definition);\n    return { ...operation, partitionKey: JSON.stringify(pk) } as Operation;\n  }\n  return operation as Operation;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}