{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __asyncGenerator, __await, __awaiter } from \"tslib\";\nimport { getPathFromLink, ResourceType, StatusCodes } from \"./common\";\nimport { DefaultQueryExecutionContext, getInitialHeader, mergeHeaders, PipelinedQueryExecutionContext } from \"./queryExecutionContext\";\nimport { FeedResponse } from \"./request/FeedResponse\";\n/**\n * Represents a QueryIterator Object, an implementation of feed or query response that enables\n * traversal and iterating over the response\n * in the Azure Cosmos DB database service.\n */\n\nexport class QueryIterator {\n  /**\n   * @hidden\n   */\n  constructor(clientContext, query, options, fetchFunctions, resourceLink, resourceType) {\n    this.clientContext = clientContext;\n    this.query = query;\n    this.options = options;\n    this.fetchFunctions = fetchFunctions;\n    this.resourceLink = resourceLink;\n    this.resourceType = resourceType;\n    this.query = query;\n    this.fetchFunctions = fetchFunctions;\n    this.options = options || {};\n    this.resourceLink = resourceLink;\n    this.fetchAllLastResHeaders = getInitialHeader();\n    this.reset();\n    this.isInitialized = false;\n  }\n  /**\n   * Gets an async iterator that will yield results until completion.\n   *\n   * NOTE: AsyncIterators are a very new feature and you might need to\n   * use polyfils/etc. in order to use them in your code.\n   *\n   * If you're using TypeScript, you can use the following polyfill as long\n   * as you target ES6 or higher and are running on Node 6 or higher.\n   *\n   * ```typescript\n   * if (!Symbol || !Symbol.asyncIterator) {\n   *   (Symbol as any).asyncIterator = Symbol.for(\"Symbol.asyncIterator\");\n   * }\n   * ```\n   *\n   * @example Iterate over all databases\n   * ```typescript\n   * for await(const {result: db} in client.databases.readAll().getAsyncIterator()) {\n   *   console.log(`Got ${db.id} from AsyncIterator`);\n   * }\n   * ```\n   */\n\n\n  getAsyncIterator() {\n    return __asyncGenerator(this, arguments, function* getAsyncIterator_1() {\n      this.reset();\n      this.queryPlanPromise = this.fetchQueryPlan();\n\n      while (this.queryExecutionContext.hasMoreResults()) {\n        let response;\n\n        try {\n          response = yield __await(this.queryExecutionContext.fetchMore());\n        } catch (error) {\n          if (this.needsQueryPlan(error)) {\n            yield __await(this.createPipelinedExecutionContext());\n\n            try {\n              response = yield __await(this.queryExecutionContext.fetchMore());\n            } catch (error) {\n              this.handleSplitError(error);\n            }\n          } else {\n            throw error;\n          }\n        }\n\n        const feedResponse = new FeedResponse(response.result, response.headers, this.queryExecutionContext.hasMoreResults());\n\n        if (response.result !== undefined) {\n          yield yield __await(feedResponse);\n        }\n      }\n    });\n  }\n  /**\n   * Determine if there are still remaining resources to processs based on the value of the continuation token or the\\\n   * elements remaining on the current batch in the QueryIterator.\n   * @returns {Boolean} true if there is other elements to process in the QueryIterator.\n   */\n\n\n  hasMoreResults() {\n    return this.queryExecutionContext.hasMoreResults();\n  }\n  /**\n   * Fetch all pages for the query and return a single FeedResponse.\n   */\n\n\n  fetchAll() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.reset();\n      this.fetchAllTempResources = [];\n      let response;\n\n      try {\n        response = yield this.toArrayImplementation();\n      } catch (error) {\n        this.handleSplitError(error);\n      }\n\n      return response;\n    });\n  }\n  /**\n   * Retrieve the next batch from the feed.\n   *\n   * This may or may not fetch more pages from the backend depending on your settings\n   * and the type of query. Aggregate queries will generally fetch all backend pages\n   * before returning the first batch of responses.\n   */\n\n\n  fetchNext() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.queryPlanPromise = this.fetchQueryPlan();\n\n      if (!this.isInitialized) {\n        yield this.init();\n      }\n\n      let response;\n\n      try {\n        response = yield this.queryExecutionContext.fetchMore();\n      } catch (error) {\n        if (this.needsQueryPlan(error)) {\n          yield this.createPipelinedExecutionContext();\n\n          try {\n            response = yield this.queryExecutionContext.fetchMore();\n          } catch (error) {\n            this.handleSplitError(error);\n          }\n        } else {\n          throw error;\n        }\n      }\n\n      return new FeedResponse(response.result, response.headers, this.queryExecutionContext.hasMoreResults());\n    });\n  }\n  /**\n   * Reset the QueryIterator to the beginning and clear all the resources inside it\n   */\n\n\n  reset() {\n    this.queryPlanPromise = undefined;\n    this.queryExecutionContext = new DefaultQueryExecutionContext(this.options, this.fetchFunctions);\n  }\n\n  toArrayImplementation() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.queryPlanPromise = this.fetchQueryPlan();\n\n      if (!this.isInitialized) {\n        yield this.init();\n      }\n\n      while (this.queryExecutionContext.hasMoreResults()) {\n        let response;\n\n        try {\n          response = yield this.queryExecutionContext.nextItem();\n        } catch (error) {\n          if (this.needsQueryPlan(error)) {\n            yield this.createPipelinedExecutionContext();\n            response = yield this.queryExecutionContext.nextItem();\n          } else {\n            throw error;\n          }\n        }\n\n        const {\n          result,\n          headers\n        } = response; // concatenate the results and fetch more\n\n        mergeHeaders(this.fetchAllLastResHeaders, headers);\n\n        if (result !== undefined) {\n          this.fetchAllTempResources.push(result);\n        }\n      }\n\n      return new FeedResponse(this.fetchAllTempResources, this.fetchAllLastResHeaders, this.queryExecutionContext.hasMoreResults());\n    });\n  }\n\n  createPipelinedExecutionContext() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const queryPlanResponse = yield this.queryPlanPromise; // We always coerce queryPlanPromise to resolved. So if it errored, we need to manually inspect the resolved value\n\n      if (queryPlanResponse instanceof Error) {\n        throw queryPlanResponse;\n      }\n\n      const queryPlan = queryPlanResponse.result;\n      const queryInfo = queryPlan.queryInfo;\n\n      if (queryInfo.aggregates.length > 0 && queryInfo.hasSelectValue === false) {\n        throw new Error(\"Aggregate queries must use the VALUE keyword\");\n      }\n\n      this.queryExecutionContext = new PipelinedQueryExecutionContext(this.clientContext, this.resourceLink, this.query, this.options, queryPlan);\n    });\n  }\n\n  fetchQueryPlan() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.queryPlanPromise && this.resourceType === ResourceType.item) {\n        return this.clientContext.getQueryPlan(getPathFromLink(this.resourceLink) + \"/docs\", ResourceType.item, this.resourceLink, this.query, this.options).catch(error => error); // Without this catch, node reports an unhandled rejection. So we stash the promise as resolved even if it errored.\n      }\n\n      return this.queryPlanPromise;\n    });\n  }\n\n  needsQueryPlan(error) {\n    return error.code === StatusCodes.BadRequest && this.resourceType === ResourceType.item;\n  }\n\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isInitialized === true) {\n        return;\n      }\n\n      if (this.initPromise === undefined) {\n        this.initPromise = this._init();\n      }\n\n      return this.initPromise;\n    });\n  }\n\n  _init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.options.forceQueryPlan === true && this.resourceType === ResourceType.item) {\n        yield this.createPipelinedExecutionContext();\n      }\n\n      this.isInitialized = true;\n    });\n  }\n\n  handleSplitError(err) {\n    if (err.code === 410) {\n      const error = new Error(\"Encountered partition split and could not recover. This request is retryable\");\n      error.code = 503;\n      error.originalError = err;\n      throw error;\n    } else {\n      throw err;\n    }\n  }\n\n}","map":{"version":3,"sources":["../src/queryIterator.ts"],"names":[],"mappings":"AAAA;AACA;;AAKA,SAAS,eAAT,EAA0B,YAA1B,EAAwC,WAAxC,QAA2D,UAA3D;AACA,SAEE,4BAFF,EAKE,gBALF,EAME,YANF,EAOE,8BAPF,QASO,yBATP;AAaA,SAAS,YAAT,QAA6B,wBAA7B;AAEA;;;;;;AAKA,OAAM,MAAO,aAAP,CAAoB;AAMxB;;;AAGA,EAAA,WAAA,CACU,aADV,EAEU,KAFV,EAGU,OAHV,EAIU,cAJV,EAKU,YALV,EAMU,YANV,EAMqC;AAL3B,SAAA,aAAA,GAAA,aAAA;AACA,SAAA,KAAA,GAAA,KAAA;AACA,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,cAAA,GAAA,cAAA;AACA,SAAA,YAAA,GAAA,YAAA;AACA,SAAA,YAAA,GAAA,YAAA;AAER,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,cAAL,GAAsB,cAAtB;AACA,SAAK,OAAL,GAAe,OAAO,IAAI,EAA1B;AACA,SAAK,YAAL,GAAoB,YAApB;AACA,SAAK,sBAAL,GAA8B,gBAAgB,EAA9C;AACA,SAAK,KAAL;AACA,SAAK,aAAL,GAAqB,KAArB;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;AAsBc,EAAA,gBAAgB,GAAA;;AAC5B,WAAK,KAAL;AACA,WAAK,gBAAL,GAAwB,KAAK,cAAL,EAAxB;;AACA,aAAO,KAAK,qBAAL,CAA2B,cAA3B,EAAP,EAAoD;AAClD,YAAI,QAAJ;;AACA,YAAI;AACF,UAAA,QAAQ,GAAG,MAAA,OAAA,CAAM,KAAK,qBAAL,CAA2B,SAA3B,EAAN,CAAX;AACD,SAFD,CAEE,OAAO,KAAP,EAAc;AACd,cAAI,KAAK,cAAL,CAAoB,KAApB,CAAJ,EAAgC;AAC9B,kBAAA,OAAA,CAAM,KAAK,+BAAL,EAAN,CAAA;;AACA,gBAAI;AACF,cAAA,QAAQ,GAAG,MAAA,OAAA,CAAM,KAAK,qBAAL,CAA2B,SAA3B,EAAN,CAAX;AACD,aAFD,CAEE,OAAO,KAAP,EAAc;AACd,mBAAK,gBAAL,CAAsB,KAAtB;AACD;AACF,WAPD,MAOO;AACL,kBAAM,KAAN;AACD;AACF;;AACD,cAAM,YAAY,GAAG,IAAI,YAAJ,CACnB,QAAQ,CAAC,MADU,EAEnB,QAAQ,CAAC,OAFU,EAGnB,KAAK,qBAAL,CAA2B,cAA3B,EAHmB,CAArB;;AAKA,YAAI,QAAQ,CAAC,MAAT,KAAoB,SAAxB,EAAmC;AACjC,gBAAA,MAAA,OAAA,CAAM,YAAN,CAAA;AACD;AACF;AACF,K;AAAA;AAED;;;;;;;AAKO,EAAA,cAAc,GAAA;AACnB,WAAO,KAAK,qBAAL,CAA2B,cAA3B,EAAP;AACD;AAED;;;;;AAIa,EAAA,QAAQ,GAAA;;AACnB,WAAK,KAAL;AACA,WAAK,qBAAL,GAA6B,EAA7B;AACA,UAAI,QAAJ;;AACA,UAAI;AACF,QAAA,QAAQ,GAAG,MAAM,KAAK,qBAAL,EAAjB;AACD,OAFD,CAEE,OAAO,KAAP,EAAc;AACd,aAAK,gBAAL,CAAsB,KAAtB;AACD;;AACD,aAAO,QAAP;AACD,K;AAAA;AAED;;;;;;;;;AAOa,EAAA,SAAS,GAAA;;AACpB,WAAK,gBAAL,GAAwB,KAAK,cAAL,EAAxB;;AACA,UAAI,CAAC,KAAK,aAAV,EAAyB;AACvB,cAAM,KAAK,IAAL,EAAN;AACD;;AAED,UAAI,QAAJ;;AACA,UAAI;AACF,QAAA,QAAQ,GAAG,MAAM,KAAK,qBAAL,CAA2B,SAA3B,EAAjB;AACD,OAFD,CAEE,OAAO,KAAP,EAAc;AACd,YAAI,KAAK,cAAL,CAAoB,KAApB,CAAJ,EAAgC;AAC9B,gBAAM,KAAK,+BAAL,EAAN;;AACA,cAAI;AACF,YAAA,QAAQ,GAAG,MAAM,KAAK,qBAAL,CAA2B,SAA3B,EAAjB;AACD,WAFD,CAEE,OAAO,KAAP,EAAc;AACd,iBAAK,gBAAL,CAAsB,KAAtB;AACD;AACF,SAPD,MAOO;AACL,gBAAM,KAAN;AACD;AACF;;AACD,aAAO,IAAI,YAAJ,CACL,QAAQ,CAAC,MADJ,EAEL,QAAQ,CAAC,OAFJ,EAGL,KAAK,qBAAL,CAA2B,cAA3B,EAHK,CAAP;AAKD,K;AAAA;AAED;;;;;AAGO,EAAA,KAAK,GAAA;AACV,SAAK,gBAAL,GAAwB,SAAxB;AACA,SAAK,qBAAL,GAA6B,IAAI,4BAAJ,CAC3B,KAAK,OADsB,EAE3B,KAAK,cAFsB,CAA7B;AAID;;AAEa,EAAA,qBAAqB,GAAA;;AACjC,WAAK,gBAAL,GAAwB,KAAK,cAAL,EAAxB;;AACA,UAAI,CAAC,KAAK,aAAV,EAAyB;AACvB,cAAM,KAAK,IAAL,EAAN;AACD;;AACD,aAAO,KAAK,qBAAL,CAA2B,cAA3B,EAAP,EAAoD;AAClD,YAAI,QAAJ;;AACA,YAAI;AACF,UAAA,QAAQ,GAAG,MAAM,KAAK,qBAAL,CAA2B,QAA3B,EAAjB;AACD,SAFD,CAEE,OAAO,KAAP,EAAc;AACd,cAAI,KAAK,cAAL,CAAoB,KAApB,CAAJ,EAAgC;AAC9B,kBAAM,KAAK,+BAAL,EAAN;AACA,YAAA,QAAQ,GAAG,MAAM,KAAK,qBAAL,CAA2B,QAA3B,EAAjB;AACD,WAHD,MAGO;AACL,kBAAM,KAAN;AACD;AACF;;AACD,cAAM;AAAE,UAAA,MAAF;AAAU,UAAA;AAAV,YAAsB,QAA5B,CAZkD,CAalD;;AACA,QAAA,YAAY,CAAC,KAAK,sBAAN,EAA8B,OAA9B,CAAZ;;AAEA,YAAI,MAAM,KAAK,SAAf,EAA0B;AACxB,eAAK,qBAAL,CAA2B,IAA3B,CAAgC,MAAhC;AACD;AACF;;AACD,aAAO,IAAI,YAAJ,CACL,KAAK,qBADA,EAEL,KAAK,sBAFA,EAGL,KAAK,qBAAL,CAA2B,cAA3B,EAHK,CAAP;AAKD,K;AAAA;;AAEa,EAAA,+BAA+B,GAAA;;AAC3C,YAAM,iBAAiB,GAAG,MAAM,KAAK,gBAArC,C,CAEA;;AACA,UAAI,iBAAiB,YAAY,KAAjC,EAAwC;AACtC,cAAM,iBAAN;AACD;;AAED,YAAM,SAAS,GAAG,iBAAiB,CAAC,MAApC;AACA,YAAM,SAAS,GAAG,SAAS,CAAC,SAA5B;;AACA,UAAI,SAAS,CAAC,UAAV,CAAqB,MAArB,GAA8B,CAA9B,IAAmC,SAAS,CAAC,cAAV,KAA6B,KAApE,EAA2E;AACzE,cAAM,IAAI,KAAJ,CAAU,8CAAV,CAAN;AACD;;AACD,WAAK,qBAAL,GAA6B,IAAI,8BAAJ,CAC3B,KAAK,aADsB,EAE3B,KAAK,YAFsB,EAG3B,KAAK,KAHsB,EAI3B,KAAK,OAJsB,EAK3B,SAL2B,CAA7B;AAOD,K;AAAA;;AAEa,EAAA,cAAc,GAAA;;AAC1B,UAAI,CAAC,KAAK,gBAAN,IAA0B,KAAK,YAAL,KAAsB,YAAY,CAAC,IAAjE,EAAuE;AACrE,eAAO,KAAK,aAAL,CACJ,YADI,CAEH,eAAe,CAAC,KAAK,YAAN,CAAf,GAAqC,OAFlC,EAGH,YAAY,CAAC,IAHV,EAIH,KAAK,YAJF,EAKH,KAAK,KALF,EAMH,KAAK,OANF,EAQJ,KARI,CAQG,KAAD,IAAgB,KARlB,CAAP,CADqE,CASpC;AAClC;;AACD,aAAO,KAAK,gBAAZ;AACD,K;AAAA;;AAEO,EAAA,cAAc,CAAC,KAAD,EAAW;AAC/B,WAAO,KAAK,CAAC,IAAN,KAAe,WAAW,CAAC,UAA3B,IAAyC,KAAK,YAAL,KAAsB,YAAY,CAAC,IAAnF;AACD;;AAGa,EAAA,IAAI,GAAA;;AAChB,UAAI,KAAK,aAAL,KAAuB,IAA3B,EAAiC;AAC/B;AACD;;AACD,UAAI,KAAK,WAAL,KAAqB,SAAzB,EAAoC;AAClC,aAAK,WAAL,GAAmB,KAAK,KAAL,EAAnB;AACD;;AACD,aAAO,KAAK,WAAZ;AACD,K;AAAA;;AACa,EAAA,KAAK,GAAA;;AACjB,UAAI,KAAK,OAAL,CAAa,cAAb,KAAgC,IAAhC,IAAwC,KAAK,YAAL,KAAsB,YAAY,CAAC,IAA/E,EAAqF;AACnF,cAAM,KAAK,+BAAL,EAAN;AACD;;AACD,WAAK,aAAL,GAAqB,IAArB;AACD,K;AAAA;;AAEO,EAAA,gBAAgB,CAAC,GAAD,EAAS;AAC/B,QAAI,GAAG,CAAC,IAAJ,KAAa,GAAjB,EAAsB;AACpB,YAAM,KAAK,GAAG,IAAI,KAAJ,CACZ,8EADY,CAAd;AAGA,MAAA,KAAK,CAAC,IAAN,GAAa,GAAb;AACA,MAAA,KAAK,CAAC,aAAN,GAAsB,GAAtB;AACA,YAAM,KAAN;AACD,KAPD,MAOO;AACL,YAAM,GAAN;AACD;AACF;;AA1PuB","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/// <reference lib=\"esnext.asynciterable\" />\n\nimport { ClientContext } from \"./ClientContext\";\nimport { getPathFromLink, ResourceType, StatusCodes } from \"./common\";\nimport {\n  CosmosHeaders,\n  DefaultQueryExecutionContext,\n  ExecutionContext,\n  FetchFunctionCallback,\n  getInitialHeader,\n  mergeHeaders,\n  PipelinedQueryExecutionContext,\n  SqlQuerySpec\n} from \"./queryExecutionContext\";\nimport { Response } from \"./request\";\nimport { ErrorResponse, PartitionedQueryExecutionInfo } from \"./request/ErrorResponse\";\nimport { FeedOptions } from \"./request/FeedOptions\";\nimport { FeedResponse } from \"./request/FeedResponse\";\n\n/**\n * Represents a QueryIterator Object, an implementation of feed or query response that enables\n * traversal and iterating over the response\n * in the Azure Cosmos DB database service.\n */\nexport class QueryIterator<T> {\n  private fetchAllTempResources: T[]; // TODO\n  private fetchAllLastResHeaders: CosmosHeaders;\n  private queryExecutionContext: ExecutionContext;\n  private queryPlanPromise: Promise<Response<PartitionedQueryExecutionInfo>>;\n  private isInitialized: boolean;\n  /**\n   * @hidden\n   */\n  constructor(\n    private clientContext: ClientContext,\n    private query: SqlQuerySpec | string,\n    private options: FeedOptions,\n    private fetchFunctions: FetchFunctionCallback | FetchFunctionCallback[],\n    private resourceLink?: string,\n    private resourceType?: ResourceType\n  ) {\n    this.query = query;\n    this.fetchFunctions = fetchFunctions;\n    this.options = options || {};\n    this.resourceLink = resourceLink;\n    this.fetchAllLastResHeaders = getInitialHeader();\n    this.reset();\n    this.isInitialized = false;\n  }\n\n  /**\n   * Gets an async iterator that will yield results until completion.\n   *\n   * NOTE: AsyncIterators are a very new feature and you might need to\n   * use polyfils/etc. in order to use them in your code.\n   *\n   * If you're using TypeScript, you can use the following polyfill as long\n   * as you target ES6 or higher and are running on Node 6 or higher.\n   *\n   * ```typescript\n   * if (!Symbol || !Symbol.asyncIterator) {\n   *   (Symbol as any).asyncIterator = Symbol.for(\"Symbol.asyncIterator\");\n   * }\n   * ```\n   *\n   * @example Iterate over all databases\n   * ```typescript\n   * for await(const {result: db} in client.databases.readAll().getAsyncIterator()) {\n   *   console.log(`Got ${db.id} from AsyncIterator`);\n   * }\n   * ```\n   */\n  public async *getAsyncIterator(): AsyncIterable<FeedResponse<T>> {\n    this.reset();\n    this.queryPlanPromise = this.fetchQueryPlan();\n    while (this.queryExecutionContext.hasMoreResults()) {\n      let response: Response<any>;\n      try {\n        response = await this.queryExecutionContext.fetchMore();\n      } catch (error) {\n        if (this.needsQueryPlan(error)) {\n          await this.createPipelinedExecutionContext();\n          try {\n            response = await this.queryExecutionContext.fetchMore();\n          } catch (error) {\n            this.handleSplitError(error);\n          }\n        } else {\n          throw error;\n        }\n      }\n      const feedResponse = new FeedResponse<T>(\n        response.result,\n        response.headers,\n        this.queryExecutionContext.hasMoreResults()\n      );\n      if (response.result !== undefined) {\n        yield feedResponse;\n      }\n    }\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs based on the value of the continuation token or the\\\n   * elements remaining on the current batch in the QueryIterator.\n   * @returns {Boolean} true if there is other elements to process in the QueryIterator.\n   */\n  public hasMoreResults(): boolean {\n    return this.queryExecutionContext.hasMoreResults();\n  }\n\n  /**\n   * Fetch all pages for the query and return a single FeedResponse.\n   */\n\n  public async fetchAll(): Promise<FeedResponse<T>> {\n    this.reset();\n    this.fetchAllTempResources = [];\n    let response: FeedResponse<T>;\n    try {\n      response = await this.toArrayImplementation();\n    } catch (error) {\n      this.handleSplitError(error);\n    }\n    return response;\n  }\n\n  /**\n   * Retrieve the next batch from the feed.\n   *\n   * This may or may not fetch more pages from the backend depending on your settings\n   * and the type of query. Aggregate queries will generally fetch all backend pages\n   * before returning the first batch of responses.\n   */\n  public async fetchNext(): Promise<FeedResponse<T>> {\n    this.queryPlanPromise = this.fetchQueryPlan();\n    if (!this.isInitialized) {\n      await this.init();\n    }\n\n    let response: Response<any>;\n    try {\n      response = await this.queryExecutionContext.fetchMore();\n    } catch (error) {\n      if (this.needsQueryPlan(error)) {\n        await this.createPipelinedExecutionContext();\n        try {\n          response = await this.queryExecutionContext.fetchMore();\n        } catch (error) {\n          this.handleSplitError(error);\n        }\n      } else {\n        throw error;\n      }\n    }\n    return new FeedResponse<T>(\n      response.result,\n      response.headers,\n      this.queryExecutionContext.hasMoreResults()\n    );\n  }\n\n  /**\n   * Reset the QueryIterator to the beginning and clear all the resources inside it\n   */\n  public reset() {\n    this.queryPlanPromise = undefined;\n    this.queryExecutionContext = new DefaultQueryExecutionContext(\n      this.options,\n      this.fetchFunctions\n    );\n  }\n\n  private async toArrayImplementation(): Promise<FeedResponse<T>> {\n    this.queryPlanPromise = this.fetchQueryPlan();\n    if (!this.isInitialized) {\n      await this.init();\n    }\n    while (this.queryExecutionContext.hasMoreResults()) {\n      let response: Response<any>;\n      try {\n        response = await this.queryExecutionContext.nextItem();\n      } catch (error) {\n        if (this.needsQueryPlan(error)) {\n          await this.createPipelinedExecutionContext();\n          response = await this.queryExecutionContext.nextItem();\n        } else {\n          throw error;\n        }\n      }\n      const { result, headers } = response;\n      // concatenate the results and fetch more\n      mergeHeaders(this.fetchAllLastResHeaders, headers);\n\n      if (result !== undefined) {\n        this.fetchAllTempResources.push(result);\n      }\n    }\n    return new FeedResponse(\n      this.fetchAllTempResources,\n      this.fetchAllLastResHeaders,\n      this.queryExecutionContext.hasMoreResults()\n    );\n  }\n\n  private async createPipelinedExecutionContext() {\n    const queryPlanResponse = await this.queryPlanPromise;\n\n    // We always coerce queryPlanPromise to resolved. So if it errored, we need to manually inspect the resolved value\n    if (queryPlanResponse instanceof Error) {\n      throw queryPlanResponse;\n    }\n\n    const queryPlan = queryPlanResponse.result;\n    const queryInfo = queryPlan.queryInfo;\n    if (queryInfo.aggregates.length > 0 && queryInfo.hasSelectValue === false) {\n      throw new Error(\"Aggregate queries must use the VALUE keyword\");\n    }\n    this.queryExecutionContext = new PipelinedQueryExecutionContext(\n      this.clientContext,\n      this.resourceLink,\n      this.query,\n      this.options,\n      queryPlan\n    );\n  }\n\n  private async fetchQueryPlan() {\n    if (!this.queryPlanPromise && this.resourceType === ResourceType.item) {\n      return this.clientContext\n        .getQueryPlan(\n          getPathFromLink(this.resourceLink) + \"/docs\",\n          ResourceType.item,\n          this.resourceLink,\n          this.query,\n          this.options\n        )\n        .catch((error: any) => error); // Without this catch, node reports an unhandled rejection. So we stash the promise as resolved even if it errored.\n    }\n    return this.queryPlanPromise;\n  }\n\n  private needsQueryPlan(error: any): error is ErrorResponse {\n    return error.code === StatusCodes.BadRequest && this.resourceType === ResourceType.item;\n  }\n\n  private initPromise: Promise<void>;\n  private async init() {\n    if (this.isInitialized === true) {\n      return;\n    }\n    if (this.initPromise === undefined) {\n      this.initPromise = this._init();\n    }\n    return this.initPromise;\n  }\n  private async _init() {\n    if (this.options.forceQueryPlan === true && this.resourceType === ResourceType.item) {\n      await this.createPipelinedExecutionContext();\n    }\n    this.isInitialized = true;\n  }\n\n  private handleSplitError(err: any) {\n    if (err.code === 410) {\n      const error = new Error(\n        \"Encountered partition split and could not recover. This request is retryable\"\n      ) as any;\n      error.code = 503;\n      error.originalError = err;\n      throw error;\n    } else {\n      throw err;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}