{"ast":null,"code":"import { __awaiter } from \"tslib\";\n/**\n * Used to specify which type of events to execute this plug in on.\n *\n * @ignore\n */\n\nexport var PluginOn;\n\n(function (PluginOn) {\n  /**\n   * Will be executed per network request\n   */\n  PluginOn[\"request\"] = \"request\";\n  /**\n   * Will be executed per API operation\n   */\n\n  PluginOn[\"operation\"] = \"operation\";\n})(PluginOn || (PluginOn = {}));\n/**\n * @internal\n * @hidden\n * @ignore\n * @param requestContext\n * @param next\n * @param on\n */\n\n\nexport function executePlugins(requestContext, next, on) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!requestContext.plugins) {\n      return next(requestContext, undefined);\n    }\n\n    let level = 0;\n\n    const _ = inner => {\n      if (++level >= inner.plugins.length) {\n        return next(requestContext, undefined);\n      } else if (inner.plugins[level].on !== on) {\n        return _(requestContext);\n      } else {\n        return inner.plugins[level].plugin(inner, _);\n      }\n    };\n\n    if (requestContext.plugins[level].on !== on) {\n      return _(requestContext);\n    } else {\n      return requestContext.plugins[level].plugin(requestContext, _);\n    }\n  });\n}","map":{"version":3,"sources":["../../src/plugins/Plugin.ts"],"names":[],"mappings":";AAKA;;;;;;AAKA,OAAA,IAAY,QAAZ;;AAAA,CAAA,UAAY,QAAZ,EAAoB;AAClB;;;AAGA,EAAA,QAAA,CAAA,SAAA,CAAA,GAAA,SAAA;AACA;;;;AAGA,EAAA,QAAA,CAAA,WAAA,CAAA,GAAA,WAAA;AACD,CATD,EAAY,QAAQ,KAAR,QAAQ,GAAA,EAAA,CAApB;AAiDA;;;;;;;;;;AAQA,OAAM,SAAgB,cAAhB,CACJ,cADI,EAEJ,IAFI,EAGJ,EAHI,EAGQ;;AAEZ,QAAI,CAAC,cAAc,CAAC,OAApB,EAA6B;AAC3B,aAAO,IAAI,CAAC,cAAD,EAAiB,SAAjB,CAAX;AACD;;AACD,QAAI,KAAK,GAAG,CAAZ;;AACA,UAAM,CAAC,GAAe,KAAD,IAAkD;AACrE,UAAI,EAAE,KAAF,IAAW,KAAK,CAAC,OAAN,CAAc,MAA7B,EAAqC;AACnC,eAAO,IAAI,CAAC,cAAD,EAAiB,SAAjB,CAAX;AACD,OAFD,MAEO,IAAI,KAAK,CAAC,OAAN,CAAc,KAAd,EAAqB,EAArB,KAA4B,EAAhC,EAAoC;AACzC,eAAO,CAAC,CAAC,cAAD,CAAR;AACD,OAFM,MAEA;AACL,eAAO,KAAK,CAAC,OAAN,CAAc,KAAd,EAAqB,MAArB,CAA4B,KAA5B,EAAmC,CAAnC,CAAP;AACD;AACF,KARD;;AASA,QAAI,cAAc,CAAC,OAAf,CAAuB,KAAvB,EAA8B,EAA9B,KAAqC,EAAzC,EAA6C;AAC3C,aAAO,CAAC,CAAC,cAAD,CAAR;AACD,KAFD,MAEO;AACL,aAAO,cAAc,CAAC,OAAf,CAAuB,KAAvB,EAA8B,MAA9B,CAAqC,cAArC,EAAqD,CAArD,CAAP;AACD;AACF,G;AAAA","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { RequestContext } from \"../request/RequestContext\";\nimport { Response } from \"../request/Response\";\n\n/**\n * Used to specify which type of events to execute this plug in on.\n *\n * @ignore\n */\nexport enum PluginOn {\n  /**\n   * Will be executed per network request\n   */\n  request = \"request\",\n  /**\n   * Will be executed per API operation\n   */\n  operation = \"operation\"\n}\n\n/**\n * Specifies which event to run for the specified plugin\n *\n * @ignore\n */\nexport interface PluginConfig {\n  /**\n   * The event to run the plugin on\n   */\n  on: keyof typeof PluginOn;\n  /**\n   * The plugin to run\n   */\n  plugin: Plugin<any>;\n}\n\n/**\n * Plugins allow you to customize the behavior of the SDk with additional logging, retry, or additional functionality.\n *\n * A plugin is a function which returns a Promise<Response<T>>, and is passed a RequestContext and Next object.\n *\n * Next is a function which takes in requestContext returns a promise. You must await/then that promise which will contain the response from further plugins,\n * allowing you to log those results or handle errors.\n *\n * RequestContext is an object which controls what operation is happening, against which endpoint, and more. Modifying this and passing it along via next is how\n * you modify future SDK behavior.\n *\n * @ignore\n */\nexport type Plugin<T> = (context: RequestContext, next: Next<T>) => Promise<Response<T>>;\n\n/**\n * Next is a function which takes in requestContext returns a promise. You must await/then that promise which will contain the response from further plugins,\n * allowing you to log those results or handle errors.\n * @ignore\n */\nexport type Next<T> = (context: RequestContext) => Promise<Response<T>>;\n\n/**\n * @internal\n * @hidden\n * @ignore\n * @param requestContext\n * @param next\n * @param on\n */\nexport async function executePlugins(\n  requestContext: RequestContext,\n  next: Plugin<any>,\n  on: PluginOn\n): Promise<Response<any>> {\n  if (!requestContext.plugins) {\n    return next(requestContext, undefined);\n  }\n  let level = 0;\n  const _: Next<any> = (inner: RequestContext): Promise<Response<any>> => {\n    if (++level >= inner.plugins.length) {\n      return next(requestContext, undefined);\n    } else if (inner.plugins[level].on !== on) {\n      return _(requestContext);\n    } else {\n      return inner.plugins[level].plugin(inner, _);\n    }\n  };\n  if (requestContext.plugins[level].on !== on) {\n    return _(requestContext);\n  } else {\n    return requestContext.plugins[level].plugin(requestContext, _);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}