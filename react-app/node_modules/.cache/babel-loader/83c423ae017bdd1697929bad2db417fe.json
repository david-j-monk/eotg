{"ast":null,"code":"// TODO: this smells funny\n\n/** @hidden */\nconst TYPEORDCOMPARATOR = Object.freeze({\n  NoValue: {\n    ord: 0\n  },\n  undefined: {\n    ord: 1\n  },\n  boolean: {\n    ord: 2,\n    compFunc: (a, b) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    }\n  },\n  number: {\n    ord: 4,\n    compFunc: (a, b) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    }\n  },\n  string: {\n    ord: 5,\n    compFunc: (a, b) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    }\n  }\n});\n/** @hidden */\n\nexport class OrderByDocumentProducerComparator {\n  constructor(sortOrder) {\n    this.sortOrder = sortOrder;\n  } // TODO: This should be an enum\n\n\n  targetPartitionKeyRangeDocProdComparator(docProd1, docProd2) {\n    const a = docProd1.getTargetParitionKeyRange()[\"minInclusive\"];\n    const b = docProd2.getTargetParitionKeyRange()[\"minInclusive\"];\n    return a === b ? 0 : a > b ? 1 : -1;\n  }\n\n  compare(docProd1, docProd2) {\n    // Need to check for split, since we don't want to dereference \"item\" of undefined / exception\n    if (docProd1.gotSplit()) {\n      return -1;\n    }\n\n    if (docProd2.gotSplit()) {\n      return 1;\n    }\n\n    const orderByItemsRes1 = this.getOrderByItems(docProd1.peekBufferedItems()[0]);\n    const orderByItemsRes2 = this.getOrderByItems(docProd2.peekBufferedItems()[0]); // validate order by items and types\n    // TODO: once V1 order by on different types is fixed this need to change\n\n    this.validateOrderByItems(orderByItemsRes1, orderByItemsRes2); // no async call in the for loop\n\n    for (let i = 0; i < orderByItemsRes1.length; i++) {\n      // compares the orderby items one by one\n      const compRes = this.compareOrderByItem(orderByItemsRes1[i], orderByItemsRes2[i]);\n\n      if (compRes !== 0) {\n        if (this.sortOrder[i] === \"Ascending\") {\n          return compRes;\n        } else if (this.sortOrder[i] === \"Descending\") {\n          return -compRes;\n        }\n      }\n    }\n\n    return this.targetPartitionKeyRangeDocProdComparator(docProd1, docProd2);\n  } // TODO: This smells funny\n\n\n  compareValue(item1, type1, item2, type2) {\n    if (type1 === \"object\" || type2 === \"object\") {\n      throw new Error(\"Tried to compare an object type\");\n    }\n\n    const type1Ord = TYPEORDCOMPARATOR[type1].ord;\n    const type2Ord = TYPEORDCOMPARATOR[type2].ord;\n    const typeCmp = type1Ord - type2Ord;\n\n    if (typeCmp !== 0) {\n      // if the types are different, use type ordinal\n      return typeCmp;\n    } // both are of the same type\n\n\n    if (type1Ord === TYPEORDCOMPARATOR[\"undefined\"].ord || type1Ord === TYPEORDCOMPARATOR[\"NoValue\"].ord) {\n      // if both types are undefined or Null they are equal\n      return 0;\n    }\n\n    const compFunc = TYPEORDCOMPARATOR[type1].compFunc;\n\n    if (typeof compFunc === \"undefined\") {\n      throw new Error(\"Cannot find the comparison function\");\n    } // same type and type is defined compare the items\n\n\n    return compFunc(item1, item2);\n  }\n\n  compareOrderByItem(orderByItem1, orderByItem2) {\n    const type1 = this.getType(orderByItem1);\n    const type2 = this.getType(orderByItem2);\n    return this.compareValue(orderByItem1[\"item\"], type1, orderByItem2[\"item\"], type2);\n  }\n\n  validateOrderByItems(res1, res2) {\n    if (res1.length !== res2.length) {\n      throw new Error(`Expected ${res1.length}, but got ${res2.length}.`);\n    }\n\n    if (res1.length !== this.sortOrder.length) {\n      throw new Error(\"orderByItems cannot have a different size than sort orders.\");\n    }\n\n    for (let i = 0; i < this.sortOrder.length; i++) {\n      const type1 = this.getType(res1[i]);\n      const type2 = this.getType(res2[i]);\n\n      if (type1 !== type2) {\n        throw new Error(`Expected ${type1}, but got ${type2}. Cannot execute cross partition order-by queries on mixed types. Consider filtering your query using IS_STRING or IS_NUMBER to get around this exception.`);\n      }\n    }\n  }\n\n  getType(orderByItem) {\n    // TODO: any item?\n    if (orderByItem === undefined || orderByItem.item === undefined) {\n      return \"NoValue\";\n    }\n\n    const type = typeof orderByItem.item;\n\n    if (TYPEORDCOMPARATOR[type] === undefined) {\n      throw new Error(`unrecognizable type ${type}`);\n    }\n\n    return type;\n  }\n\n  getOrderByItems(res) {\n    // TODO: any res?\n    return res[\"orderByItems\"];\n  }\n\n}","map":{"version":3,"sources":["../../src/queryExecutionContext/orderByDocumentProducerComparator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { DocumentProducer } from \"./documentProducer\";\n\n// TODO: this smells funny\n/** @hidden */\nconst TYPEORDCOMPARATOR: {\n  [type: string]: { ord: number; compFunc?: (a: any, b: any) => number };\n} = Object.freeze({\n  NoValue: {\n    ord: 0\n  },\n  undefined: {\n    ord: 1\n  },\n  boolean: {\n    ord: 2,\n    compFunc: (a: boolean, b: boolean) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    }\n  },\n  number: {\n    ord: 4,\n    compFunc: (a: number, b: number) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    }\n  },\n  string: {\n    ord: 5,\n    compFunc: (a: string, b: string) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    }\n  }\n});\n\n/** @hidden */\nexport class OrderByDocumentProducerComparator {\n  constructor(public sortOrder: string[]) {} // TODO: This should be an enum\n\n  private targetPartitionKeyRangeDocProdComparator(\n    docProd1: DocumentProducer,\n    docProd2: DocumentProducer\n  ) {\n    const a = docProd1.getTargetParitionKeyRange()[\"minInclusive\"];\n    const b = docProd2.getTargetParitionKeyRange()[\"minInclusive\"];\n    return a === b ? 0 : a > b ? 1 : -1;\n  }\n\n  public compare(docProd1: DocumentProducer, docProd2: DocumentProducer) {\n    // Need to check for split, since we don't want to dereference \"item\" of undefined / exception\n    if (docProd1.gotSplit()) {\n      return -1;\n    }\n    if (docProd2.gotSplit()) {\n      return 1;\n    }\n\n    const orderByItemsRes1 = this.getOrderByItems(docProd1.peekBufferedItems()[0]);\n    const orderByItemsRes2 = this.getOrderByItems(docProd2.peekBufferedItems()[0]);\n\n    // validate order by items and types\n    // TODO: once V1 order by on different types is fixed this need to change\n    this.validateOrderByItems(orderByItemsRes1, orderByItemsRes2);\n\n    // no async call in the for loop\n    for (let i = 0; i < orderByItemsRes1.length; i++) {\n      // compares the orderby items one by one\n      const compRes = this.compareOrderByItem(orderByItemsRes1[i], orderByItemsRes2[i]);\n      if (compRes !== 0) {\n        if (this.sortOrder[i] === \"Ascending\") {\n          return compRes;\n        } else if (this.sortOrder[i] === \"Descending\") {\n          return -compRes;\n        }\n      }\n    }\n\n    return this.targetPartitionKeyRangeDocProdComparator(docProd1, docProd2);\n  }\n\n  // TODO: This smells funny\n  public compareValue(item1: any, type1: string, item2: any, type2: string) {\n    if (type1 === \"object\" || type2 === \"object\") {\n      throw new Error(\"Tried to compare an object type\");\n    }\n    const type1Ord = TYPEORDCOMPARATOR[type1].ord;\n    const type2Ord = TYPEORDCOMPARATOR[type2].ord;\n    const typeCmp = type1Ord - type2Ord;\n\n    if (typeCmp !== 0) {\n      // if the types are different, use type ordinal\n      return typeCmp;\n    }\n\n    // both are of the same type\n    if (\n      type1Ord === TYPEORDCOMPARATOR[\"undefined\"].ord ||\n      type1Ord === TYPEORDCOMPARATOR[\"NoValue\"].ord\n    ) {\n      // if both types are undefined or Null they are equal\n      return 0;\n    }\n\n    const compFunc = TYPEORDCOMPARATOR[type1].compFunc;\n    if (typeof compFunc === \"undefined\") {\n      throw new Error(\"Cannot find the comparison function\");\n    }\n    // same type and type is defined compare the items\n    return compFunc(item1, item2);\n  }\n\n  private compareOrderByItem(orderByItem1: any, orderByItem2: any) {\n    const type1 = this.getType(orderByItem1);\n    const type2 = this.getType(orderByItem2);\n    return this.compareValue(orderByItem1[\"item\"], type1, orderByItem2[\"item\"], type2);\n  }\n\n  private validateOrderByItems(res1: string[], res2: string[]) {\n    if (res1.length !== res2.length) {\n      throw new Error(`Expected ${res1.length}, but got ${res2.length}.`);\n    }\n    if (res1.length !== this.sortOrder.length) {\n      throw new Error(\"orderByItems cannot have a different size than sort orders.\");\n    }\n\n    for (let i = 0; i < this.sortOrder.length; i++) {\n      const type1 = this.getType(res1[i]);\n      const type2 = this.getType(res2[i]);\n      if (type1 !== type2) {\n        throw new Error(\n          `Expected ${type1}, but got ${type2}. Cannot execute cross partition order-by queries on mixed types. Consider filtering your query using IS_STRING or IS_NUMBER to get around this exception.`\n        );\n      }\n    }\n  }\n\n  private getType(orderByItem: any) {\n    // TODO: any item?\n    if (orderByItem === undefined || orderByItem.item === undefined) {\n      return \"NoValue\";\n    }\n    const type = typeof orderByItem.item;\n    if (TYPEORDCOMPARATOR[type] === undefined) {\n      throw new Error(`unrecognizable type ${type}`);\n    }\n    return type;\n  }\n\n  private getOrderByItems(res: any) {\n    // TODO: any res?\n    return res[\"orderByItems\"];\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}