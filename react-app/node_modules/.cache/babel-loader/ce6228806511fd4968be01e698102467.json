{"ast":null,"code":"import { __awaiter } from \"tslib\"; // Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Constants } from \"../common/constants\";\nimport { sleep } from \"../common/helper\";\nimport { StatusCodes, SubStatusCodes } from \"../common/statusCodes\";\nimport { DefaultRetryPolicy } from \"./defaultRetryPolicy\";\nimport { EndpointDiscoveryRetryPolicy } from \"./endpointDiscoveryRetryPolicy\";\nimport { ResourceThrottleRetryPolicy } from \"./resourceThrottleRetryPolicy\";\nimport { SessionRetryPolicy } from \"./sessionRetryPolicy\";\n/**\n *\n * @param param0\n * @ignore\n */\n\nexport function execute({\n  retryContext = {},\n  retryPolicies,\n  requestContext,\n  executeRequest\n}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // TODO: any response\n    if (!retryPolicies) {\n      retryPolicies = {\n        endpointDiscoveryRetryPolicy: new EndpointDiscoveryRetryPolicy(requestContext.globalEndpointManager, requestContext.operationType),\n        resourceThrottleRetryPolicy: new ResourceThrottleRetryPolicy(requestContext.connectionPolicy.retryOptions.maxRetryAttemptCount, requestContext.connectionPolicy.retryOptions.fixedRetryIntervalInMilliseconds, requestContext.connectionPolicy.retryOptions.maxWaitTimeInSeconds),\n        sessionReadRetryPolicy: new SessionRetryPolicy(requestContext.globalEndpointManager, requestContext.resourceType, requestContext.operationType, requestContext.connectionPolicy),\n        defaultRetryPolicy: new DefaultRetryPolicy(requestContext.operationType)\n      };\n    }\n\n    if (retryContext && retryContext.clearSessionTokenNotAvailable) {\n      requestContext.client.clearSessionToken(requestContext.path);\n    }\n\n    requestContext.endpoint = yield requestContext.globalEndpointManager.resolveServiceEndpoint(requestContext.resourceType, requestContext.operationType);\n\n    try {\n      const response = yield executeRequest(requestContext);\n      response.headers[Constants.ThrottleRetryCount] = retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;\n      response.headers[Constants.ThrottleRetryWaitTimeInMs] = retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;\n      return response;\n    } catch (err) {\n      // TODO: any error\n      let retryPolicy = null;\n      const headers = err.headers || {};\n\n      if (err.code === StatusCodes.Forbidden && (err.substatus === SubStatusCodes.DatabaseAccountNotFound || err.substatus === SubStatusCodes.WriteForbidden)) {\n        retryPolicy = retryPolicies.endpointDiscoveryRetryPolicy;\n      } else if (err.code === StatusCodes.TooManyRequests) {\n        retryPolicy = retryPolicies.resourceThrottleRetryPolicy;\n      } else if (err.code === StatusCodes.NotFound && err.substatus === SubStatusCodes.ReadSessionNotAvailable) {\n        retryPolicy = retryPolicies.sessionReadRetryPolicy;\n      } else {\n        retryPolicy = retryPolicies.defaultRetryPolicy;\n      }\n\n      const results = yield retryPolicy.shouldRetry(err, retryContext, requestContext.endpoint);\n\n      if (!results) {\n        headers[Constants.ThrottleRetryCount] = retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;\n        headers[Constants.ThrottleRetryWaitTimeInMs] = retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;\n        err.headers = Object.assign(Object.assign({}, err.headers), headers);\n        throw err;\n      } else {\n        requestContext.retryCount++;\n        const newUrl = results[1]; // TODO: any hack\n\n        if (newUrl !== undefined) {\n          requestContext.endpoint = newUrl;\n        }\n\n        yield sleep(retryPolicy.retryAfterInMs);\n        return execute({\n          executeRequest,\n          requestContext,\n          retryContext,\n          retryPolicies\n        });\n      }\n    }\n  });\n}","map":{"version":3,"sources":["../../src/retry/retryUtility.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Constants } from \"../common/constants\";\nimport { sleep } from \"../common/helper\";\nimport { StatusCodes, SubStatusCodes } from \"../common/statusCodes\";\nimport { Response } from \"../request\";\nimport { RequestContext } from \"../request/RequestContext\";\nimport { DefaultRetryPolicy } from \"./defaultRetryPolicy\";\nimport { EndpointDiscoveryRetryPolicy } from \"./endpointDiscoveryRetryPolicy\";\nimport { ResourceThrottleRetryPolicy } from \"./resourceThrottleRetryPolicy\";\nimport { RetryContext } from \"./RetryContext\";\nimport { RetryPolicy } from \"./RetryPolicy\";\nimport { SessionRetryPolicy } from \"./sessionRetryPolicy\";\n\n/**\n * @ignore\n */\ninterface ExecuteArgs {\n  retryContext?: RetryContext;\n  retryPolicies?: RetryPolicies;\n  requestContext: RequestContext;\n  executeRequest: (requestContext: RequestContext) => Promise<Response<any>>;\n}\n\n/**\n * @ignore\n */\ninterface RetryPolicies {\n  endpointDiscoveryRetryPolicy: EndpointDiscoveryRetryPolicy;\n  resourceThrottleRetryPolicy: ResourceThrottleRetryPolicy;\n  sessionReadRetryPolicy: SessionRetryPolicy;\n  defaultRetryPolicy: DefaultRetryPolicy;\n}\n\n/**\n *\n * @param param0\n * @ignore\n */\nexport async function execute({\n  retryContext = {},\n  retryPolicies,\n  requestContext,\n  executeRequest\n}: ExecuteArgs): Promise<Response<any>> {\n  // TODO: any response\n  if (!retryPolicies) {\n    retryPolicies = {\n      endpointDiscoveryRetryPolicy: new EndpointDiscoveryRetryPolicy(\n        requestContext.globalEndpointManager,\n        requestContext.operationType\n      ),\n      resourceThrottleRetryPolicy: new ResourceThrottleRetryPolicy(\n        requestContext.connectionPolicy.retryOptions.maxRetryAttemptCount,\n        requestContext.connectionPolicy.retryOptions.fixedRetryIntervalInMilliseconds,\n        requestContext.connectionPolicy.retryOptions.maxWaitTimeInSeconds\n      ),\n      sessionReadRetryPolicy: new SessionRetryPolicy(\n        requestContext.globalEndpointManager,\n        requestContext.resourceType,\n        requestContext.operationType,\n        requestContext.connectionPolicy\n      ),\n      defaultRetryPolicy: new DefaultRetryPolicy(requestContext.operationType)\n    };\n  }\n  if (retryContext && retryContext.clearSessionTokenNotAvailable) {\n    requestContext.client.clearSessionToken(requestContext.path);\n  }\n  requestContext.endpoint = await requestContext.globalEndpointManager.resolveServiceEndpoint(\n    requestContext.resourceType,\n    requestContext.operationType\n  );\n  try {\n    const response = await executeRequest(requestContext);\n    response.headers[Constants.ThrottleRetryCount] =\n      retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;\n    response.headers[Constants.ThrottleRetryWaitTimeInMs] =\n      retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;\n    return response;\n  } catch (err) {\n    // TODO: any error\n    let retryPolicy: RetryPolicy = null;\n    const headers = err.headers || {};\n    if (\n      err.code === StatusCodes.Forbidden &&\n      (err.substatus === SubStatusCodes.DatabaseAccountNotFound ||\n        err.substatus === SubStatusCodes.WriteForbidden)\n    ) {\n      retryPolicy = retryPolicies.endpointDiscoveryRetryPolicy;\n    } else if (err.code === StatusCodes.TooManyRequests) {\n      retryPolicy = retryPolicies.resourceThrottleRetryPolicy;\n    } else if (\n      err.code === StatusCodes.NotFound &&\n      err.substatus === SubStatusCodes.ReadSessionNotAvailable\n    ) {\n      retryPolicy = retryPolicies.sessionReadRetryPolicy;\n    } else {\n      retryPolicy = retryPolicies.defaultRetryPolicy;\n    }\n    const results = await retryPolicy.shouldRetry(err, retryContext, requestContext.endpoint);\n    if (!results) {\n      headers[Constants.ThrottleRetryCount] =\n        retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;\n      headers[Constants.ThrottleRetryWaitTimeInMs] =\n        retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;\n      err.headers = { ...err.headers, ...headers };\n      throw err;\n    } else {\n      requestContext.retryCount++;\n      const newUrl = (results as any)[1]; // TODO: any hack\n      if (newUrl !== undefined) {\n        requestContext.endpoint = newUrl;\n      }\n      await sleep(retryPolicy.retryAfterInMs);\n      return execute({\n        executeRequest,\n        requestContext,\n        retryContext,\n        retryPolicies\n      });\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}