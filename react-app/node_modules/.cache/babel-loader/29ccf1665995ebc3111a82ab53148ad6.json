{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Constants } from \"../common\";\n/** @hidden */\n\nexport class QueryRange {\n  /**\n   * Represents a QueryRange.\n   * @constructor QueryRange\n   * @param {string} rangeMin                - min\n   * @param {string} rangeMin                - max\n   * @param {boolean} isMinInclusive         - isMinInclusive\n   * @param {boolean} isMaxInclusive         - isMaxInclusive\n   * @ignore\n   */\n  constructor(rangeMin, rangeMax, isMinInclusive, isMaxInclusive) {\n    this.min = rangeMin;\n    this.max = rangeMax;\n    this.isMinInclusive = isMinInclusive;\n    this.isMaxInclusive = isMaxInclusive;\n  }\n\n  overlaps(other) {\n    // tslint:disable-next-line:no-this-assignment\n    const range1 = this;\n    const range2 = other;\n\n    if (range1 === undefined || range2 === undefined) {\n      return false;\n    }\n\n    if (range1.isEmpty() || range2.isEmpty()) {\n      return false;\n    }\n\n    if (range1.min <= range2.max || range2.min <= range1.max) {\n      if (range1.min === range2.max && !(range1.isMinInclusive && range2.isMaxInclusive) || range2.min === range1.max && !(range2.isMinInclusive && range1.isMaxInclusive)) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  isFullRange() {\n    return this.min === Constants.EffectiveParitionKeyConstants.MinimumInclusiveEffectivePartitionKey && this.max === Constants.EffectiveParitionKeyConstants.MaximumExclusiveEffectivePartitionKey && this.isMinInclusive === true && this.isMaxInclusive === false;\n  }\n\n  isEmpty() {\n    return !(this.isMinInclusive && this.isMaxInclusive) && this.min === this.max;\n  }\n  /**\n   * Parse a QueryRange from a partitionKeyRange\n   * @returns QueryRange\n   * @ignore\n   */\n\n\n  static parsePartitionKeyRange(partitionKeyRange) {\n    // TODO: paritionkeyrange\n    return new QueryRange(partitionKeyRange[Constants.PartitionKeyRange.MinInclusive], partitionKeyRange[Constants.PartitionKeyRange.MaxExclusive], true, false);\n  }\n  /**\n   * Parse a QueryRange from a dictionary\n   * @returns QueryRange\n   * @ignore\n   */\n\n\n  static parseFromDict(queryRangeDict) {\n    // TODO: queryRangeDictionary\n    return new QueryRange(queryRangeDict.min, queryRangeDict.max, queryRangeDict.isMinInclusive, queryRangeDict.isMaxInclusive);\n  }\n\n}","map":{"version":3,"sources":["../../src/routing/QueryRange.ts"],"names":[],"mappings":"AAAA;AACA;AACA,SAAS,SAAT,QAA0B,WAA1B;AAEA;;AACA,OAAM,MAAO,UAAP,CAAiB;AAMrB;;;;;;;;;AASA,EAAA,WAAA,CACE,QADF,EAEE,QAFF,EAGE,cAHF,EAIE,cAJF,EAIyB;AAEvB,SAAK,GAAL,GAAW,QAAX;AACA,SAAK,GAAL,GAAW,QAAX;AACA,SAAK,cAAL,GAAsB,cAAtB;AACA,SAAK,cAAL,GAAsB,cAAtB;AACD;;AACM,EAAA,QAAQ,CAAC,KAAD,EAAkB;AAC/B;AACA,UAAM,MAAM,GAAG,IAAf;AACA,UAAM,MAAM,GAAG,KAAf;;AACA,QAAI,MAAM,KAAK,SAAX,IAAwB,MAAM,KAAK,SAAvC,EAAkD;AAChD,aAAO,KAAP;AACD;;AACD,QAAI,MAAM,CAAC,OAAP,MAAoB,MAAM,CAAC,OAAP,EAAxB,EAA0C;AACxC,aAAO,KAAP;AACD;;AAED,QAAI,MAAM,CAAC,GAAP,IAAc,MAAM,CAAC,GAArB,IAA4B,MAAM,CAAC,GAAP,IAAc,MAAM,CAAC,GAArD,EAA0D;AACxD,UACG,MAAM,CAAC,GAAP,KAAe,MAAM,CAAC,GAAtB,IAA6B,EAAE,MAAM,CAAC,cAAP,IAAyB,MAAM,CAAC,cAAlC,CAA9B,IACC,MAAM,CAAC,GAAP,KAAe,MAAM,CAAC,GAAtB,IAA6B,EAAE,MAAM,CAAC,cAAP,IAAyB,MAAM,CAAC,cAAlC,CAFhC,EAGE;AACA,eAAO,KAAP;AACD;;AACD,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD;;AAEM,EAAA,WAAW,GAAA;AAChB,WACE,KAAK,GAAL,KAAa,SAAS,CAAC,6BAAV,CAAwC,qCAArD,IACA,KAAK,GAAL,KAAa,SAAS,CAAC,6BAAV,CAAwC,qCADrD,IAEA,KAAK,cAAL,KAAwB,IAFxB,IAGA,KAAK,cAAL,KAAwB,KAJ1B;AAMD;;AAEM,EAAA,OAAO,GAAA;AACZ,WAAO,EAAE,KAAK,cAAL,IAAuB,KAAK,cAA9B,KAAiD,KAAK,GAAL,KAAa,KAAK,GAA1E;AACD;AACD;;;;;;;AAKO,SAAO,sBAAP,CAA8B,iBAA9B,EAAoD;AACzD;AACA,WAAO,IAAI,UAAJ,CACL,iBAAiB,CAAC,SAAS,CAAC,iBAAV,CAA4B,YAA7B,CADZ,EAEL,iBAAiB,CAAC,SAAS,CAAC,iBAAV,CAA4B,YAA7B,CAFZ,EAGL,IAHK,EAIL,KAJK,CAAP;AAMD;AACD;;;;;;;AAKO,SAAO,aAAP,CAAqB,cAArB,EAAwC;AAC7C;AACA,WAAO,IAAI,UAAJ,CACL,cAAc,CAAC,GADV,EAEL,cAAc,CAAC,GAFV,EAGL,cAAc,CAAC,cAHV,EAIL,cAAc,CAAC,cAJV,CAAP;AAMD;;AAxFoB","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Constants } from \"../common\";\n\n/** @hidden */\nexport class QueryRange {\n  public min: string;\n  public max: string;\n  public isMinInclusive: boolean;\n  public isMaxInclusive: boolean;\n\n  /**\n   * Represents a QueryRange.\n   * @constructor QueryRange\n   * @param {string} rangeMin                - min\n   * @param {string} rangeMin                - max\n   * @param {boolean} isMinInclusive         - isMinInclusive\n   * @param {boolean} isMaxInclusive         - isMaxInclusive\n   * @ignore\n   */\n  constructor(\n    rangeMin: string,\n    rangeMax: string,\n    isMinInclusive: boolean,\n    isMaxInclusive: boolean\n  ) {\n    this.min = rangeMin;\n    this.max = rangeMax;\n    this.isMinInclusive = isMinInclusive;\n    this.isMaxInclusive = isMaxInclusive;\n  }\n  public overlaps(other: QueryRange) {\n    // tslint:disable-next-line:no-this-assignment\n    const range1 = this;\n    const range2 = other;\n    if (range1 === undefined || range2 === undefined) {\n      return false;\n    }\n    if (range1.isEmpty() || range2.isEmpty()) {\n      return false;\n    }\n\n    if (range1.min <= range2.max || range2.min <= range1.max) {\n      if (\n        (range1.min === range2.max && !(range1.isMinInclusive && range2.isMaxInclusive)) ||\n        (range2.min === range1.max && !(range2.isMinInclusive && range1.isMaxInclusive))\n      ) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  public isFullRange() {\n    return (\n      this.min === Constants.EffectiveParitionKeyConstants.MinimumInclusiveEffectivePartitionKey &&\n      this.max === Constants.EffectiveParitionKeyConstants.MaximumExclusiveEffectivePartitionKey &&\n      this.isMinInclusive === true &&\n      this.isMaxInclusive === false\n    );\n  }\n\n  public isEmpty() {\n    return !(this.isMinInclusive && this.isMaxInclusive) && this.min === this.max;\n  }\n  /**\n   * Parse a QueryRange from a partitionKeyRange\n   * @returns QueryRange\n   * @ignore\n   */\n  public static parsePartitionKeyRange(partitionKeyRange: any) {\n    // TODO: paritionkeyrange\n    return new QueryRange(\n      partitionKeyRange[Constants.PartitionKeyRange.MinInclusive],\n      partitionKeyRange[Constants.PartitionKeyRange.MaxExclusive],\n      true,\n      false\n    );\n  }\n  /**\n   * Parse a QueryRange from a dictionary\n   * @returns QueryRange\n   * @ignore\n   */\n  public static parseFromDict(queryRangeDict: any) {\n    // TODO: queryRangeDictionary\n    return new QueryRange(\n      queryRangeDict.min,\n      queryRangeDict.max,\n      queryRangeDict.isMinInclusive,\n      queryRangeDict.isMaxInclusive\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}