{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { isReadRequest } from \"../common/helper\";\n/**\n * This class implements the retry policy for endpoint discovery.\n * @hidden\n */\n\nexport class EndpointDiscoveryRetryPolicy {\n  /**\n   * @constructor EndpointDiscoveryRetryPolicy\n   * @param {object} globalEndpointManager The GlobalEndpointManager instance.\n   */\n  constructor(globalEndpointManager, operationType) {\n    this.globalEndpointManager = globalEndpointManager;\n    this.operationType = operationType;\n    this.maxTries = EndpointDiscoveryRetryPolicy.maxTries;\n    this.currentRetryAttemptCount = 0;\n    this.retryAfterInMs = EndpointDiscoveryRetryPolicy.retryAfterInMs;\n  }\n  /**\n   * Determines whether the request should be retried or not.\n   * @param {object} err - Error returned by the request.\n   */\n\n\n  shouldRetry(err, retryContext, locationEndpoint) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!err) {\n        return false;\n      }\n\n      if (!retryContext || !locationEndpoint) {\n        return false;\n      }\n\n      if (!this.globalEndpointManager.enableEndpointDiscovery) {\n        return false;\n      }\n\n      if (this.currentRetryAttemptCount >= this.maxTries) {\n        return false;\n      }\n\n      this.currentRetryAttemptCount++;\n\n      if (isReadRequest(this.operationType)) {\n        yield this.globalEndpointManager.markCurrentLocationUnavailableForRead(locationEndpoint);\n      } else {\n        yield this.globalEndpointManager.markCurrentLocationUnavailableForWrite(locationEndpoint);\n      }\n\n      retryContext.retryCount = this.currentRetryAttemptCount;\n      retryContext.clearSessionTokenNotAvailable = false;\n      retryContext.retryRequestOnPreferredLocations = false;\n      return true;\n    });\n  }\n\n}\nEndpointDiscoveryRetryPolicy.maxTries = 120; // TODO: Constant?\n\nEndpointDiscoveryRetryPolicy.retryAfterInMs = 1000;","map":{"version":3,"sources":["../../src/retry/endpointDiscoveryRetryPolicy.ts"],"names":[],"mappings":";AAGA,SAAS,aAAT,QAA8B,kBAA9B;AAMA;;;;;AAIA,OAAM,MAAO,4BAAP,CAAmC;AAWvC;;;;AAIA,EAAA,WAAA,CACU,qBADV,EAEU,aAFV,EAEsC;AAD5B,SAAA,qBAAA,GAAA,qBAAA;AACA,SAAA,aAAA,GAAA,aAAA;AAER,SAAK,QAAL,GAAgB,4BAA4B,CAAC,QAA7C;AACA,SAAK,wBAAL,GAAgC,CAAhC;AACA,SAAK,cAAL,GAAsB,4BAA4B,CAAC,cAAnD;AACD;AAED;;;;;;AAIa,EAAA,WAAW,CACtB,GADsB,EAEtB,YAFsB,EAGtB,gBAHsB,EAGG;;AAEzB,UAAI,CAAC,GAAL,EAAU;AACR,eAAO,KAAP;AACD;;AAED,UAAI,CAAC,YAAD,IAAiB,CAAC,gBAAtB,EAAwC;AACtC,eAAO,KAAP;AACD;;AAED,UAAI,CAAC,KAAK,qBAAL,CAA2B,uBAAhC,EAAyD;AACvD,eAAO,KAAP;AACD;;AAED,UAAI,KAAK,wBAAL,IAAiC,KAAK,QAA1C,EAAoD;AAClD,eAAO,KAAP;AACD;;AAED,WAAK,wBAAL;;AAEA,UAAI,aAAa,CAAC,KAAK,aAAN,CAAjB,EAAuC;AACrC,cAAM,KAAK,qBAAL,CAA2B,qCAA3B,CAAiE,gBAAjE,CAAN;AACD,OAFD,MAEO;AACL,cAAM,KAAK,qBAAL,CAA2B,sCAA3B,CAAkE,gBAAlE,CAAN;AACD;;AAED,MAAA,YAAY,CAAC,UAAb,GAA0B,KAAK,wBAA/B;AACA,MAAA,YAAY,CAAC,6BAAb,GAA6C,KAA7C;AACA,MAAA,YAAY,CAAC,gCAAb,GAAgD,KAAhD;AAEA,aAAO,IAAP;AACD,K;AAAA;;AA9DsC;AAQf,4BAAA,CAAA,QAAA,GAAW,GAAX,C,CAAgB;;AAChB,4BAAA,CAAA,cAAA,GAAiB,IAAjB","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { OperationType } from \"../common\";\nimport { isReadRequest } from \"../common/helper\";\nimport { GlobalEndpointManager } from \"../globalEndpointManager\";\nimport { ErrorResponse } from \"../request\";\nimport { RetryContext } from \"./RetryContext\";\nimport { RetryPolicy } from \"./RetryPolicy\";\n\n/**\n * This class implements the retry policy for endpoint discovery.\n * @hidden\n */\nexport class EndpointDiscoveryRetryPolicy implements RetryPolicy {\n  /** Current retry attempt count. */\n  public currentRetryAttemptCount: number;\n  /** Retry interval in milliseconds. */\n  public retryAfterInMs: number;\n\n  /** Max number of retry attempts to perform. */\n  private maxTries: number;\n  private static readonly maxTries = 120; // TODO: Constant?\n  private static readonly retryAfterInMs = 1000;\n\n  /**\n   * @constructor EndpointDiscoveryRetryPolicy\n   * @param {object} globalEndpointManager The GlobalEndpointManager instance.\n   */\n  constructor(\n    private globalEndpointManager: GlobalEndpointManager,\n    private operationType: OperationType\n  ) {\n    this.maxTries = EndpointDiscoveryRetryPolicy.maxTries;\n    this.currentRetryAttemptCount = 0;\n    this.retryAfterInMs = EndpointDiscoveryRetryPolicy.retryAfterInMs;\n  }\n\n  /**\n   * Determines whether the request should be retried or not.\n   * @param {object} err - Error returned by the request.\n   */\n  public async shouldRetry(\n    err: ErrorResponse,\n    retryContext?: RetryContext,\n    locationEndpoint?: string\n  ): Promise<boolean | [boolean, string]> {\n    if (!err) {\n      return false;\n    }\n\n    if (!retryContext || !locationEndpoint) {\n      return false;\n    }\n\n    if (!this.globalEndpointManager.enableEndpointDiscovery) {\n      return false;\n    }\n\n    if (this.currentRetryAttemptCount >= this.maxTries) {\n      return false;\n    }\n\n    this.currentRetryAttemptCount++;\n\n    if (isReadRequest(this.operationType)) {\n      await this.globalEndpointManager.markCurrentLocationUnavailableForRead(locationEndpoint);\n    } else {\n      await this.globalEndpointManager.markCurrentLocationUnavailableForWrite(locationEndpoint);\n    }\n\n    retryContext.retryCount = this.currentRetryAttemptCount;\n    retryContext.clearSessionTokenNotAvailable = false;\n    retryContext.retryRequestOnPreferredLocations = false;\n\n    return true;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}