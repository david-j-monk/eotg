{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Constants } from \"../common\";\nimport { QueryMetrics } from \"../queryMetrics/queryMetrics\";\n/** @hidden */\n// TODO: docs\n\nexport function getRequestChargeIfAny(headers) {\n  if (typeof headers === \"number\") {\n    return headers;\n  } else if (typeof headers === \"string\") {\n    return parseFloat(headers);\n  }\n\n  if (headers) {\n    const rc = headers[Constants.HttpHeaders.RequestCharge];\n\n    if (rc) {\n      return parseFloat(rc);\n    } else {\n      return 0;\n    }\n  } else {\n    return 0;\n  }\n}\n/**\n * @ignore\n */\n\nexport function getInitialHeader() {\n  const headers = {};\n  headers[Constants.HttpHeaders.RequestCharge] = 0;\n  headers[Constants.HttpHeaders.QueryMetrics] = {};\n  return headers;\n}\n/**\n * @ignore\n * @param headers\n * @param toBeMergedHeaders\n */\n// TODO: The name of this method isn't very accurate to what it does\n\nexport function mergeHeaders(headers, toBeMergedHeaders) {\n  if (headers[Constants.HttpHeaders.RequestCharge] === undefined) {\n    headers[Constants.HttpHeaders.RequestCharge] = 0;\n  }\n\n  if (headers[Constants.HttpHeaders.QueryMetrics] === undefined) {\n    headers[Constants.HttpHeaders.QueryMetrics] = QueryMetrics.zero;\n  }\n\n  if (!toBeMergedHeaders) {\n    return;\n  }\n\n  headers[Constants.HttpHeaders.RequestCharge] += getRequestChargeIfAny(toBeMergedHeaders);\n\n  if (toBeMergedHeaders[Constants.HttpHeaders.IsRUPerMinuteUsed]) {\n    headers[Constants.HttpHeaders.IsRUPerMinuteUsed] = toBeMergedHeaders[Constants.HttpHeaders.IsRUPerMinuteUsed];\n  }\n\n  if (Constants.HttpHeaders.QueryMetrics in toBeMergedHeaders) {\n    const headerQueryMetrics = headers[Constants.HttpHeaders.QueryMetrics];\n    const toBeMergedHeaderQueryMetrics = toBeMergedHeaders[Constants.HttpHeaders.QueryMetrics];\n\n    for (const partitionId in toBeMergedHeaderQueryMetrics) {\n      if (headerQueryMetrics[partitionId]) {\n        const combinedQueryMetrics = headerQueryMetrics[partitionId].add([toBeMergedHeaderQueryMetrics[partitionId]]);\n        headerQueryMetrics[partitionId] = combinedQueryMetrics;\n      } else {\n        headerQueryMetrics[partitionId] = toBeMergedHeaderQueryMetrics[partitionId];\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../../src/queryExecutionContext/headerUtils.ts"],"names":[],"mappings":"AAAA;AACA;AACA,SAAS,SAAT,QAA0B,WAA1B;AACA,SAAS,YAAT,QAA6B,8BAA7B;AAMA;AACA;;AACA,OAAM,SAAU,qBAAV,CAAgC,OAAhC,EAA+D;AACnE,MAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,WAAO,OAAP;AACD,GAFD,MAEO,IAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AACtC,WAAO,UAAU,CAAC,OAAD,CAAjB;AACD;;AAED,MAAI,OAAJ,EAAa;AACX,UAAM,EAAE,GAAG,OAAO,CAAC,SAAS,CAAC,WAAV,CAAsB,aAAvB,CAAlB;;AACA,QAAI,EAAJ,EAAQ;AACN,aAAO,UAAU,CAAC,EAAD,CAAjB;AACD,KAFD,MAEO;AACL,aAAO,CAAP;AACD;AACF,GAPD,MAOO;AACL,WAAO,CAAP;AACD;AACF;AAED;;;;AAGA,OAAM,SAAU,gBAAV,GAA0B;AAC9B,QAAM,OAAO,GAAkB,EAA/B;AACA,EAAA,OAAO,CAAC,SAAS,CAAC,WAAV,CAAsB,aAAvB,CAAP,GAA+C,CAA/C;AACA,EAAA,OAAO,CAAC,SAAS,CAAC,WAAV,CAAsB,YAAvB,CAAP,GAA8C,EAA9C;AACA,SAAO,OAAP;AACD;AAED;;;;;AAKA;;AACA,OAAM,SAAU,YAAV,CAAuB,OAAvB,EAA+C,iBAA/C,EAA+E;AACnF,MAAI,OAAO,CAAC,SAAS,CAAC,WAAV,CAAsB,aAAvB,CAAP,KAAiD,SAArD,EAAgE;AAC9D,IAAA,OAAO,CAAC,SAAS,CAAC,WAAV,CAAsB,aAAvB,CAAP,GAA+C,CAA/C;AACD;;AAED,MAAI,OAAO,CAAC,SAAS,CAAC,WAAV,CAAsB,YAAvB,CAAP,KAAgD,SAApD,EAA+D;AAC7D,IAAA,OAAO,CAAC,SAAS,CAAC,WAAV,CAAsB,YAAvB,CAAP,GAA8C,YAAY,CAAC,IAA3D;AACD;;AAED,MAAI,CAAC,iBAAL,EAAwB;AACtB;AACD;;AAED,EAAA,OAAO,CAAC,SAAS,CAAC,WAAV,CAAsB,aAAvB,CAAP,IAAgD,qBAAqB,CAAC,iBAAD,CAArE;;AACA,MAAI,iBAAiB,CAAC,SAAS,CAAC,WAAV,CAAsB,iBAAvB,CAArB,EAAgE;AAC9D,IAAA,OAAO,CAAC,SAAS,CAAC,WAAV,CAAsB,iBAAvB,CAAP,GACE,iBAAiB,CAAC,SAAS,CAAC,WAAV,CAAsB,iBAAvB,CADnB;AAED;;AAED,MAAI,SAAS,CAAC,WAAV,CAAsB,YAAtB,IAAsC,iBAA1C,EAA6D;AAC3D,UAAM,kBAAkB,GAAG,OAAO,CAAC,SAAS,CAAC,WAAV,CAAsB,YAAvB,CAAlC;AACA,UAAM,4BAA4B,GAAG,iBAAiB,CAAC,SAAS,CAAC,WAAV,CAAsB,YAAvB,CAAtD;;AAEA,SAAK,MAAM,WAAX,IAA0B,4BAA1B,EAAwD;AACtD,UAAI,kBAAkB,CAAC,WAAD,CAAtB,EAAqC;AACnC,cAAM,oBAAoB,GAAG,kBAAkB,CAAC,WAAD,CAAlB,CAAgC,GAAhC,CAAoC,CAC/D,4BAA4B,CAAC,WAAD,CADmC,CAApC,CAA7B;AAGA,QAAA,kBAAkB,CAAC,WAAD,CAAlB,GAAkC,oBAAlC;AACD,OALD,MAKO;AACL,QAAA,kBAAkB,CAAC,WAAD,CAAlB,GAAkC,4BAA4B,CAAC,WAAD,CAA9D;AACD;AACF;AACF;AACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Constants } from \"../common\";\nimport { QueryMetrics } from \"../queryMetrics/queryMetrics\";\n\nexport interface CosmosHeaders {\n  [key: string]: any;\n}\n\n/** @hidden */\n// TODO: docs\nexport function getRequestChargeIfAny(headers: CosmosHeaders | number): number {\n  if (typeof headers === \"number\") {\n    return headers;\n  } else if (typeof headers === \"string\") {\n    return parseFloat(headers);\n  }\n\n  if (headers) {\n    const rc = headers[Constants.HttpHeaders.RequestCharge];\n    if (rc) {\n      return parseFloat(rc as string);\n    } else {\n      return 0;\n    }\n  } else {\n    return 0;\n  }\n}\n\n/**\n * @ignore\n */\nexport function getInitialHeader(): CosmosHeaders {\n  const headers: CosmosHeaders = {};\n  headers[Constants.HttpHeaders.RequestCharge] = 0;\n  headers[Constants.HttpHeaders.QueryMetrics] = {};\n  return headers;\n}\n\n/**\n * @ignore\n * @param headers\n * @param toBeMergedHeaders\n */\n// TODO: The name of this method isn't very accurate to what it does\nexport function mergeHeaders(headers: CosmosHeaders, toBeMergedHeaders: CosmosHeaders) {\n  if (headers[Constants.HttpHeaders.RequestCharge] === undefined) {\n    headers[Constants.HttpHeaders.RequestCharge] = 0;\n  }\n\n  if (headers[Constants.HttpHeaders.QueryMetrics] === undefined) {\n    headers[Constants.HttpHeaders.QueryMetrics] = QueryMetrics.zero;\n  }\n\n  if (!toBeMergedHeaders) {\n    return;\n  }\n\n  headers[Constants.HttpHeaders.RequestCharge] += getRequestChargeIfAny(toBeMergedHeaders);\n  if (toBeMergedHeaders[Constants.HttpHeaders.IsRUPerMinuteUsed]) {\n    headers[Constants.HttpHeaders.IsRUPerMinuteUsed] =\n      toBeMergedHeaders[Constants.HttpHeaders.IsRUPerMinuteUsed];\n  }\n\n  if (Constants.HttpHeaders.QueryMetrics in toBeMergedHeaders) {\n    const headerQueryMetrics = headers[Constants.HttpHeaders.QueryMetrics];\n    const toBeMergedHeaderQueryMetrics = toBeMergedHeaders[Constants.HttpHeaders.QueryMetrics];\n\n    for (const partitionId in toBeMergedHeaderQueryMetrics) {\n      if (headerQueryMetrics[partitionId]) {\n        const combinedQueryMetrics = headerQueryMetrics[partitionId].add([\n          toBeMergedHeaderQueryMetrics[partitionId]\n        ]);\n        headerQueryMetrics[partitionId] = combinedQueryMetrics;\n      } else {\n        headerQueryMetrics[partitionId] = toBeMergedHeaderQueryMetrics[partitionId];\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}