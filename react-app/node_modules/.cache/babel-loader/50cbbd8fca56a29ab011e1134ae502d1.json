{"ast":null,"code":"import { __awaiter } from \"tslib\"; // Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { generateHeaders } from \"./utils/headers\";\nimport { Constants, getResourceIdFromPath, ResourceType, trimSlashFromLeftAndRight } from \"./common\";\n/**\n * @ignore\n * @param clientOptions\n * @param verb\n * @param path\n * @param resourceId\n * @param resourceType\n * @param headers\n */\n\nexport function setAuthorizationHeader(clientOptions, verb, path, resourceId, resourceType, headers) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (clientOptions.permissionFeed) {\n      clientOptions.resourceTokens = {};\n\n      for (const permission of clientOptions.permissionFeed) {\n        const id = getResourceIdFromPath(permission.resource);\n\n        if (!id) {\n          throw new Error(`authorization error: ${id} \\\n                          is an invalid resourceId in permissionFeed`);\n        }\n\n        clientOptions.resourceTokens[id] = permission._token; // TODO: any\n      }\n    }\n\n    if (clientOptions.key) {\n      yield setAuthorizationTokenHeaderUsingMasterKey(verb, resourceId, resourceType, headers, clientOptions.key);\n    } else if (clientOptions.resourceTokens) {\n      headers[Constants.HttpHeaders.Authorization] = encodeURIComponent(getAuthorizationTokenUsingResourceTokens(clientOptions.resourceTokens, path, resourceId));\n    } else if (clientOptions.tokenProvider) {\n      headers[Constants.HttpHeaders.Authorization] = encodeURIComponent(yield clientOptions.tokenProvider({\n        verb,\n        path,\n        resourceId,\n        resourceType,\n        headers\n      }));\n    }\n  });\n}\n/**\n * The default function for setting header token using the masterKey\n * @ignore\n */\n\nexport function setAuthorizationTokenHeaderUsingMasterKey(verb, resourceId, resourceType, headers, masterKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // TODO This should live in cosmos-sign\n    if (resourceType === ResourceType.offer) {\n      resourceId = resourceId && resourceId.toLowerCase();\n    }\n\n    headers = Object.assign(headers, yield generateHeaders(masterKey, verb, resourceType, resourceId));\n  });\n}\n/**\n * @ignore\n * @param resourceTokens\n * @param path\n * @param resourceId\n */\n// TODO: Resource tokens\n\nexport function getAuthorizationTokenUsingResourceTokens(resourceTokens, path, resourceId) {\n  if (resourceTokens && Object.keys(resourceTokens).length > 0) {\n    // For database account access(through getDatabaseAccount API), path and resourceId are \"\",\n    // so in this case we return the first token to be used for creating the auth header as the\n    // service will accept any token in this case\n    if (!path && !resourceId) {\n      return resourceTokens[Object.keys(resourceTokens)[0]];\n    } // If we have exact resource token for the path use it\n\n\n    if (resourceId && resourceTokens[resourceId]) {\n      return resourceTokens[resourceId];\n    } // minimum valid path /dbs\n\n\n    if (!path || path.length < 4) {\n      // TODO: This should throw an error\n      return null;\n    }\n\n    path = trimSlashFromLeftAndRight(path);\n    const pathSegments = path && path.split(\"/\") || []; // Item path\n\n    if (pathSegments.length === 6) {\n      // Look for a container token matching the item path\n      const containerPath = pathSegments.slice(0, 4).map(decodeURIComponent).join(\"/\");\n\n      if (resourceTokens[containerPath]) {\n        return resourceTokens[containerPath];\n      }\n    } // TODO remove in v4: This is legacy behavior that lets someone use a resource token pointing ONLY at an ID\n    // It was used when _rid was exposed by the SDK, but now that we are using user provided ids it is not needed\n    // However removing it now would be a breaking change\n    // if it's an incomplete path like /dbs/db1/colls/, start from the parent resource\n\n\n    let index = pathSegments.length % 2 === 0 ? pathSegments.length - 1 : pathSegments.length - 2;\n\n    for (; index > 0; index -= 2) {\n      const id = decodeURI(pathSegments[index]);\n\n      if (resourceTokens[id]) {\n        return resourceTokens[id];\n      }\n    }\n  } // TODO: This should throw an error\n\n\n  return null;\n}","map":{"version":3,"sources":["../src/auth.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { generateHeaders } from \"./utils/headers\";\nimport {\n  Constants,\n  getResourceIdFromPath,\n  HTTPMethod,\n  ResourceType,\n  trimSlashFromLeftAndRight\n} from \"./common\";\nimport { CosmosClientOptions } from \"./CosmosClientOptions\";\nimport { CosmosHeaders } from \"./queryExecutionContext\";\n\n/** @hidden */\nexport interface RequestInfo {\n  verb: HTTPMethod;\n  path: string;\n  resourceId: string;\n  resourceType: ResourceType;\n  headers: CosmosHeaders;\n}\n\nexport type TokenProvider = (requestInfo: RequestInfo) => Promise<string>;\n\n/**\n * @ignore\n * @param clientOptions\n * @param verb\n * @param path\n * @param resourceId\n * @param resourceType\n * @param headers\n */\nexport async function setAuthorizationHeader(\n  clientOptions: CosmosClientOptions,\n  verb: HTTPMethod,\n  path: string,\n  resourceId: string,\n  resourceType: ResourceType,\n  headers: CosmosHeaders\n): Promise<void> {\n  if (clientOptions.permissionFeed) {\n    clientOptions.resourceTokens = {};\n    for (const permission of clientOptions.permissionFeed) {\n      const id = getResourceIdFromPath(permission.resource);\n      if (!id) {\n        throw new Error(`authorization error: ${id} \\\n                          is an invalid resourceId in permissionFeed`);\n      }\n\n      clientOptions.resourceTokens[id] = (permission as any)._token; // TODO: any\n    }\n  }\n\n  if (clientOptions.key) {\n    await setAuthorizationTokenHeaderUsingMasterKey(\n      verb,\n      resourceId,\n      resourceType,\n      headers,\n      clientOptions.key\n    );\n  } else if (clientOptions.resourceTokens) {\n    headers[Constants.HttpHeaders.Authorization] = encodeURIComponent(\n      getAuthorizationTokenUsingResourceTokens(clientOptions.resourceTokens, path, resourceId)\n    );\n  } else if (clientOptions.tokenProvider) {\n    headers[Constants.HttpHeaders.Authorization] = encodeURIComponent(\n      await clientOptions.tokenProvider({ verb, path, resourceId, resourceType, headers })\n    );\n  }\n}\n\n/**\n * The default function for setting header token using the masterKey\n * @ignore\n */\nexport async function setAuthorizationTokenHeaderUsingMasterKey(\n  verb: HTTPMethod,\n  resourceId: string,\n  resourceType: ResourceType,\n  headers: CosmosHeaders,\n  masterKey: string\n) {\n  // TODO This should live in cosmos-sign\n  if (resourceType === ResourceType.offer) {\n    resourceId = resourceId && resourceId.toLowerCase();\n  }\n  headers = Object.assign(\n    headers,\n    await generateHeaders(masterKey, verb, resourceType, resourceId)\n  );\n}\n\n/**\n * @ignore\n * @param resourceTokens\n * @param path\n * @param resourceId\n */\n// TODO: Resource tokens\nexport function getAuthorizationTokenUsingResourceTokens(\n  resourceTokens: { [resourceId: string]: string },\n  path: string,\n  resourceId: string\n) {\n  if (resourceTokens && Object.keys(resourceTokens).length > 0) {\n    // For database account access(through getDatabaseAccount API), path and resourceId are \"\",\n    // so in this case we return the first token to be used for creating the auth header as the\n    // service will accept any token in this case\n    if (!path && !resourceId) {\n      return resourceTokens[Object.keys(resourceTokens)[0]];\n    }\n\n    // If we have exact resource token for the path use it\n    if (resourceId && resourceTokens[resourceId]) {\n      return resourceTokens[resourceId];\n    }\n\n    // minimum valid path /dbs\n    if (!path || path.length < 4) {\n      // TODO: This should throw an error\n      return null;\n    }\n\n    path = trimSlashFromLeftAndRight(path);\n    const pathSegments = (path && path.split(\"/\")) || [];\n\n    // Item path\n    if (pathSegments.length === 6) {\n      // Look for a container token matching the item path\n      const containerPath = pathSegments\n        .slice(0, 4)\n        .map(decodeURIComponent)\n        .join(\"/\");\n      if (resourceTokens[containerPath]) {\n        return resourceTokens[containerPath];\n      }\n    }\n\n    // TODO remove in v4: This is legacy behavior that lets someone use a resource token pointing ONLY at an ID\n    // It was used when _rid was exposed by the SDK, but now that we are using user provided ids it is not needed\n    // However removing it now would be a breaking change\n    // if it's an incomplete path like /dbs/db1/colls/, start from the parent resource\n    let index = pathSegments.length % 2 === 0 ? pathSegments.length - 1 : pathSegments.length - 2;\n    for (; index > 0; index -= 2) {\n      const id = decodeURI(pathSegments[index]);\n      if (resourceTokens[id]) {\n        return resourceTokens[id];\n      }\n    }\n  }\n\n  // TODO: This should throw an error\n  return null;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}