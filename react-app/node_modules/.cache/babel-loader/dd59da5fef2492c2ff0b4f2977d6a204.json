{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { hashObject } from \"../../utils/hashObject\";\nimport { createAggregator } from \"../Aggregators\";\nimport { getInitialHeader, mergeHeaders } from \"../headerUtils\";\nimport { emptyGroup, extractAggregateResult } from \"./emptyGroup\";\n/** @hidden */\n\nexport class GroupByEndpointComponent {\n  constructor(executionContext, queryInfo) {\n    this.executionContext = executionContext;\n    this.queryInfo = queryInfo;\n    this.groupings = new Map();\n    this.aggregateResultArray = [];\n    this.completed = false;\n  }\n\n  nextItem() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // If we have a full result set, begin returning results\n      if (this.aggregateResultArray.length > 0) {\n        return {\n          result: this.aggregateResultArray.pop(),\n          headers: getInitialHeader()\n        };\n      }\n\n      if (this.completed) {\n        return {\n          result: undefined,\n          headers: getInitialHeader()\n        };\n      }\n\n      const aggregateHeaders = getInitialHeader();\n\n      while (this.executionContext.hasMoreResults()) {\n        // Grab the next result\n        const {\n          result,\n          headers\n        } = yield this.executionContext.nextItem();\n        mergeHeaders(aggregateHeaders, headers); // If it exists, process it via aggregators\n\n        if (result) {\n          const group = result.groupByItems ? yield hashObject(result.groupByItems) : emptyGroup;\n          const aggregators = this.groupings.get(group);\n          const payload = result.payload;\n\n          if (aggregators) {\n            // Iterator over all results in the payload\n            Object.keys(payload).map(key => {\n              const aggregateResult = extractAggregateResult(payload[key]);\n              aggregators.get(key).aggregate(aggregateResult);\n            });\n          } else {\n            // This is the first time we have seen a grouping. Setup the initial result without aggregate values\n            const grouping = new Map();\n            this.groupings.set(group, grouping); // Iterator over all results in the payload\n\n            Object.keys(payload).map(key => {\n              const aggregateType = this.queryInfo.groupByAliasToAggregateType[key]; // Create a new aggregator for this specific aggregate field\n\n              const aggregator = createAggregator(aggregateType);\n              grouping.set(key, aggregator);\n\n              if (aggregateType) {\n                const aggregateResult = extractAggregateResult(payload[key]);\n                aggregator.aggregate(aggregateResult);\n              } else {\n                aggregator.aggregate(payload[key]);\n              }\n            });\n          }\n        }\n      }\n\n      for (const grouping of this.groupings.values()) {\n        const groupResult = {};\n\n        for (const [aggregateKey, aggregator] of grouping.entries()) {\n          groupResult[aggregateKey] = aggregator.getResult();\n        }\n\n        this.aggregateResultArray.push(groupResult);\n      }\n\n      this.completed = true;\n      return {\n        result: this.aggregateResultArray.pop(),\n        headers: aggregateHeaders\n      };\n    });\n  }\n\n  hasMoreResults() {\n    return this.executionContext.hasMoreResults() || this.aggregateResultArray.length > 0;\n  }\n\n}","map":{"version":3,"sources":["../../../src/queryExecutionContext/EndpointComponent/GroupByEndpointComponent.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Response } from \"../../request\";\nimport { ExecutionContext } from \"../ExecutionContext\";\nimport { CosmosHeaders } from \"../CosmosHeaders\";\nimport { QueryInfo } from \"../../request/ErrorResponse\";\nimport { hashObject } from \"../../utils/hashObject\";\nimport { Aggregator, createAggregator } from \"../Aggregators\";\nimport { getInitialHeader, mergeHeaders } from \"../headerUtils\";\nimport { emptyGroup, extractAggregateResult } from \"./emptyGroup\";\n\ninterface GroupByResponse {\n  result: GroupByResult;\n  headers: CosmosHeaders;\n}\n\ninterface GroupByResult {\n  groupByItems: any[];\n  payload: any;\n}\n\n/** @hidden */\nexport class GroupByEndpointComponent implements ExecutionContext {\n  constructor(private executionContext: ExecutionContext, private queryInfo: QueryInfo) {}\n\n  private readonly groupings: Map<string, Map<string, Aggregator>> = new Map();\n  private readonly aggregateResultArray: any[] = [];\n  private completed: boolean = false;\n\n  public async nextItem(): Promise<Response<any>> {\n    // If we have a full result set, begin returning results\n    if (this.aggregateResultArray.length > 0) {\n      return { result: this.aggregateResultArray.pop(), headers: getInitialHeader() };\n    }\n\n    if (this.completed) {\n      return { result: undefined, headers: getInitialHeader() };\n    }\n\n    const aggregateHeaders = getInitialHeader();\n\n    while (this.executionContext.hasMoreResults()) {\n      // Grab the next result\n      const { result, headers } = (await this.executionContext.nextItem()) as GroupByResponse;\n      mergeHeaders(aggregateHeaders, headers);\n\n      // If it exists, process it via aggregators\n      if (result) {\n        const group = result.groupByItems ? await hashObject(result.groupByItems) : emptyGroup;\n        const aggregators = this.groupings.get(group);\n        const payload = result.payload;\n        if (aggregators) {\n          // Iterator over all results in the payload\n          Object.keys(payload).map((key) => {\n            const aggregateResult = extractAggregateResult(payload[key]);\n            aggregators.get(key).aggregate(aggregateResult);\n          });\n        } else {\n          // This is the first time we have seen a grouping. Setup the initial result without aggregate values\n          const grouping = new Map();\n          this.groupings.set(group, grouping);\n          // Iterator over all results in the payload\n          Object.keys(payload).map((key) => {\n            const aggregateType = this.queryInfo.groupByAliasToAggregateType[key];\n            // Create a new aggregator for this specific aggregate field\n            const aggregator = createAggregator(aggregateType);\n            grouping.set(key, aggregator);\n            if (aggregateType) {\n              const aggregateResult = extractAggregateResult(payload[key]);\n              aggregator.aggregate(aggregateResult);\n            } else {\n              aggregator.aggregate(payload[key]);\n            }\n          });\n        }\n      }\n    }\n\n    for (const grouping of this.groupings.values()) {\n      const groupResult: any = {};\n      for (const [aggregateKey, aggregator] of grouping.entries()) {\n        groupResult[aggregateKey] = aggregator.getResult();\n      }\n      this.aggregateResultArray.push(groupResult);\n    }\n    this.completed = true;\n    return { result: this.aggregateResultArray.pop(), headers: aggregateHeaders };\n  }\n\n  public hasMoreResults() {\n    return this.executionContext.hasMoreResults() || this.aggregateResultArray.length > 0;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}