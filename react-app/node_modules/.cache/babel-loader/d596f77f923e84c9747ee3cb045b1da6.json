{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { hashObject } from \"../../utils/hashObject\";\nimport { createAggregator } from \"../Aggregators\";\nimport { getInitialHeader, mergeHeaders } from \"../headerUtils\";\nimport { emptyGroup, extractAggregateResult } from \"./emptyGroup\";\n/** @hidden */\n\nexport class GroupByValueEndpointComponent {\n  constructor(executionContext, queryInfo) {\n    this.executionContext = executionContext;\n    this.queryInfo = queryInfo;\n    this.aggregators = new Map();\n    this.aggregateResultArray = [];\n    this.completed = false; // VALUE queries will only every have a single grouping\n\n    this.aggregateType = this.queryInfo.aggregates[0];\n  }\n\n  nextItem() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Start returning results if we have processed a full results set\n      if (this.aggregateResultArray.length > 0) {\n        return {\n          result: this.aggregateResultArray.pop(),\n          headers: getInitialHeader()\n        };\n      }\n\n      if (this.completed) {\n        return {\n          result: undefined,\n          headers: getInitialHeader()\n        };\n      }\n\n      const aggregateHeaders = getInitialHeader();\n\n      while (this.executionContext.hasMoreResults()) {\n        // Grab the next result\n        const {\n          result,\n          headers\n        } = yield this.executionContext.nextItem();\n        mergeHeaders(aggregateHeaders, headers); // If it exists, process it via aggregators\n\n        if (result) {\n          let grouping = emptyGroup;\n          let payload = result;\n\n          if (result.groupByItems) {\n            // If the query contains a GROUP BY clause, it will have a payload property and groupByItems\n            payload = result.payload;\n            grouping = yield hashObject(result.groupByItems);\n          }\n\n          const aggregator = this.aggregators.get(grouping);\n\n          if (!aggregator) {\n            // This is the first time we have seen a grouping so create a new aggregator\n            this.aggregators.set(grouping, createAggregator(this.aggregateType));\n          }\n\n          if (this.aggregateType) {\n            const aggregateResult = extractAggregateResult(payload[0]);\n            this.aggregators.get(grouping).aggregate(aggregateResult);\n          } else {\n            // Queries with no aggregates pass the payload directly to the aggregator\n            // Example: SELECT VALUE c.team FROM c GROUP BY c.team\n            this.aggregators.get(grouping).aggregate(payload);\n          }\n        }\n      } // It no results are left in the underling execution context, convert our aggregate results to an array\n\n\n      for (const aggregator of this.aggregators.values()) {\n        this.aggregateResultArray.push(aggregator.getResult());\n      }\n\n      this.completed = true;\n      return {\n        result: this.aggregateResultArray.pop(),\n        headers: aggregateHeaders\n      };\n    });\n  }\n\n  hasMoreResults() {\n    return this.executionContext.hasMoreResults() || this.aggregateResultArray.length > 0;\n  }\n\n}","map":{"version":3,"sources":["../../../src/queryExecutionContext/EndpointComponent/GroupByValueEndpointComponent.ts"],"names":[],"mappings":";AAMA,SAAS,UAAT,QAA2B,wBAA3B;AACA,SAAqB,gBAArB,QAA6C,gBAA7C;AACA,SAAS,gBAAT,EAA2B,YAA3B,QAA+C,gBAA/C;AACA,SAAS,UAAT,EAAqB,sBAArB,QAAmD,cAAnD;AAYA;;AACA,OAAM,MAAO,6BAAP,CAAoC;AAMxC,EAAA,WAAA,CAAoB,gBAApB,EAAgE,SAAhE,EAAoF;AAAhE,SAAA,gBAAA,GAAA,gBAAA;AAA4C,SAAA,SAAA,GAAA,SAAA;AAL/C,SAAA,WAAA,GAAuC,IAAI,GAAJ,EAAvC;AACA,SAAA,oBAAA,GAA8B,EAA9B;AAET,SAAA,SAAA,GAAqB,KAArB,CAE4E,CAClF;;AACA,SAAK,aAAL,GAAqB,KAAK,SAAL,CAAe,UAAf,CAA0B,CAA1B,CAArB;AACD;;AAEY,EAAA,QAAQ,GAAA;;AACnB;AACA,UAAI,KAAK,oBAAL,CAA0B,MAA1B,GAAmC,CAAvC,EAA0C;AACxC,eAAO;AAAE,UAAA,MAAM,EAAE,KAAK,oBAAL,CAA0B,GAA1B,EAAV;AAA2C,UAAA,OAAO,EAAE,gBAAgB;AAApE,SAAP;AACD;;AAED,UAAI,KAAK,SAAT,EAAoB;AAClB,eAAO;AAAE,UAAA,MAAM,EAAE,SAAV;AAAqB,UAAA,OAAO,EAAE,gBAAgB;AAA9C,SAAP;AACD;;AAED,YAAM,gBAAgB,GAAG,gBAAgB,EAAzC;;AAEA,aAAO,KAAK,gBAAL,CAAsB,cAAtB,EAAP,EAA+C;AAC7C;AACA,cAAM;AAAE,UAAA,MAAF;AAAU,UAAA;AAAV,YAAuB,MAAM,KAAK,gBAAL,CAAsB,QAAtB,EAAnC;AACA,QAAA,YAAY,CAAC,gBAAD,EAAmB,OAAnB,CAAZ,CAH6C,CAK7C;;AACA,YAAI,MAAJ,EAAY;AACV,cAAI,QAAQ,GAAW,UAAvB;AACA,cAAI,OAAO,GAAQ,MAAnB;;AACA,cAAI,MAAM,CAAC,YAAX,EAAyB;AACvB;AACA,YAAA,OAAO,GAAG,MAAM,CAAC,OAAjB;AACA,YAAA,QAAQ,GAAG,MAAM,UAAU,CAAC,MAAM,CAAC,YAAR,CAA3B;AACD;;AAED,gBAAM,UAAU,GAAG,KAAK,WAAL,CAAiB,GAAjB,CAAqB,QAArB,CAAnB;;AACA,cAAI,CAAC,UAAL,EAAiB;AACf;AACA,iBAAK,WAAL,CAAiB,GAAjB,CAAqB,QAArB,EAA+B,gBAAgB,CAAC,KAAK,aAAN,CAA/C;AACD;;AAED,cAAI,KAAK,aAAT,EAAwB;AACtB,kBAAM,eAAe,GAAG,sBAAsB,CAAC,OAAO,CAAC,CAAD,CAAR,CAA9C;AACA,iBAAK,WAAL,CAAiB,GAAjB,CAAqB,QAArB,EAA+B,SAA/B,CAAyC,eAAzC;AACD,WAHD,MAGO;AACL;AACA;AACA,iBAAK,WAAL,CAAiB,GAAjB,CAAqB,QAArB,EAA+B,SAA/B,CAAyC,OAAzC;AACD;AACF;AACF,O,CAED;;;AACA,WAAK,MAAM,UAAX,IAAyB,KAAK,WAAL,CAAiB,MAAjB,EAAzB,EAAoD;AAClD,aAAK,oBAAL,CAA0B,IAA1B,CAA+B,UAAU,CAAC,SAAX,EAA/B;AACD;;AACD,WAAK,SAAL,GAAiB,IAAjB;AACA,aAAO;AAAE,QAAA,MAAM,EAAE,KAAK,oBAAL,CAA0B,GAA1B,EAAV;AAA2C,QAAA,OAAO,EAAE;AAApD,OAAP;AACD,K;AAAA;;AAEM,EAAA,cAAc,GAAA;AACnB,WAAO,KAAK,gBAAL,CAAsB,cAAtB,MAA0C,KAAK,oBAAL,CAA0B,MAA1B,GAAmC,CAApF;AACD;;AAjEuC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Response } from \"../../request\";\nimport { ExecutionContext } from \"../ExecutionContext\";\nimport { CosmosHeaders } from \"../CosmosHeaders\";\nimport { AggregateType, QueryInfo } from \"../../request/ErrorResponse\";\nimport { hashObject } from \"../../utils/hashObject\";\nimport { Aggregator, createAggregator } from \"../Aggregators\";\nimport { getInitialHeader, mergeHeaders } from \"../headerUtils\";\nimport { emptyGroup, extractAggregateResult } from \"./emptyGroup\";\n\ninterface GroupByResponse {\n  result: GroupByResult;\n  headers: CosmosHeaders;\n}\n\ninterface GroupByResult {\n  groupByItems: any[];\n  payload: any;\n}\n\n/** @hidden */\nexport class GroupByValueEndpointComponent implements ExecutionContext {\n  private readonly aggregators: Map<string, Aggregator> = new Map();\n  private readonly aggregateResultArray: any[] = [];\n  private aggregateType: AggregateType;\n  private completed: boolean = false;\n\n  constructor(private executionContext: ExecutionContext, private queryInfo: QueryInfo) {\n    // VALUE queries will only every have a single grouping\n    this.aggregateType = this.queryInfo.aggregates[0];\n  }\n\n  public async nextItem(): Promise<Response<any>> {\n    // Start returning results if we have processed a full results set\n    if (this.aggregateResultArray.length > 0) {\n      return { result: this.aggregateResultArray.pop(), headers: getInitialHeader() };\n    }\n\n    if (this.completed) {\n      return { result: undefined, headers: getInitialHeader() };\n    }\n\n    const aggregateHeaders = getInitialHeader();\n\n    while (this.executionContext.hasMoreResults()) {\n      // Grab the next result\n      const { result, headers } = (await this.executionContext.nextItem()) as GroupByResponse;\n      mergeHeaders(aggregateHeaders, headers);\n\n      // If it exists, process it via aggregators\n      if (result) {\n        let grouping: string = emptyGroup;\n        let payload: any = result;\n        if (result.groupByItems) {\n          // If the query contains a GROUP BY clause, it will have a payload property and groupByItems\n          payload = result.payload;\n          grouping = await hashObject(result.groupByItems);\n        }\n\n        const aggregator = this.aggregators.get(grouping);\n        if (!aggregator) {\n          // This is the first time we have seen a grouping so create a new aggregator\n          this.aggregators.set(grouping, createAggregator(this.aggregateType));\n        }\n\n        if (this.aggregateType) {\n          const aggregateResult = extractAggregateResult(payload[0]);\n          this.aggregators.get(grouping).aggregate(aggregateResult);\n        } else {\n          // Queries with no aggregates pass the payload directly to the aggregator\n          // Example: SELECT VALUE c.team FROM c GROUP BY c.team\n          this.aggregators.get(grouping).aggregate(payload);\n        }\n      }\n    }\n\n    // It no results are left in the underling execution context, convert our aggregate results to an array\n    for (const aggregator of this.aggregators.values()) {\n      this.aggregateResultArray.push(aggregator.getResult());\n    }\n    this.completed = true;\n    return { result: this.aggregateResultArray.pop(), headers: aggregateHeaders };\n  }\n\n  public hasMoreResults() {\n    return this.executionContext.hasMoreResults() || this.aggregateResultArray.length > 0;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}