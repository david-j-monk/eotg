{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { OffsetLimitEndpointComponent } from \"./EndpointComponent/OffsetLimitEndpointComponent\";\nimport { OrderByEndpointComponent } from \"./EndpointComponent/OrderByEndpointComponent\";\nimport { OrderedDistinctEndpointComponent } from \"./EndpointComponent/OrderedDistinctEndpointComponent\";\nimport { UnorderedDistinctEndpointComponent } from \"./EndpointComponent/UnorderedDistinctEndpointComponent\";\nimport { GroupByEndpointComponent } from \"./EndpointComponent/GroupByEndpointComponent\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { OrderByQueryExecutionContext } from \"./orderByQueryExecutionContext\";\nimport { ParallelQueryExecutionContext } from \"./parallelQueryExecutionContext\";\nimport { GroupByValueEndpointComponent } from \"./EndpointComponent/GroupByValueEndpointComponent\";\n/** @hidden */\n\nexport class PipelinedQueryExecutionContext {\n  constructor(clientContext, collectionLink, query, // TODO: any query\n  options, partitionedQueryExecutionInfo) {\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n    this.endpoint = null;\n    this.pageSize = options[\"maxItemCount\"];\n\n    if (this.pageSize === undefined) {\n      this.pageSize = PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE;\n    } // Pick between parallel vs order by execution context\n\n\n    const sortOrders = partitionedQueryExecutionInfo.queryInfo.orderBy;\n\n    if (Array.isArray(sortOrders) && sortOrders.length > 0) {\n      // Need to wrap orderby execution context in endpoint component, since the data is nested as a \\\n      //      \"payload\" property.\n      this.endpoint = new OrderByEndpointComponent(new OrderByQueryExecutionContext(this.clientContext, this.collectionLink, this.query, this.options, this.partitionedQueryExecutionInfo));\n    } else {\n      this.endpoint = new ParallelQueryExecutionContext(this.clientContext, this.collectionLink, this.query, this.options, this.partitionedQueryExecutionInfo);\n    }\n\n    if (Object.keys(partitionedQueryExecutionInfo.queryInfo.groupByAliasToAggregateType).length > 0 || partitionedQueryExecutionInfo.queryInfo.aggregates.length > 0 || partitionedQueryExecutionInfo.queryInfo.groupByExpressions.length > 0) {\n      if (partitionedQueryExecutionInfo.queryInfo.hasSelectValue) {\n        this.endpoint = new GroupByValueEndpointComponent(this.endpoint, partitionedQueryExecutionInfo.queryInfo);\n      } else {\n        this.endpoint = new GroupByEndpointComponent(this.endpoint, partitionedQueryExecutionInfo.queryInfo);\n      }\n    } // If top then add that to the pipeline. TOP N is effectively OFFSET 0 LIMIT N\n\n\n    const top = partitionedQueryExecutionInfo.queryInfo.top;\n\n    if (typeof top === \"number\") {\n      this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, 0, top);\n    } // If offset+limit then add that to the pipeline\n\n\n    const limit = partitionedQueryExecutionInfo.queryInfo.limit;\n    const offset = partitionedQueryExecutionInfo.queryInfo.offset;\n\n    if (typeof limit === \"number\" && typeof offset === \"number\") {\n      this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, offset, limit);\n    } // If distinct then add that to the pipeline\n\n\n    const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n\n    if (distinctType === \"Ordered\") {\n      this.endpoint = new OrderedDistinctEndpointComponent(this.endpoint);\n    }\n\n    if (distinctType === \"Unordered\") {\n      this.endpoint = new UnorderedDistinctEndpointComponent(this.endpoint);\n    }\n  }\n\n  nextItem() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.endpoint.nextItem();\n    });\n  } // Removed callback here beacuse it wouldn't have ever worked...\n\n\n  hasMoreResults() {\n    return this.endpoint.hasMoreResults();\n  }\n\n  fetchMore() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // if the wrapped endpoint has different implementation for fetchMore use that\n      // otherwise use the default implementation\n      if (typeof this.endpoint.fetchMore === \"function\") {\n        return this.endpoint.fetchMore();\n      } else {\n        this.fetchBuffer = [];\n        this.fetchMoreRespHeaders = getInitialHeader();\n        return this._fetchMoreImplementation();\n      }\n    });\n  }\n\n  _fetchMoreImplementation() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          result: item,\n          headers\n        } = yield this.endpoint.nextItem();\n        mergeHeaders(this.fetchMoreRespHeaders, headers);\n\n        if (item === undefined) {\n          // no more results\n          if (this.fetchBuffer.length === 0) {\n            return {\n              result: undefined,\n              headers: this.fetchMoreRespHeaders\n            };\n          } else {\n            // Just give what we have\n            const temp = this.fetchBuffer;\n            this.fetchBuffer = [];\n            return {\n              result: temp,\n              headers: this.fetchMoreRespHeaders\n            };\n          }\n        } else {\n          // append the result\n          this.fetchBuffer.push(item);\n\n          if (this.fetchBuffer.length >= this.pageSize) {\n            // fetched enough results\n            const temp = this.fetchBuffer.slice(0, this.pageSize);\n            this.fetchBuffer = this.fetchBuffer.splice(this.pageSize);\n            return {\n              result: temp,\n              headers: this.fetchMoreRespHeaders\n            };\n          } else {\n            // recursively fetch more\n            // TODO: is recursion a good idea?\n            return this._fetchMoreImplementation();\n          }\n        }\n      } catch (err) {\n        mergeHeaders(this.fetchMoreRespHeaders, err.headers);\n        err.headers = this.fetchMoreRespHeaders;\n\n        if (err) {\n          throw err;\n        }\n      }\n    });\n  }\n\n}\nPipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE = 10;","map":{"version":3,"sources":["../../src/queryExecutionContext/pipelinedQueryExecutionContext.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ClientContext } from \"../ClientContext\";\nimport { Response, FeedOptions } from \"../request\";\nimport { PartitionedQueryExecutionInfo } from \"../request/ErrorResponse\";\nimport { CosmosHeaders } from \"./CosmosHeaders\";\nimport { OffsetLimitEndpointComponent } from \"./EndpointComponent/OffsetLimitEndpointComponent\";\nimport { OrderByEndpointComponent } from \"./EndpointComponent/OrderByEndpointComponent\";\nimport { OrderedDistinctEndpointComponent } from \"./EndpointComponent/OrderedDistinctEndpointComponent\";\nimport { UnorderedDistinctEndpointComponent } from \"./EndpointComponent/UnorderedDistinctEndpointComponent\";\nimport { GroupByEndpointComponent } from \"./EndpointComponent/GroupByEndpointComponent\";\nimport { ExecutionContext } from \"./ExecutionContext\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { OrderByQueryExecutionContext } from \"./orderByQueryExecutionContext\";\nimport { ParallelQueryExecutionContext } from \"./parallelQueryExecutionContext\";\nimport { GroupByValueEndpointComponent } from \"./EndpointComponent/GroupByValueEndpointComponent\";\n\n/** @hidden */\nexport class PipelinedQueryExecutionContext implements ExecutionContext {\n  private fetchBuffer: any[];\n  private fetchMoreRespHeaders: CosmosHeaders;\n  private endpoint: ExecutionContext;\n  private pageSize: number;\n  private static DEFAULT_PAGE_SIZE = 10;\n  constructor(\n    private clientContext: ClientContext,\n    private collectionLink: string,\n    private query: any, // TODO: any query\n    private options: FeedOptions,\n    private partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo\n  ) {\n    this.endpoint = null;\n    this.pageSize = options[\"maxItemCount\"];\n    if (this.pageSize === undefined) {\n      this.pageSize = PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE;\n    }\n\n    // Pick between parallel vs order by execution context\n    const sortOrders = partitionedQueryExecutionInfo.queryInfo.orderBy;\n    if (Array.isArray(sortOrders) && sortOrders.length > 0) {\n      // Need to wrap orderby execution context in endpoint component, since the data is nested as a \\\n      //      \"payload\" property.\n      this.endpoint = new OrderByEndpointComponent(\n        new OrderByQueryExecutionContext(\n          this.clientContext,\n          this.collectionLink,\n          this.query,\n          this.options,\n          this.partitionedQueryExecutionInfo\n        )\n      );\n    } else {\n      this.endpoint = new ParallelQueryExecutionContext(\n        this.clientContext,\n        this.collectionLink,\n        this.query,\n        this.options,\n        this.partitionedQueryExecutionInfo\n      );\n    }\n    if (\n      Object.keys(partitionedQueryExecutionInfo.queryInfo.groupByAliasToAggregateType).length > 0 ||\n      partitionedQueryExecutionInfo.queryInfo.aggregates.length > 0 ||\n      partitionedQueryExecutionInfo.queryInfo.groupByExpressions.length > 0\n    ) {\n      if (partitionedQueryExecutionInfo.queryInfo.hasSelectValue) {\n        this.endpoint = new GroupByValueEndpointComponent(\n          this.endpoint,\n          partitionedQueryExecutionInfo.queryInfo\n        );\n      } else {\n        this.endpoint = new GroupByEndpointComponent(\n          this.endpoint,\n          partitionedQueryExecutionInfo.queryInfo\n        );\n      }\n    }\n    // If top then add that to the pipeline. TOP N is effectively OFFSET 0 LIMIT N\n    const top = partitionedQueryExecutionInfo.queryInfo.top;\n    if (typeof top === \"number\") {\n      this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, 0, top);\n    }\n\n    // If offset+limit then add that to the pipeline\n    const limit = partitionedQueryExecutionInfo.queryInfo.limit;\n    const offset = partitionedQueryExecutionInfo.queryInfo.offset;\n    if (typeof limit === \"number\" && typeof offset === \"number\") {\n      this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, offset, limit);\n    }\n\n    // If distinct then add that to the pipeline\n    const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n    if (distinctType === \"Ordered\") {\n      this.endpoint = new OrderedDistinctEndpointComponent(this.endpoint);\n    }\n    if (distinctType === \"Unordered\") {\n      this.endpoint = new UnorderedDistinctEndpointComponent(this.endpoint);\n    }\n  }\n\n  public async nextItem(): Promise<Response<any>> {\n    return this.endpoint.nextItem();\n  }\n\n  // Removed callback here beacuse it wouldn't have ever worked...\n  public hasMoreResults(): boolean {\n    return this.endpoint.hasMoreResults();\n  }\n\n  public async fetchMore(): Promise<Response<any>> {\n    // if the wrapped endpoint has different implementation for fetchMore use that\n    // otherwise use the default implementation\n    if (typeof this.endpoint.fetchMore === \"function\") {\n      return this.endpoint.fetchMore();\n    } else {\n      this.fetchBuffer = [];\n      this.fetchMoreRespHeaders = getInitialHeader();\n      return this._fetchMoreImplementation();\n    }\n  }\n\n  private async _fetchMoreImplementation(): Promise<Response<any>> {\n    try {\n      const { result: item, headers } = await this.endpoint.nextItem();\n      mergeHeaders(this.fetchMoreRespHeaders, headers);\n      if (item === undefined) {\n        // no more results\n        if (this.fetchBuffer.length === 0) {\n          return {\n            result: undefined,\n            headers: this.fetchMoreRespHeaders\n          };\n        } else {\n          // Just give what we have\n          const temp = this.fetchBuffer;\n          this.fetchBuffer = [];\n          return { result: temp, headers: this.fetchMoreRespHeaders };\n        }\n      } else {\n        // append the result\n        this.fetchBuffer.push(item);\n        if (this.fetchBuffer.length >= this.pageSize) {\n          // fetched enough results\n          const temp = this.fetchBuffer.slice(0, this.pageSize);\n          this.fetchBuffer = this.fetchBuffer.splice(this.pageSize);\n          return { result: temp, headers: this.fetchMoreRespHeaders };\n        } else {\n          // recursively fetch more\n          // TODO: is recursion a good idea?\n          return this._fetchMoreImplementation();\n        }\n      }\n    } catch (err) {\n      mergeHeaders(this.fetchMoreRespHeaders, err.headers);\n      err.headers = this.fetchMoreRespHeaders;\n      if (err) {\n        throw err;\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}