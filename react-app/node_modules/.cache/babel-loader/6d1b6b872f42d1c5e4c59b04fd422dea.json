{"ast":null,"code":"import { __awaiter } from \"tslib\"; // Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport AbortController from \"node-abort-controller\";\nimport fetch from \"node-fetch\";\nimport { trimSlashes } from \"../common\";\nimport { Constants } from \"../common/constants\";\nimport { logger } from \"../common/logger\";\nimport { executePlugins, PluginOn } from \"../plugins/Plugin\";\nimport * as RetryUtility from \"../retry/retryUtility\";\nimport { defaultHttpAgent, defaultHttpsAgent } from \"./defaultAgent\";\nimport { bodyFromData } from \"./request\";\nimport { TimeoutError } from \"./TimeoutError\";\n/** @hidden */\n\nconst log = logger(\"RequestHandler\");\n\nfunction executeRequest(requestContext) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return executePlugins(requestContext, httpRequest, PluginOn.request);\n  });\n}\n/**\n * @ignore\n * @param requestContext\n */\n\n\nfunction httpRequest(requestContext) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const controller = new AbortController();\n    const signal = controller.signal; // Wrap users passed abort events and call our own internal abort()\n\n    const userSignal = requestContext.options && requestContext.options.abortSignal;\n\n    if (userSignal) {\n      if (userSignal.aborted) {\n        controller.abort();\n      } else {\n        userSignal.addEventListener(\"abort\", () => {\n          controller.abort();\n        });\n      }\n    }\n\n    const timeout = setTimeout(() => {\n      controller.abort();\n    }, requestContext.connectionPolicy.requestTimeout);\n    let response;\n\n    if (requestContext.body) {\n      requestContext.body = bodyFromData(requestContext.body);\n    }\n\n    try {\n      response = yield fetch(trimSlashes(requestContext.endpoint) + requestContext.path, {\n        method: requestContext.method,\n        headers: requestContext.headers,\n        agent: parsedUrl => {\n          if (requestContext.requestAgent) {\n            return requestContext.requestAgent;\n          }\n\n          return parsedUrl.protocol === \"http\" ? defaultHttpAgent : defaultHttpsAgent;\n        },\n        signal,\n        body: requestContext.body\n      });\n    } catch (error) {\n      if (error.name === \"AbortError\") {\n        // If the user passed signal caused the abort, cancel the timeout and rethrow the error\n        if (userSignal && userSignal.aborted === true) {\n          clearTimeout(timeout);\n          throw error;\n        } // If the user didn't cancel, it must be an abort we called due to timeout\n\n\n        throw new TimeoutError();\n      }\n\n      throw error;\n    }\n\n    clearTimeout(timeout);\n    const result = response.status === 204 || response.status === 304 ? null : yield response.json();\n    const headers = {};\n    response.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n    const substatus = headers[Constants.HttpHeaders.SubStatus] ? parseInt(headers[Constants.HttpHeaders.SubStatus], 10) : undefined;\n\n    if (response.status >= 400) {\n      const errorResponse = new Error(result.message);\n      log.warn(response.status + \" \" + requestContext.endpoint + \" \" + requestContext.path + \" \" + result.message);\n      errorResponse.code = response.status;\n      errorResponse.body = result;\n      errorResponse.headers = headers;\n\n      if (Constants.HttpHeaders.ActivityId in headers) {\n        errorResponse.activityId = headers[Constants.HttpHeaders.ActivityId];\n      }\n\n      if (Constants.HttpHeaders.SubStatus in headers) {\n        errorResponse.substatus = substatus;\n      }\n\n      if (Constants.HttpHeaders.RetryAfterInMs in headers) {\n        errorResponse.retryAfterInMs = parseInt(headers[Constants.HttpHeaders.RetryAfterInMs], 10);\n        Object.defineProperty(errorResponse, \"retryAfterInMilliseconds\", {\n          get: () => {\n            return errorResponse.retryAfterInMs;\n          }\n        });\n      }\n\n      throw errorResponse;\n    }\n\n    return {\n      headers,\n      result,\n      code: response.status,\n      substatus\n    };\n  });\n}\n/**\n * @ignore\n * @param requestContext\n */\n\n\nexport function request(requestContext) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (requestContext.body) {\n      requestContext.body = bodyFromData(requestContext.body);\n\n      if (!requestContext.body) {\n        throw new Error(\"parameter data must be a javascript object, string, or Buffer\");\n      }\n    }\n\n    return RetryUtility.execute({\n      requestContext,\n      executeRequest\n    });\n  });\n}","map":{"version":3,"sources":["../../src/request/RequestHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport AbortController from \"node-abort-controller\";\nimport fetch, { RequestInit, Response } from \"node-fetch\";\nimport { trimSlashes } from \"../common\";\nimport { Constants } from \"../common/constants\";\nimport { logger } from \"../common/logger\";\nimport { executePlugins, PluginOn } from \"../plugins/Plugin\";\nimport * as RetryUtility from \"../retry/retryUtility\";\nimport { defaultHttpAgent, defaultHttpsAgent } from \"./defaultAgent\";\nimport { ErrorResponse } from \"./ErrorResponse\";\nimport { bodyFromData } from \"./request\";\nimport { RequestContext } from \"./RequestContext\";\nimport { Response as CosmosResponse } from \"./Response\";\nimport { TimeoutError } from \"./TimeoutError\";\n\n/** @hidden */\nconst log = logger(\"RequestHandler\");\n\nasync function executeRequest(requestContext: RequestContext) {\n  return executePlugins(requestContext, httpRequest, PluginOn.request);\n}\n\n/**\n * @ignore\n * @param requestContext\n */\nasync function httpRequest(requestContext: RequestContext) {\n  const controller = new AbortController();\n  const signal = controller.signal;\n\n  // Wrap users passed abort events and call our own internal abort()\n  const userSignal = requestContext.options && requestContext.options.abortSignal;\n  if (userSignal) {\n    if (userSignal.aborted) {\n      controller.abort();\n    } else {\n      userSignal.addEventListener(\"abort\", () => {\n        controller.abort();\n      });\n    }\n  }\n\n  const timeout = setTimeout(() => {\n    controller.abort();\n  }, requestContext.connectionPolicy.requestTimeout);\n\n  let response: Response;\n\n  if (requestContext.body) {\n    requestContext.body = bodyFromData(requestContext.body);\n  }\n\n  try {\n    response = await fetch(trimSlashes(requestContext.endpoint) + requestContext.path, {\n      method: requestContext.method,\n      headers: requestContext.headers as any,\n      agent: (parsedUrl: URL) => {\n        if (requestContext.requestAgent) {\n          return requestContext.requestAgent;\n        }\n        return parsedUrl.protocol === \"http\" ? defaultHttpAgent : defaultHttpsAgent;\n      },\n      signal,\n      body: requestContext.body\n    } as RequestInit);\n  } catch (error) {\n    if (error.name === \"AbortError\") {\n      // If the user passed signal caused the abort, cancel the timeout and rethrow the error\n      if (userSignal && userSignal.aborted === true) {\n        clearTimeout(timeout);\n        throw error;\n      }\n      // If the user didn't cancel, it must be an abort we called due to timeout\n      throw new TimeoutError();\n    }\n    throw error;\n  }\n\n  clearTimeout(timeout);\n\n  const result = response.status === 204 || response.status === 304 ? null : await response.json();\n  const headers = {} as any;\n  response.headers.forEach((value: string, key: string) => {\n    headers[key] = value;\n  });\n\n  const substatus = headers[Constants.HttpHeaders.SubStatus]\n    ? parseInt(headers[Constants.HttpHeaders.SubStatus], 10)\n    : undefined;\n\n  if (response.status >= 400) {\n    const errorResponse: ErrorResponse = new Error(result.message);\n\n    log.warn(\n      response.status +\n        \" \" +\n        requestContext.endpoint +\n        \" \" +\n        requestContext.path +\n        \" \" +\n        result.message\n    );\n\n    errorResponse.code = response.status;\n    errorResponse.body = result;\n    errorResponse.headers = headers;\n\n    if (Constants.HttpHeaders.ActivityId in headers) {\n      errorResponse.activityId = headers[Constants.HttpHeaders.ActivityId];\n    }\n\n    if (Constants.HttpHeaders.SubStatus in headers) {\n      errorResponse.substatus = substatus;\n    }\n\n    if (Constants.HttpHeaders.RetryAfterInMs in headers) {\n      errorResponse.retryAfterInMs = parseInt(headers[Constants.HttpHeaders.RetryAfterInMs], 10);\n      Object.defineProperty(errorResponse, \"retryAfterInMilliseconds\", {\n        get: () => {\n          return errorResponse.retryAfterInMs;\n        }\n      });\n    }\n\n    throw errorResponse;\n  }\n  return {\n    headers,\n    result,\n    code: response.status,\n    substatus\n  };\n}\n\n/**\n * @ignore\n * @param requestContext\n */\nexport async function request<T>(requestContext: RequestContext): Promise<CosmosResponse<T>> {\n  if (requestContext.body) {\n    requestContext.body = bodyFromData(requestContext.body);\n    if (!requestContext.body) {\n      throw new Error(\"parameter data must be a javascript object, string, or Buffer\");\n    }\n  }\n\n  return RetryUtility.execute({\n    requestContext,\n    executeRequest\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}