{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { Constants, getIdFromLink, getPathFromLink, ResourceType, StatusCodes, SubStatusCodes } from \"../common\";\nimport { DefaultQueryExecutionContext } from \"./defaultQueryExecutionContext\";\nimport { FetchResult, FetchResultType } from \"./FetchResult\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\n/** @hidden */\n\nexport class DocumentProducer {\n  /**\n   * Provides the Target Partition Range Query Execution Context.\n   * @constructor DocumentProducer\n   * @param {ClientContext} clientContext        - The service endpoint to use to create the client.\n   * @param {String} collectionLink                - Represents collection link\n   * @param {SqlQuerySpec | string} query          - A SQL query.\n   * @param {object} targetPartitionKeyRange       - Query Target Partition key Range\n   * @ignore\n   */\n  constructor(clientContext, collectionLink, query, targetPartitionKeyRange, // TODO: any partition key range\n  options) {\n    this.clientContext = clientContext;\n    this.generation = 0;\n\n    this.fetchFunction = options => __awaiter(this, void 0, void 0, function* () {\n      const path = getPathFromLink(this.collectionLink, ResourceType.item);\n      const id = getIdFromLink(this.collectionLink);\n      return this.clientContext.queryFeed({\n        path,\n        resourceType: ResourceType.item,\n        resourceId: id,\n        resultFn: result => result.Documents,\n        query: this.query,\n        options,\n        partitionKeyRangeId: this.targetPartitionKeyRange[\"id\"]\n      });\n    }); // TODO: any options\n\n\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.targetPartitionKeyRange = targetPartitionKeyRange;\n    this.fetchResults = [];\n    this.allFetched = false;\n    this.err = undefined;\n    this.previousContinuationToken = undefined;\n    this.continuationToken = undefined;\n    this.respHeaders = getInitialHeader(); // tslint:disable-next-line:no-shadowed-variable\n\n    this.internalExecutionContext = new DefaultQueryExecutionContext(options, this.fetchFunction);\n  }\n  /**\n   * Synchronously gives the contiguous buffered results (stops at the first non result) if any\n   * @returns {Object}       - buffered current items if any\n   * @ignore\n   */\n\n\n  peekBufferedItems() {\n    const bufferedResults = [];\n\n    for (let i = 0, done = false; i < this.fetchResults.length && !done; i++) {\n      const fetchResult = this.fetchResults[i];\n\n      switch (fetchResult.fetchResultType) {\n        case FetchResultType.Done:\n          done = true;\n          break;\n\n        case FetchResultType.Exception:\n          done = true;\n          break;\n\n        case FetchResultType.Result:\n          bufferedResults.push(fetchResult.feedResponse);\n          break;\n      }\n    }\n\n    return bufferedResults;\n  }\n\n  hasMoreResults() {\n    return this.internalExecutionContext.hasMoreResults() || this.fetchResults.length !== 0;\n  }\n\n  gotSplit() {\n    const fetchResult = this.fetchResults[0];\n\n    if (fetchResult.fetchResultType === FetchResultType.Exception) {\n      if (DocumentProducer._needPartitionKeyRangeCacheRefresh(fetchResult.error)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _getAndResetActiveResponseHeaders() {\n    const ret = this.respHeaders;\n    this.respHeaders = getInitialHeader();\n    return ret;\n  }\n\n  _updateStates(err, allFetched) {\n    // TODO: any Error\n    if (err) {\n      this.err = err;\n      return;\n    }\n\n    if (allFetched) {\n      this.allFetched = true;\n    }\n\n    if (this.internalExecutionContext.continuationToken === this.continuationToken) {\n      // nothing changed\n      return;\n    }\n\n    this.previousContinuationToken = this.continuationToken;\n    this.continuationToken = this.internalExecutionContext.continuationToken;\n  }\n\n  static _needPartitionKeyRangeCacheRefresh(error) {\n    // TODO: error\n    return error.code === StatusCodes.Gone && \"substatus\" in error && error[\"substatus\"] === SubStatusCodes.PartitionKeyRangeGone;\n  }\n  /**\n   * Fetches and bufferes the next page of results and executes the given callback\n   * @memberof DocumentProducer\n   * @instance\n   */\n\n\n  bufferMore() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.err) {\n        throw this.err;\n      }\n\n      try {\n        const {\n          result: resources,\n          headers: headerResponse\n        } = yield this.internalExecutionContext.fetchMore();\n        ++this.generation;\n\n        this._updateStates(undefined, resources === undefined);\n\n        if (resources !== undefined) {\n          // some more results\n          resources.forEach(element => {\n            // TODO: resources any\n            this.fetchResults.push(new FetchResult(element, undefined));\n          });\n        } // need to modify the header response so that the query metrics are per partition\n\n\n        if (headerResponse != null && Constants.HttpHeaders.QueryMetrics in headerResponse) {\n          // \"0\" is the default partition before one is actually assigned.\n          const queryMetrics = headerResponse[Constants.HttpHeaders.QueryMetrics][\"0\"]; // Wraping query metrics in a object where the keys are the partition key range.\n\n          headerResponse[Constants.HttpHeaders.QueryMetrics] = {};\n          headerResponse[Constants.HttpHeaders.QueryMetrics][this.targetPartitionKeyRange.id] = queryMetrics;\n        }\n\n        return {\n          result: resources,\n          headers: headerResponse\n        };\n      } catch (err) {\n        // TODO: any error\n        if (DocumentProducer._needPartitionKeyRangeCacheRefresh(err)) {\n          // Split just happend\n          // Buffer the error so the execution context can still get the feedResponses in the itemBuffer\n          const bufferedError = new FetchResult(undefined, err);\n          this.fetchResults.push(bufferedError); // Putting a dummy result so that the rest of code flows\n\n          return {\n            result: [bufferedError],\n            headers: err.headers\n          };\n        } else {\n          this._updateStates(err, err.resources === undefined);\n\n          throw err;\n        }\n      }\n    });\n  }\n  /**\n   * Synchronously gives the bufferend current item if any\n   * @returns {Object}       - buffered current item if any\n   * @ignore\n   */\n\n\n  getTargetParitionKeyRange() {\n    return this.targetPartitionKeyRange;\n  }\n  /**\n   * Execute a provided function on the next element in the DocumentProducer.\n   * @memberof DocumentProducer\n   * @instance\n   * @param {callback} callback - Function to execute for each element. the function \\\n   * takes two parameters error, element.\n   */\n\n\n  nextItem() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.err) {\n        this._updateStates(this.err, undefined);\n\n        throw this.err;\n      }\n\n      try {\n        const {\n          result,\n          headers\n        } = yield this.current();\n        const fetchResult = this.fetchResults.shift();\n\n        this._updateStates(undefined, result === undefined);\n\n        if (fetchResult.feedResponse !== result) {\n          throw new Error(`Expected ${fetchResult.feedResponse} to equal ${result}`);\n        }\n\n        switch (fetchResult.fetchResultType) {\n          case FetchResultType.Done:\n            return {\n              result: undefined,\n              headers\n            };\n\n          case FetchResultType.Exception:\n            fetchResult.error.headers = headers;\n            throw fetchResult.error;\n\n          case FetchResultType.Result:\n            return {\n              result: fetchResult.feedResponse,\n              headers\n            };\n        }\n      } catch (err) {\n        this._updateStates(err, err.item === undefined);\n\n        throw err;\n      }\n    });\n  }\n  /**\n   * Retrieve the current element on the DocumentProducer.\n   * @memberof DocumentProducer\n   * @instance\n   * @param {callback} callback - Function to execute for the current element. \\\n   * the function takes two parameters error, element.\n   */\n\n\n  current() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // If something is buffered just give that\n      if (this.fetchResults.length > 0) {\n        const fetchResult = this.fetchResults[0]; // Need to unwrap fetch results\n\n        switch (fetchResult.fetchResultType) {\n          case FetchResultType.Done:\n            return {\n              result: undefined,\n              headers: this._getAndResetActiveResponseHeaders()\n            };\n\n          case FetchResultType.Exception:\n            fetchResult.error.headers = this._getAndResetActiveResponseHeaders();\n            throw fetchResult.error;\n\n          case FetchResultType.Result:\n            return {\n              result: fetchResult.feedResponse,\n              headers: this._getAndResetActiveResponseHeaders()\n            };\n        }\n      } // If there isn't anymore items left to fetch then let the user know.\n\n\n      if (this.allFetched) {\n        return {\n          result: undefined,\n          headers: this._getAndResetActiveResponseHeaders()\n        };\n      } // If there are no more bufferd items and there are still items to be fetched then buffer more\n\n\n      const {\n        result,\n        headers\n      } = yield this.bufferMore();\n      mergeHeaders(this.respHeaders, headers);\n\n      if (result === undefined) {\n        return {\n          result: undefined,\n          headers: this.respHeaders\n        };\n      }\n\n      return this.current();\n    });\n  }\n\n}","map":{"version":3,"sources":["../../src/queryExecutionContext/documentProducer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ClientContext } from \"../ClientContext\";\nimport {\n  Constants,\n  getIdFromLink,\n  getPathFromLink,\n  ResourceType,\n  StatusCodes,\n  SubStatusCodes\n} from \"../common\";\nimport { FeedOptions } from \"../request\";\nimport { Response } from \"../request\";\nimport { DefaultQueryExecutionContext } from \"./defaultQueryExecutionContext\";\nimport { FetchResult, FetchResultType } from \"./FetchResult\";\nimport { CosmosHeaders, getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { FetchFunctionCallback, SqlQuerySpec } from \"./index\";\n\n/** @hidden */\nexport class DocumentProducer {\n  private collectionLink: string;\n  private query: string | SqlQuerySpec;\n  public targetPartitionKeyRange: any; // TODO: any partitionkeyrange\n  public fetchResults: FetchResult[];\n  public allFetched: boolean;\n  private err: Error;\n  public previousContinuationToken: string;\n  public continuationToken: string;\n  public generation: number = 0;\n  private respHeaders: CosmosHeaders;\n  private internalExecutionContext: DefaultQueryExecutionContext;\n\n  /**\n   * Provides the Target Partition Range Query Execution Context.\n   * @constructor DocumentProducer\n   * @param {ClientContext} clientContext        - The service endpoint to use to create the client.\n   * @param {String} collectionLink                - Represents collection link\n   * @param {SqlQuerySpec | string} query          - A SQL query.\n   * @param {object} targetPartitionKeyRange       - Query Target Partition key Range\n   * @ignore\n   */\n  constructor(\n    private clientContext: ClientContext,\n    collectionLink: string,\n    query: SqlQuerySpec,\n    targetPartitionKeyRange: any, // TODO: any partition key range\n    options: FeedOptions\n  ) {\n    // TODO: any options\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.targetPartitionKeyRange = targetPartitionKeyRange;\n    this.fetchResults = [];\n\n    this.allFetched = false;\n    this.err = undefined;\n\n    this.previousContinuationToken = undefined;\n    this.continuationToken = undefined;\n    this.respHeaders = getInitialHeader();\n\n    // tslint:disable-next-line:no-shadowed-variable\n    this.internalExecutionContext = new DefaultQueryExecutionContext(options, this.fetchFunction);\n  }\n  /**\n   * Synchronously gives the contiguous buffered results (stops at the first non result) if any\n   * @returns {Object}       - buffered current items if any\n   * @ignore\n   */\n  public peekBufferedItems() {\n    const bufferedResults = [];\n    for (let i = 0, done = false; i < this.fetchResults.length && !done; i++) {\n      const fetchResult = this.fetchResults[i];\n      switch (fetchResult.fetchResultType) {\n        case FetchResultType.Done:\n          done = true;\n          break;\n        case FetchResultType.Exception:\n          done = true;\n          break;\n        case FetchResultType.Result:\n          bufferedResults.push(fetchResult.feedResponse);\n          break;\n      }\n    }\n    return bufferedResults;\n  }\n\n  public fetchFunction: FetchFunctionCallback = async (options: any) => {\n    const path = getPathFromLink(this.collectionLink, ResourceType.item);\n    const id = getIdFromLink(this.collectionLink);\n\n    return this.clientContext.queryFeed({\n      path,\n      resourceType: ResourceType.item,\n      resourceId: id,\n      resultFn: (result: any) => result.Documents,\n      query: this.query,\n      options,\n      partitionKeyRangeId: this.targetPartitionKeyRange[\"id\"]\n    });\n  };\n\n  public hasMoreResults() {\n    return this.internalExecutionContext.hasMoreResults() || this.fetchResults.length !== 0;\n  }\n\n  public gotSplit() {\n    const fetchResult = this.fetchResults[0];\n    if (fetchResult.fetchResultType === FetchResultType.Exception) {\n      if (DocumentProducer._needPartitionKeyRangeCacheRefresh(fetchResult.error)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _getAndResetActiveResponseHeaders() {\n    const ret = this.respHeaders;\n    this.respHeaders = getInitialHeader();\n    return ret;\n  }\n\n  private _updateStates(err: any, allFetched: boolean) {\n    // TODO: any Error\n    if (err) {\n      this.err = err;\n      return;\n    }\n    if (allFetched) {\n      this.allFetched = true;\n    }\n    if (this.internalExecutionContext.continuationToken === this.continuationToken) {\n      // nothing changed\n      return;\n    }\n    this.previousContinuationToken = this.continuationToken;\n    this.continuationToken = this.internalExecutionContext.continuationToken;\n  }\n\n  private static _needPartitionKeyRangeCacheRefresh(error: any) {\n    // TODO: error\n    return (\n      error.code === StatusCodes.Gone &&\n      \"substatus\" in error &&\n      error[\"substatus\"] === SubStatusCodes.PartitionKeyRangeGone\n    );\n  }\n\n  /**\n   * Fetches and bufferes the next page of results and executes the given callback\n   * @memberof DocumentProducer\n   * @instance\n   */\n  public async bufferMore(): Promise<Response<any>> {\n    if (this.err) {\n      throw this.err;\n    }\n\n    try {\n      const {\n        result: resources,\n        headers: headerResponse\n      } = await this.internalExecutionContext.fetchMore();\n      ++this.generation;\n      this._updateStates(undefined, resources === undefined);\n      if (resources !== undefined) {\n        // some more results\n        resources.forEach((element: any) => {\n          // TODO: resources any\n          this.fetchResults.push(new FetchResult(element, undefined));\n        });\n      }\n\n      // need to modify the header response so that the query metrics are per partition\n      if (headerResponse != null && Constants.HttpHeaders.QueryMetrics in headerResponse) {\n        // \"0\" is the default partition before one is actually assigned.\n        const queryMetrics = headerResponse[Constants.HttpHeaders.QueryMetrics][\"0\"];\n\n        // Wraping query metrics in a object where the keys are the partition key range.\n        headerResponse[Constants.HttpHeaders.QueryMetrics] = {};\n        headerResponse[Constants.HttpHeaders.QueryMetrics][\n          this.targetPartitionKeyRange.id\n        ] = queryMetrics;\n      }\n\n      return { result: resources, headers: headerResponse };\n    } catch (err) {\n      // TODO: any error\n      if (DocumentProducer._needPartitionKeyRangeCacheRefresh(err)) {\n        // Split just happend\n        // Buffer the error so the execution context can still get the feedResponses in the itemBuffer\n        const bufferedError = new FetchResult(undefined, err);\n        this.fetchResults.push(bufferedError);\n        // Putting a dummy result so that the rest of code flows\n        return { result: [bufferedError], headers: err.headers };\n      } else {\n        this._updateStates(err, err.resources === undefined);\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Synchronously gives the bufferend current item if any\n   * @returns {Object}       - buffered current item if any\n   * @ignore\n   */\n  public getTargetParitionKeyRange() {\n    return this.targetPartitionKeyRange;\n  }\n\n  /**\n   * Execute a provided function on the next element in the DocumentProducer.\n   * @memberof DocumentProducer\n   * @instance\n   * @param {callback} callback - Function to execute for each element. the function \\\n   * takes two parameters error, element.\n   */\n  public async nextItem(): Promise<Response<any>> {\n    if (this.err) {\n      this._updateStates(this.err, undefined);\n      throw this.err;\n    }\n\n    try {\n      const { result, headers } = await this.current();\n\n      const fetchResult = this.fetchResults.shift();\n      this._updateStates(undefined, result === undefined);\n      if (fetchResult.feedResponse !== result) {\n        throw new Error(`Expected ${fetchResult.feedResponse} to equal ${result}`);\n      }\n      switch (fetchResult.fetchResultType) {\n        case FetchResultType.Done:\n          return { result: undefined, headers };\n        case FetchResultType.Exception:\n          fetchResult.error.headers = headers;\n          throw fetchResult.error;\n        case FetchResultType.Result:\n          return { result: fetchResult.feedResponse, headers };\n      }\n    } catch (err) {\n      this._updateStates(err, err.item === undefined);\n      throw err;\n    }\n  }\n\n  /**\n   * Retrieve the current element on the DocumentProducer.\n   * @memberof DocumentProducer\n   * @instance\n   * @param {callback} callback - Function to execute for the current element. \\\n   * the function takes two parameters error, element.\n   */\n  public async current(): Promise<Response<any>> {\n    // If something is buffered just give that\n    if (this.fetchResults.length > 0) {\n      const fetchResult = this.fetchResults[0];\n      // Need to unwrap fetch results\n      switch (fetchResult.fetchResultType) {\n        case FetchResultType.Done:\n          return {\n            result: undefined,\n            headers: this._getAndResetActiveResponseHeaders()\n          };\n        case FetchResultType.Exception:\n          fetchResult.error.headers = this._getAndResetActiveResponseHeaders();\n          throw fetchResult.error;\n        case FetchResultType.Result:\n          return {\n            result: fetchResult.feedResponse,\n            headers: this._getAndResetActiveResponseHeaders()\n          };\n      }\n    }\n\n    // If there isn't anymore items left to fetch then let the user know.\n    if (this.allFetched) {\n      return {\n        result: undefined,\n        headers: this._getAndResetActiveResponseHeaders()\n      };\n    }\n\n    // If there are no more bufferd items and there are still items to be fetched then buffer more\n    const { result, headers } = await this.bufferMore();\n    mergeHeaders(this.respHeaders, headers);\n    if (result === undefined) {\n      return { result: undefined, headers: this.respHeaders };\n    }\n    return this.current();\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}