{"ast":null,"code":"import { __awaiter } from \"tslib\"; // Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { v4 as uuid } from \"uuid\";\nimport { Constants, HTTPMethod, OperationType, ResourceType } from \"./common/constants\";\nimport { getIdFromLink, getPathFromLink, parseLink } from \"./common/helper\";\nimport { logger } from \"./common/logger\";\nimport { StatusCodes, SubStatusCodes } from \"./common/statusCodes\";\nimport { ConsistencyLevel, DatabaseAccount } from \"./documents\";\nimport { executePlugins, PluginOn } from \"./plugins/Plugin\";\nimport { QueryIterator } from \"./queryIterator\";\nimport { getHeaders } from \"./request/request\";\nimport { request as executeRequest } from \"./request/RequestHandler\";\nimport { SessionContainer } from \"./session/sessionContainer\";\n/** @hidden */\n\nconst log = logger(\"ClientContext\");\nconst QueryJsonContentType = \"application/query+json\";\n/**\n * @hidden\n * @ignore\n */\n\nexport class ClientContext {\n  constructor(cosmosClientOptions, globalEndpointManager) {\n    this.cosmosClientOptions = cosmosClientOptions;\n    this.globalEndpointManager = globalEndpointManager;\n    this.connectionPolicy = cosmosClientOptions.connectionPolicy;\n    this.sessionContainer = new SessionContainer();\n    this.partitionKeyDefinitionCache = {};\n  }\n  /** @ignore */\n\n\n  read({\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const request = {\n          globalEndpointManager: this.globalEndpointManager,\n          requestAgent: this.cosmosClientOptions.agent,\n          connectionPolicy: this.connectionPolicy,\n          method: HTTPMethod.get,\n          path,\n          operationType: OperationType.Read,\n          client: this,\n          resourceId,\n          options,\n          resourceType,\n          plugins: this.cosmosClientOptions.plugins,\n          partitionKey\n        };\n        request.headers = yield this.buildHeaders(request);\n        this.applySessionToken(request); // read will use ReadEndpoint since it uses GET operation\n\n        request.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request.resourceType, request.operationType);\n        const response = yield executePlugins(request, executeRequest, PluginOn.operation);\n        this.captureSessionToken(undefined, path, OperationType.Read, response.headers);\n        return response;\n      } catch (err) {\n        this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n        throw err;\n      }\n    });\n  }\n\n  queryFeed({\n    path,\n    resourceType,\n    resourceId,\n    resultFn,\n    query,\n    options,\n    partitionKeyRangeId,\n    partitionKey\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Query operations will use ReadEndpoint even though it uses\n      // GET(for queryFeed) and POST(for regular query operations)\n      const request = {\n        globalEndpointManager: this.globalEndpointManager,\n        requestAgent: this.cosmosClientOptions.agent,\n        connectionPolicy: this.connectionPolicy,\n        method: HTTPMethod.get,\n        path,\n        operationType: OperationType.Query,\n        client: this,\n        partitionKeyRangeId,\n        resourceId,\n        resourceType,\n        options,\n        body: query,\n        plugins: this.cosmosClientOptions.plugins,\n        partitionKey\n      };\n      const requestId = uuid();\n\n      if (query !== undefined) {\n        request.method = HTTPMethod.post;\n      }\n\n      request.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request.resourceType, request.operationType);\n      request.headers = yield this.buildHeaders(request);\n\n      if (query !== undefined) {\n        request.headers[Constants.HttpHeaders.IsQuery] = \"true\";\n        request.headers[Constants.HttpHeaders.ContentType] = QueryJsonContentType;\n\n        if (typeof query === \"string\") {\n          request.body = {\n            query\n          }; // Converts query text to query object.\n        }\n      }\n\n      this.applySessionToken(request);\n      log.info(\"query \" + requestId + \" started\" + (request.partitionKeyRangeId ? \" pkrid: \" + request.partitionKeyRangeId : \"\"));\n      log.silly(request);\n      const start = Date.now();\n      const response = yield executeRequest(request);\n      log.info(\"query \" + requestId + \" finished - \" + (Date.now() - start) + \"ms\");\n      this.captureSessionToken(undefined, path, OperationType.Query, response.headers);\n      return this.processQueryFeedResponse(response, !!query, resultFn);\n    });\n  }\n\n  getQueryPlan(path, resourceType, resourceId, query, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const request = {\n        globalEndpointManager: this.globalEndpointManager,\n        requestAgent: this.cosmosClientOptions.agent,\n        connectionPolicy: this.connectionPolicy,\n        method: HTTPMethod.post,\n        path,\n        operationType: OperationType.Read,\n        client: this,\n        resourceId,\n        resourceType,\n        options,\n        body: query,\n        plugins: this.cosmosClientOptions.plugins\n      };\n      request.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request.resourceType, request.operationType);\n      request.headers = yield this.buildHeaders(request);\n      request.headers[Constants.HttpHeaders.IsQueryPlan] = \"True\";\n      request.headers[Constants.HttpHeaders.QueryVersion] = \"1.4\";\n      request.headers[Constants.HttpHeaders.SupportedQueryFeatures] = \"NonValueAggregate, Aggregate, Distinct, MultipleOrderBy, OffsetAndLimit, OrderBy, Top, CompositeAggregate, GroupBy, MultipleAggregates\";\n      request.headers[Constants.HttpHeaders.ContentType] = QueryJsonContentType;\n\n      if (typeof query === \"string\") {\n        request.body = {\n          query\n        }; // Converts query text to query object.\n      }\n\n      this.applySessionToken(request);\n      const response = yield executeRequest(request);\n      this.captureSessionToken(undefined, path, OperationType.Query, response.headers);\n      return response;\n    });\n  }\n\n  queryPartitionKeyRanges(collectionLink, query, options) {\n    const path = getPathFromLink(collectionLink, ResourceType.pkranges);\n    const id = getIdFromLink(collectionLink);\n\n    const cb = innerOptions => {\n      return this.queryFeed({\n        path,\n        resourceType: ResourceType.pkranges,\n        resourceId: id,\n        resultFn: result => result.PartitionKeyRanges,\n        query,\n        options: innerOptions\n      });\n    };\n\n    return new QueryIterator(this, query, options, cb);\n  }\n\n  delete({\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const request = {\n          globalEndpointManager: this.globalEndpointManager,\n          requestAgent: this.cosmosClientOptions.agent,\n          connectionPolicy: this.connectionPolicy,\n          method: HTTPMethod.delete,\n          client: this,\n          operationType: OperationType.Delete,\n          path,\n          resourceType,\n          options,\n          resourceId,\n          plugins: this.cosmosClientOptions.plugins,\n          partitionKey\n        };\n        request.headers = yield this.buildHeaders(request);\n        this.applySessionToken(request); // deleteResource will use WriteEndpoint since it uses DELETE operation\n\n        request.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request.resourceType, request.operationType);\n        const response = yield executePlugins(request, executeRequest, PluginOn.operation);\n\n        if (parseLink(path).type !== \"colls\") {\n          this.captureSessionToken(undefined, path, OperationType.Delete, response.headers);\n        } else {\n          this.clearSessionToken(path);\n        }\n\n        return response;\n      } catch (err) {\n        this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n        throw err;\n      }\n    });\n  }\n\n  create({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const request = {\n          globalEndpointManager: this.globalEndpointManager,\n          requestAgent: this.cosmosClientOptions.agent,\n          connectionPolicy: this.connectionPolicy,\n          method: HTTPMethod.post,\n          client: this,\n          operationType: OperationType.Create,\n          path,\n          resourceType,\n          resourceId,\n          body,\n          options,\n          plugins: this.cosmosClientOptions.plugins,\n          partitionKey\n        };\n        request.headers = yield this.buildHeaders(request); // create will use WriteEndpoint since it uses POST operation\n\n        this.applySessionToken(request);\n        request.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request.resourceType, request.operationType);\n        const response = yield executePlugins(request, executeRequest, PluginOn.operation);\n        this.captureSessionToken(undefined, path, OperationType.Create, response.headers);\n        return response;\n      } catch (err) {\n        this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n        throw err;\n      }\n    });\n  }\n\n  processQueryFeedResponse(res, isQuery, resultFn) {\n    if (isQuery) {\n      return {\n        result: resultFn(res.result),\n        headers: res.headers,\n        code: res.code\n      };\n    } else {\n      const newResult = resultFn(res.result).map(body => body);\n      return {\n        result: newResult,\n        headers: res.headers,\n        code: res.code\n      };\n    }\n  }\n\n  applySessionToken(requestContext) {\n    const request = this.getSessionParams(requestContext.path);\n\n    if (requestContext.headers && requestContext.headers[Constants.HttpHeaders.SessionToken]) {\n      return;\n    }\n\n    const sessionConsistency = requestContext.headers[Constants.HttpHeaders.ConsistencyLevel];\n\n    if (!sessionConsistency) {\n      return;\n    }\n\n    if (sessionConsistency !== ConsistencyLevel.Session) {\n      return;\n    }\n\n    if (request.resourceAddress) {\n      const sessionToken = this.sessionContainer.get(request);\n\n      if (sessionToken) {\n        requestContext.headers[Constants.HttpHeaders.SessionToken] = sessionToken;\n      }\n    }\n  }\n\n  replace({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const request = {\n          globalEndpointManager: this.globalEndpointManager,\n          requestAgent: this.cosmosClientOptions.agent,\n          connectionPolicy: this.connectionPolicy,\n          method: HTTPMethod.put,\n          client: this,\n          operationType: OperationType.Replace,\n          path,\n          resourceType,\n          body,\n          resourceId,\n          options,\n          plugins: this.cosmosClientOptions.plugins,\n          partitionKey\n        };\n        request.headers = yield this.buildHeaders(request);\n        this.applySessionToken(request); // replace will use WriteEndpoint since it uses PUT operation\n\n        request.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request.resourceType, request.operationType);\n        const response = yield executePlugins(request, executeRequest, PluginOn.operation);\n        this.captureSessionToken(undefined, path, OperationType.Replace, response.headers);\n        return response;\n      } catch (err) {\n        this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n        throw err;\n      }\n    });\n  }\n\n  upsert({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const request = {\n          globalEndpointManager: this.globalEndpointManager,\n          requestAgent: this.cosmosClientOptions.agent,\n          connectionPolicy: this.connectionPolicy,\n          method: HTTPMethod.post,\n          client: this,\n          operationType: OperationType.Upsert,\n          path,\n          resourceType,\n          body,\n          resourceId,\n          options,\n          plugins: this.cosmosClientOptions.plugins,\n          partitionKey\n        };\n        request.headers = yield this.buildHeaders(request);\n        request.headers[Constants.HttpHeaders.IsUpsert] = true;\n        this.applySessionToken(request); // upsert will use WriteEndpoint since it uses POST operation\n\n        request.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request.resourceType, request.operationType);\n        const response = yield executePlugins(request, executeRequest, PluginOn.operation);\n        this.captureSessionToken(undefined, path, OperationType.Upsert, response.headers);\n        return response;\n      } catch (err) {\n        this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n        throw err;\n      }\n    });\n  }\n\n  execute({\n    sprocLink,\n    params,\n    options = {},\n    partitionKey\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Accept a single parameter or an array of parameters.\n      // Didn't add type annotation for this because we should legacy this behavior\n      if (params !== null && params !== undefined && !Array.isArray(params)) {\n        params = [params];\n      }\n\n      const path = getPathFromLink(sprocLink);\n      const id = getIdFromLink(sprocLink);\n      const request = {\n        globalEndpointManager: this.globalEndpointManager,\n        requestAgent: this.cosmosClientOptions.agent,\n        connectionPolicy: this.connectionPolicy,\n        method: HTTPMethod.post,\n        client: this,\n        operationType: OperationType.Execute,\n        path,\n        resourceType: ResourceType.sproc,\n        options,\n        resourceId: id,\n        body: params,\n        plugins: this.cosmosClientOptions.plugins,\n        partitionKey\n      };\n      request.headers = yield this.buildHeaders(request); // executeStoredProcedure will use WriteEndpoint since it uses POST operation\n\n      request.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request.resourceType, request.operationType);\n      return executePlugins(request, executeRequest, PluginOn.operation);\n    });\n  }\n  /**\n   * Gets the Database account information.\n   * @param {string} [options.urlConnection]   - The endpoint url whose database account needs to be retrieved. \\\n   * If not present, current client's url will be used.\n   */\n\n\n  getDatabaseAccount(options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const endpoint = options.urlConnection || this.cosmosClientOptions.endpoint;\n      const request = {\n        endpoint,\n        globalEndpointManager: this.globalEndpointManager,\n        requestAgent: this.cosmosClientOptions.agent,\n        connectionPolicy: this.connectionPolicy,\n        method: HTTPMethod.get,\n        client: this,\n        operationType: OperationType.Read,\n        path: \"\",\n        resourceType: ResourceType.none,\n        options,\n        plugins: this.cosmosClientOptions.plugins\n      };\n      request.headers = yield this.buildHeaders(request); // await options.beforeOperation({ endpoint, request, headers: requestHeaders });\n\n      const {\n        result,\n        headers\n      } = yield executePlugins(request, executeRequest, PluginOn.operation);\n      const databaseAccount = new DatabaseAccount(result, headers);\n      return {\n        result: databaseAccount,\n        headers\n      };\n    });\n  }\n\n  getWriteEndpoint() {\n    return this.globalEndpointManager.getWriteEndpoint();\n  }\n\n  getReadEndpoint() {\n    return this.globalEndpointManager.getReadEndpoint();\n  }\n\n  bulk({\n    body,\n    path,\n    resourceId,\n    partitionKeyRangeId,\n    options = {}\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const request = {\n          globalEndpointManager: this.globalEndpointManager,\n          requestAgent: this.cosmosClientOptions.agent,\n          connectionPolicy: this.connectionPolicy,\n          method: HTTPMethod.post,\n          client: this,\n          operationType: OperationType.Batch,\n          path,\n          body,\n          resourceType: ResourceType.item,\n          resourceId,\n          plugins: this.cosmosClientOptions.plugins,\n          options\n        };\n        request.headers = yield this.buildHeaders(request);\n        request.headers[Constants.HttpHeaders.IsBatchRequest] = true;\n        request.headers[Constants.HttpHeaders.PartitionKeyRangeID] = partitionKeyRangeId;\n        request.headers[Constants.HttpHeaders.IsBatchAtomic] = false;\n        this.applySessionToken(request);\n        request.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request.resourceType, request.operationType);\n        const response = yield executePlugins(request, executeRequest, PluginOn.operation);\n        this.captureSessionToken(undefined, path, OperationType.Batch, response.headers);\n        return response;\n      } catch (err) {\n        this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n        throw err;\n      }\n    });\n  }\n\n  captureSessionToken(err, path, operationType, resHeaders) {\n    const request = this.getSessionParams(path);\n    request.operationType = operationType;\n\n    if (!err || !this.isMasterResource(request.resourceType) && (err.code === StatusCodes.PreconditionFailed || err.code === StatusCodes.Conflict || err.code === StatusCodes.NotFound && err.substatus !== SubStatusCodes.ReadSessionNotAvailable)) {\n      this.sessionContainer.set(request, resHeaders);\n    }\n  }\n\n  clearSessionToken(path) {\n    const request = this.getSessionParams(path);\n    this.sessionContainer.remove(request);\n  }\n\n  getSessionParams(resourceLink) {\n    const resourceId = null;\n    let resourceAddress = null;\n    const parserOutput = parseLink(resourceLink);\n    resourceAddress = parserOutput.objectBody.self;\n    const resourceType = parserOutput.type;\n    return {\n      resourceId,\n      resourceAddress,\n      resourceType,\n      isNameBased: true\n    };\n  }\n\n  isMasterResource(resourceType) {\n    if (resourceType === Constants.Path.OffersPathSegment || resourceType === Constants.Path.DatabasesPathSegment || resourceType === Constants.Path.UsersPathSegment || resourceType === Constants.Path.PermissionsPathSegment || resourceType === Constants.Path.TopologyPathSegment || resourceType === Constants.Path.DatabaseAccountPathSegment || resourceType === Constants.Path.PartitionKeyRangesPathSegment || resourceType === Constants.Path.CollectionsPathSegment) {\n      return true;\n    }\n\n    return false;\n  }\n\n  buildHeaders(requestContext) {\n    return getHeaders({\n      clientOptions: this.cosmosClientOptions,\n      defaultHeaders: Object.assign(Object.assign({}, this.cosmosClientOptions.defaultHeaders), requestContext.options.initialHeaders),\n      verb: requestContext.method,\n      path: requestContext.path,\n      resourceId: requestContext.resourceId,\n      resourceType: requestContext.resourceType,\n      options: requestContext.options,\n      partitionKeyRangeId: requestContext.partitionKeyRangeId,\n      useMultipleWriteLocations: this.connectionPolicy.useMultipleWriteLocations,\n      partitionKey: requestContext.partitionKey\n    });\n  }\n\n}","map":{"version":3,"sources":["../src/ClientContext.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { v4 as uuid } from \"uuid\";\nimport { PartitionKeyRange } from \"./client/Container/PartitionKeyRange\";\nimport { Resource } from \"./client/Resource\";\nimport { Constants, HTTPMethod, OperationType, ResourceType } from \"./common/constants\";\nimport { getIdFromLink, getPathFromLink, parseLink } from \"./common/helper\";\nimport { logger } from \"./common/logger\";\nimport { StatusCodes, SubStatusCodes } from \"./common/statusCodes\";\nimport { CosmosClientOptions } from \"./CosmosClientOptions\";\nimport { ConnectionPolicy, ConsistencyLevel, DatabaseAccount, PartitionKey } from \"./documents\";\nimport { GlobalEndpointManager } from \"./globalEndpointManager\";\nimport { executePlugins, PluginOn } from \"./plugins/Plugin\";\nimport { FetchFunctionCallback, SqlQuerySpec } from \"./queryExecutionContext\";\nimport { CosmosHeaders } from \"./queryExecutionContext/CosmosHeaders\";\nimport { QueryIterator } from \"./queryIterator\";\nimport { ErrorResponse } from \"./request\";\nimport { FeedOptions, RequestOptions, Response } from \"./request\";\nimport { PartitionedQueryExecutionInfo } from \"./request/ErrorResponse\";\nimport { getHeaders } from \"./request/request\";\nimport { RequestContext } from \"./request/RequestContext\";\nimport { request as executeRequest } from \"./request/RequestHandler\";\nimport { SessionContainer } from \"./session/sessionContainer\";\nimport { SessionContext } from \"./session/SessionContext\";\n\n/** @hidden */\nconst log = logger(\"ClientContext\");\n\nconst QueryJsonContentType = \"application/query+json\";\n\n/**\n * @hidden\n * @ignore\n */\nexport class ClientContext {\n  private readonly sessionContainer: SessionContainer;\n  private connectionPolicy: ConnectionPolicy;\n\n  public partitionKeyDefinitionCache: { [containerUrl: string]: any }; // TODO: ParitionKeyDefinitionCache\n  public constructor(\n    private cosmosClientOptions: CosmosClientOptions,\n    private globalEndpointManager: GlobalEndpointManager\n  ) {\n    this.connectionPolicy = cosmosClientOptions.connectionPolicy;\n    this.sessionContainer = new SessionContainer();\n    this.partitionKeyDefinitionCache = {};\n  }\n  /** @ignore */\n  public async read<T>({\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey\n  }: {\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n  }): Promise<Response<T & Resource>> {\n    try {\n      const request: RequestContext = {\n        globalEndpointManager: this.globalEndpointManager,\n        requestAgent: this.cosmosClientOptions.agent,\n        connectionPolicy: this.connectionPolicy,\n        method: HTTPMethod.get,\n        path,\n        operationType: OperationType.Read,\n        client: this,\n        resourceId,\n        options,\n        resourceType,\n        plugins: this.cosmosClientOptions.plugins,\n        partitionKey\n      };\n\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n\n      // read will use ReadEndpoint since it uses GET operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        request.resourceType,\n        request.operationType\n      );\n      const response = await executePlugins(request, executeRequest, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Read, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async queryFeed<T>({\n    path,\n    resourceType,\n    resourceId,\n    resultFn,\n    query,\n    options,\n    partitionKeyRangeId,\n    partitionKey\n  }: {\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    resultFn: (result: { [key: string]: any }) => any[];\n    query: SqlQuerySpec | string;\n    options: FeedOptions;\n    partitionKeyRangeId?: string;\n    partitionKey?: PartitionKey;\n  }): Promise<Response<T & Resource>> {\n    // Query operations will use ReadEndpoint even though it uses\n    // GET(for queryFeed) and POST(for regular query operations)\n\n    const request: RequestContext = {\n      globalEndpointManager: this.globalEndpointManager,\n      requestAgent: this.cosmosClientOptions.agent,\n      connectionPolicy: this.connectionPolicy,\n      method: HTTPMethod.get,\n      path,\n      operationType: OperationType.Query,\n      client: this,\n      partitionKeyRangeId,\n      resourceId,\n      resourceType,\n      options,\n      body: query,\n      plugins: this.cosmosClientOptions.plugins,\n      partitionKey\n    };\n    const requestId = uuid();\n    if (query !== undefined) {\n      request.method = HTTPMethod.post;\n    }\n    request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n      request.resourceType,\n      request.operationType\n    );\n    request.headers = await this.buildHeaders(request);\n    if (query !== undefined) {\n      request.headers[Constants.HttpHeaders.IsQuery] = \"true\";\n      request.headers[Constants.HttpHeaders.ContentType] = QueryJsonContentType;\n      if (typeof query === \"string\") {\n        request.body = { query }; // Converts query text to query object.\n      }\n    }\n    this.applySessionToken(request);\n    log.info(\n      \"query \" +\n        requestId +\n        \" started\" +\n        (request.partitionKeyRangeId ? \" pkrid: \" + request.partitionKeyRangeId : \"\")\n    );\n    log.silly(request);\n    const start = Date.now();\n    const response = await executeRequest(request);\n    log.info(\"query \" + requestId + \" finished - \" + (Date.now() - start) + \"ms\");\n    this.captureSessionToken(undefined, path, OperationType.Query, response.headers);\n    return this.processQueryFeedResponse(response, !!query, resultFn);\n  }\n\n  public async getQueryPlan(\n    path: string,\n    resourceType: ResourceType,\n    resourceId: string,\n    query: SqlQuerySpec | string,\n    options: FeedOptions = {}\n  ): Promise<Response<PartitionedQueryExecutionInfo>> {\n    const request: RequestContext = {\n      globalEndpointManager: this.globalEndpointManager,\n      requestAgent: this.cosmosClientOptions.agent,\n      connectionPolicy: this.connectionPolicy,\n      method: HTTPMethod.post,\n      path,\n      operationType: OperationType.Read,\n      client: this,\n      resourceId,\n      resourceType,\n      options,\n      body: query,\n      plugins: this.cosmosClientOptions.plugins\n    };\n\n    request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n      request.resourceType,\n      request.operationType\n    );\n    request.headers = await this.buildHeaders(request);\n    request.headers[Constants.HttpHeaders.IsQueryPlan] = \"True\";\n    request.headers[Constants.HttpHeaders.QueryVersion] = \"1.4\";\n    request.headers[Constants.HttpHeaders.SupportedQueryFeatures] =\n      \"NonValueAggregate, Aggregate, Distinct, MultipleOrderBy, OffsetAndLimit, OrderBy, Top, CompositeAggregate, GroupBy, MultipleAggregates\";\n    request.headers[Constants.HttpHeaders.ContentType] = QueryJsonContentType;\n    if (typeof query === \"string\") {\n      request.body = { query }; // Converts query text to query object.\n    }\n\n    this.applySessionToken(request);\n    const response = await executeRequest(request);\n    this.captureSessionToken(undefined, path, OperationType.Query, response.headers);\n    return response as any;\n  }\n\n  public queryPartitionKeyRanges(\n    collectionLink: string,\n    query?: string | SqlQuerySpec,\n    options?: FeedOptions\n  ) {\n    const path = getPathFromLink(collectionLink, ResourceType.pkranges);\n    const id = getIdFromLink(collectionLink);\n    const cb: FetchFunctionCallback = (innerOptions) => {\n      return this.queryFeed({\n        path,\n        resourceType: ResourceType.pkranges,\n        resourceId: id,\n        resultFn: (result) => result.PartitionKeyRanges,\n        query,\n        options: innerOptions\n      });\n    };\n    return new QueryIterator<PartitionKeyRange>(this, query, options, cb);\n  }\n\n  public async delete<T>({\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey\n  }: {\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n  }): Promise<Response<T & Resource>> {\n    try {\n      const request: RequestContext = {\n        globalEndpointManager: this.globalEndpointManager,\n        requestAgent: this.cosmosClientOptions.agent,\n        connectionPolicy: this.connectionPolicy,\n        method: HTTPMethod.delete,\n        client: this,\n        operationType: OperationType.Delete,\n        path,\n        resourceType,\n        options,\n        resourceId,\n        plugins: this.cosmosClientOptions.plugins,\n        partitionKey\n      };\n\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n      // deleteResource will use WriteEndpoint since it uses DELETE operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        request.resourceType,\n        request.operationType\n      );\n      const response = await executePlugins(request, executeRequest, PluginOn.operation);\n      if (parseLink(path).type !== \"colls\") {\n        this.captureSessionToken(undefined, path, OperationType.Delete, response.headers);\n      } else {\n        this.clearSessionToken(path);\n      }\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async create<T, U = T>({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey\n  }: {\n    body: T;\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n  }): Promise<Response<T & U & Resource>> {\n    try {\n      const request: RequestContext = {\n        globalEndpointManager: this.globalEndpointManager,\n        requestAgent: this.cosmosClientOptions.agent,\n        connectionPolicy: this.connectionPolicy,\n        method: HTTPMethod.post,\n        client: this,\n        operationType: OperationType.Create,\n        path,\n        resourceType,\n        resourceId,\n        body,\n        options,\n        plugins: this.cosmosClientOptions.plugins,\n        partitionKey\n      };\n\n      request.headers = await this.buildHeaders(request);\n      // create will use WriteEndpoint since it uses POST operation\n      this.applySessionToken(request);\n\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        request.resourceType,\n        request.operationType\n      );\n      const response = await executePlugins(request, executeRequest, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Create, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  private processQueryFeedResponse(\n    res: Response<any>,\n    isQuery: boolean,\n    resultFn: (result: { [key: string]: any }) => any[]\n  ): Response<any> {\n    if (isQuery) {\n      return { result: resultFn(res.result), headers: res.headers, code: res.code };\n    } else {\n      const newResult = resultFn(res.result).map((body: any) => body);\n      return { result: newResult, headers: res.headers, code: res.code };\n    }\n  }\n\n  private applySessionToken(requestContext: RequestContext) {\n    const request = this.getSessionParams(requestContext.path);\n\n    if (requestContext.headers && requestContext.headers[Constants.HttpHeaders.SessionToken]) {\n      return;\n    }\n\n    const sessionConsistency: ConsistencyLevel = requestContext.headers[\n      Constants.HttpHeaders.ConsistencyLevel\n    ] as ConsistencyLevel;\n    if (!sessionConsistency) {\n      return;\n    }\n\n    if (sessionConsistency !== ConsistencyLevel.Session) {\n      return;\n    }\n\n    if (request.resourceAddress) {\n      const sessionToken = this.sessionContainer.get(request);\n      if (sessionToken) {\n        requestContext.headers[Constants.HttpHeaders.SessionToken] = sessionToken;\n      }\n    }\n  }\n\n  public async replace<T>({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey\n  }: {\n    body: any;\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n  }): Promise<Response<T & Resource>> {\n    try {\n      const request: RequestContext = {\n        globalEndpointManager: this.globalEndpointManager,\n        requestAgent: this.cosmosClientOptions.agent,\n        connectionPolicy: this.connectionPolicy,\n        method: HTTPMethod.put,\n        client: this,\n        operationType: OperationType.Replace,\n        path,\n        resourceType,\n        body,\n        resourceId,\n        options,\n        plugins: this.cosmosClientOptions.plugins,\n        partitionKey\n      };\n\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n\n      // replace will use WriteEndpoint since it uses PUT operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        request.resourceType,\n        request.operationType\n      );\n      const response = await executePlugins(request, executeRequest, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Replace, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async upsert<T, U = T>({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey\n  }: {\n    body: T;\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n  }): Promise<Response<T & U & Resource>> {\n    try {\n      const request: RequestContext = {\n        globalEndpointManager: this.globalEndpointManager,\n        requestAgent: this.cosmosClientOptions.agent,\n        connectionPolicy: this.connectionPolicy,\n        method: HTTPMethod.post,\n        client: this,\n        operationType: OperationType.Upsert,\n        path,\n        resourceType,\n        body,\n        resourceId,\n        options,\n        plugins: this.cosmosClientOptions.plugins,\n        partitionKey\n      };\n\n      request.headers = await this.buildHeaders(request);\n      request.headers[Constants.HttpHeaders.IsUpsert] = true;\n      this.applySessionToken(request);\n\n      // upsert will use WriteEndpoint since it uses POST operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        request.resourceType,\n        request.operationType\n      );\n      const response = await executePlugins(request, executeRequest, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Upsert, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async execute<T>({\n    sprocLink,\n    params,\n    options = {},\n    partitionKey\n  }: {\n    sprocLink: string;\n    params?: any[];\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n  }): Promise<Response<T>> {\n    // Accept a single parameter or an array of parameters.\n    // Didn't add type annotation for this because we should legacy this behavior\n    if (params !== null && params !== undefined && !Array.isArray(params)) {\n      params = [params];\n    }\n    const path = getPathFromLink(sprocLink);\n    const id = getIdFromLink(sprocLink);\n\n    const request: RequestContext = {\n      globalEndpointManager: this.globalEndpointManager,\n      requestAgent: this.cosmosClientOptions.agent,\n      connectionPolicy: this.connectionPolicy,\n      method: HTTPMethod.post,\n      client: this,\n      operationType: OperationType.Execute,\n      path,\n      resourceType: ResourceType.sproc,\n      options,\n      resourceId: id,\n      body: params,\n      plugins: this.cosmosClientOptions.plugins,\n      partitionKey\n    };\n\n    request.headers = await this.buildHeaders(request);\n    // executeStoredProcedure will use WriteEndpoint since it uses POST operation\n    request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n      request.resourceType,\n      request.operationType\n    );\n    return executePlugins(request, executeRequest, PluginOn.operation);\n  }\n\n  /**\n   * Gets the Database account information.\n   * @param {string} [options.urlConnection]   - The endpoint url whose database account needs to be retrieved. \\\n   * If not present, current client's url will be used.\n   */\n  public async getDatabaseAccount(\n    options: RequestOptions = {}\n  ): Promise<Response<DatabaseAccount>> {\n    const endpoint = options.urlConnection || this.cosmosClientOptions.endpoint;\n    const request: RequestContext = {\n      endpoint,\n      globalEndpointManager: this.globalEndpointManager,\n      requestAgent: this.cosmosClientOptions.agent,\n      connectionPolicy: this.connectionPolicy,\n      method: HTTPMethod.get,\n      client: this,\n      operationType: OperationType.Read,\n      path: \"\",\n      resourceType: ResourceType.none,\n      options,\n      plugins: this.cosmosClientOptions.plugins\n    };\n\n    request.headers = await this.buildHeaders(request);\n    // await options.beforeOperation({ endpoint, request, headers: requestHeaders });\n    const { result, headers } = await executePlugins(request, executeRequest, PluginOn.operation);\n\n    const databaseAccount = new DatabaseAccount(result, headers);\n\n    return { result: databaseAccount, headers };\n  }\n\n  public getWriteEndpoint(): Promise<string> {\n    return this.globalEndpointManager.getWriteEndpoint();\n  }\n\n  public getReadEndpoint(): Promise<string> {\n    return this.globalEndpointManager.getReadEndpoint();\n  }\n\n  public async bulk<T>({\n    body,\n    path,\n    resourceId,\n    partitionKeyRangeId,\n    options = {}\n  }: {\n    body: T;\n    path: string;\n    partitionKeyRangeId: string;\n    resourceId: string;\n    options?: RequestOptions;\n  }) {\n    try {\n      const request: RequestContext = {\n        globalEndpointManager: this.globalEndpointManager,\n        requestAgent: this.cosmosClientOptions.agent,\n        connectionPolicy: this.connectionPolicy,\n        method: HTTPMethod.post,\n        client: this,\n        operationType: OperationType.Batch,\n        path,\n        body,\n        resourceType: ResourceType.item,\n        resourceId,\n        plugins: this.cosmosClientOptions.plugins,\n        options\n      };\n\n      request.headers = await this.buildHeaders(request);\n      request.headers[Constants.HttpHeaders.IsBatchRequest] = true;\n      request.headers[Constants.HttpHeaders.PartitionKeyRangeID] = partitionKeyRangeId;\n      request.headers[Constants.HttpHeaders.IsBatchAtomic] = false;\n\n      this.applySessionToken(request);\n\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        request.resourceType,\n        request.operationType\n      );\n      const response = await executePlugins(request, executeRequest, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Batch, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  private captureSessionToken(\n    err: ErrorResponse,\n    path: string,\n    operationType: OperationType,\n    resHeaders: CosmosHeaders\n  ) {\n    const request = this.getSessionParams(path);\n    request.operationType = operationType;\n    if (\n      !err ||\n      (!this.isMasterResource(request.resourceType) &&\n        (err.code === StatusCodes.PreconditionFailed ||\n          err.code === StatusCodes.Conflict ||\n          (err.code === StatusCodes.NotFound &&\n            err.substatus !== SubStatusCodes.ReadSessionNotAvailable)))\n    ) {\n      this.sessionContainer.set(request, resHeaders);\n    }\n  }\n\n  public clearSessionToken(path: string) {\n    const request = this.getSessionParams(path);\n    this.sessionContainer.remove(request);\n  }\n\n  private getSessionParams(resourceLink: string): SessionContext {\n    const resourceId: string = null;\n    let resourceAddress: string = null;\n    const parserOutput = parseLink(resourceLink);\n\n    resourceAddress = parserOutput.objectBody.self;\n\n    const resourceType = parserOutput.type;\n    return {\n      resourceId,\n      resourceAddress,\n      resourceType,\n      isNameBased: true\n    };\n  }\n\n  private isMasterResource(resourceType: string): boolean {\n    if (\n      resourceType === Constants.Path.OffersPathSegment ||\n      resourceType === Constants.Path.DatabasesPathSegment ||\n      resourceType === Constants.Path.UsersPathSegment ||\n      resourceType === Constants.Path.PermissionsPathSegment ||\n      resourceType === Constants.Path.TopologyPathSegment ||\n      resourceType === Constants.Path.DatabaseAccountPathSegment ||\n      resourceType === Constants.Path.PartitionKeyRangesPathSegment ||\n      resourceType === Constants.Path.CollectionsPathSegment\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private buildHeaders(requestContext: RequestContext) {\n    return getHeaders({\n      clientOptions: this.cosmosClientOptions,\n      defaultHeaders: {\n        ...this.cosmosClientOptions.defaultHeaders,\n        ...requestContext.options.initialHeaders\n      },\n      verb: requestContext.method,\n      path: requestContext.path,\n      resourceId: requestContext.resourceId,\n      resourceType: requestContext.resourceType,\n      options: requestContext.options,\n      partitionKeyRangeId: requestContext.partitionKeyRangeId,\n      useMultipleWriteLocations: this.connectionPolicy.useMultipleWriteLocations,\n      partitionKey: requestContext.partitionKey\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}