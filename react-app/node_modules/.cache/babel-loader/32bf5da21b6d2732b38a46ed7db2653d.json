{"ast":null,"code":"import { __awaiter } from \"tslib\"; // Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Constants } from \"../common\";\nimport { logger } from \"../common/logger\";\nimport { ClientSideMetrics, QueryMetrics } from \"../queryMetrics\";\nimport { getInitialHeader } from \"./headerUtils\";\n/** @hidden */\n\nconst log = logger(\"defaultQueryExecutionContext\");\n/** @hidden */\n\nvar STATES;\n\n(function (STATES) {\n  STATES[\"start\"] = \"start\";\n  STATES[\"inProgress\"] = \"inProgress\";\n  STATES[\"ended\"] = \"ended\";\n})(STATES || (STATES = {}));\n/** @hidden */\n\n\nexport class DefaultQueryExecutionContext {\n  /**\n   * Provides the basic Query Execution Context.\n   * This wraps the internal logic query execution using provided fetch functions\n   * @constructor DefaultQueryExecutionContext\n   * @param {ClientContext} clientContext          - Is used to read the partitionKeyRanges for split proofing\n   * @param {SqlQuerySpec | string} query          - A SQL query.\n   * @param {FeedOptions} [options]                - Represents the feed options.\n   * @param {callback | callback[]} fetchFunctions - A function to retrieve each page of data.\n   *                          An array of functions may be used to query more than one partition.\n   * @ignore\n   */\n  constructor(options, fetchFunctions) {\n    // TODO: any options\n    this.resources = [];\n    this.currentIndex = 0;\n    this.currentPartitionIndex = 0;\n    this.fetchFunctions = Array.isArray(fetchFunctions) ? fetchFunctions : [fetchFunctions];\n    this.options = options || {};\n    this.continuationToken = this.options.continuationToken || this.options.continuation || null;\n    this.state = DefaultQueryExecutionContext.STATES.start;\n  }\n\n  get continuation() {\n    return this.continuationToken;\n  }\n  /**\n   * Execute a provided callback on the next element in the execution context.\n   * @memberof DefaultQueryExecutionContext\n   * @instance\n   */\n\n\n  nextItem() {\n    return __awaiter(this, void 0, void 0, function* () {\n      ++this.currentIndex;\n      const response = yield this.current();\n      return response;\n    });\n  }\n  /**\n   * Retrieve the current element on the execution context.\n   * @memberof DefaultQueryExecutionContext\n   * @instance\n   */\n\n\n  current() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.currentIndex < this.resources.length) {\n        return {\n          result: this.resources[this.currentIndex],\n          headers: getInitialHeader()\n        };\n      }\n\n      if (this._canFetchMore()) {\n        const {\n          result: resources,\n          headers\n        } = yield this.fetchMore();\n        this.resources = resources;\n\n        if (this.resources.length === 0) {\n          if (!this.continuationToken && this.currentPartitionIndex >= this.fetchFunctions.length) {\n            this.state = DefaultQueryExecutionContext.STATES.ended;\n            return {\n              result: undefined,\n              headers\n            };\n          } else {\n            return this.current();\n          }\n        }\n\n        return {\n          result: this.resources[this.currentIndex],\n          headers\n        };\n      } else {\n        this.state = DefaultQueryExecutionContext.STATES.ended;\n        return {\n          result: undefined,\n          headers: getInitialHeader()\n        };\n      }\n    });\n  }\n  /**\n   * Determine if there are still remaining resources to processs based on\n   * the value of the continuation token or the elements remaining on the current batch in the execution context.\n   * @memberof DefaultQueryExecutionContext\n   * @instance\n   * @returns {Boolean} true if there is other elements to process in the DefaultQueryExecutionContext.\n   */\n\n\n  hasMoreResults() {\n    return this.state === DefaultQueryExecutionContext.STATES.start || this.continuationToken !== undefined || this.currentIndex < this.resources.length - 1 || this.currentPartitionIndex < this.fetchFunctions.length;\n  }\n  /**\n   * Fetches the next batch of the feed and pass them as an array to a callback\n   * @memberof DefaultQueryExecutionContext\n   * @instance\n   */\n\n  /**\n   * Fetches the next batch of the feed and pass them as an array to a callback\n   * @memberof DefaultQueryExecutionContext\n   * @instance\n   */\n\n\n  fetchMore() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.currentPartitionIndex >= this.fetchFunctions.length) {\n        return {\n          headers: getInitialHeader(),\n          result: undefined\n        };\n      } // Keep to the original continuation and to restore the value after fetchFunction call\n\n\n      const originalContinuation = this.options.continuationToken || this.options.continuation;\n      this.options.continuationToken = this.continuationToken; // Return undefined if there is no more results\n\n      if (this.currentPartitionIndex >= this.fetchFunctions.length) {\n        return {\n          headers: getInitialHeader(),\n          result: undefined\n        };\n      }\n\n      let resources;\n      let responseHeaders;\n\n      try {\n        let p;\n\n        if (this.nextFetchFunction !== undefined) {\n          log.debug(\"using prefetch\");\n          p = this.nextFetchFunction;\n          this.nextFetchFunction = undefined;\n        } else {\n          log.debug(\"using fresh fetch\");\n          p = this.fetchFunctions[this.currentPartitionIndex](this.options);\n        }\n\n        const response = yield p;\n        resources = response.result;\n        responseHeaders = response.headers;\n        this.continuationToken = responseHeaders[Constants.HttpHeaders.Continuation];\n\n        if (!this.continuationToken) {\n          ++this.currentPartitionIndex;\n        }\n\n        if (this.options && this.options.bufferItems === true) {\n          const fetchFunction = this.fetchFunctions[this.currentPartitionIndex];\n          this.nextFetchFunction = fetchFunction ? fetchFunction(Object.assign(Object.assign({}, this.options), {\n            continuationToken: this.continuationToken\n          })) : undefined;\n        }\n      } catch (err) {\n        this.state = DefaultQueryExecutionContext.STATES.ended; // return callback(err, undefined, responseHeaders);\n        // TODO: Error and data being returned is an antipattern, this might broken\n\n        throw err;\n      }\n\n      this.state = DefaultQueryExecutionContext.STATES.inProgress;\n      this.currentIndex = 0;\n      this.options.continuationToken = originalContinuation;\n      this.options.continuation = originalContinuation; // deserializing query metrics so that we aren't working with delimited strings in the rest of the code base\n\n      if (Constants.HttpHeaders.QueryMetrics in responseHeaders) {\n        const delimitedString = responseHeaders[Constants.HttpHeaders.QueryMetrics];\n        let queryMetrics = QueryMetrics.createFromDelimitedString(delimitedString); // Add the request charge to the query metrics so that we can have per partition request charge.\n\n        if (Constants.HttpHeaders.RequestCharge in responseHeaders) {\n          const requestCharge = Number(responseHeaders[Constants.HttpHeaders.RequestCharge]) || 0;\n          queryMetrics = new QueryMetrics(queryMetrics.retrievedDocumentCount, queryMetrics.retrievedDocumentSize, queryMetrics.outputDocumentCount, queryMetrics.outputDocumentSize, queryMetrics.indexHitDocumentCount, queryMetrics.totalQueryExecutionTime, queryMetrics.queryPreparationTimes, queryMetrics.indexLookupTime, queryMetrics.documentLoadTime, queryMetrics.vmExecutionTime, queryMetrics.runtimeExecutionTimes, queryMetrics.documentWriteTime, new ClientSideMetrics(requestCharge));\n        } // Wraping query metrics in a object where the key is '0' just so single partition\n        // and partition queries have the same response schema\n\n\n        responseHeaders[Constants.HttpHeaders.QueryMetrics] = {};\n        responseHeaders[Constants.HttpHeaders.QueryMetrics][\"0\"] = queryMetrics;\n      }\n\n      return {\n        result: resources,\n        headers: responseHeaders\n      };\n    });\n  }\n\n  _canFetchMore() {\n    const res = this.state === DefaultQueryExecutionContext.STATES.start || this.continuationToken && this.state === DefaultQueryExecutionContext.STATES.inProgress || this.currentPartitionIndex < this.fetchFunctions.length && this.state === DefaultQueryExecutionContext.STATES.inProgress;\n    return res;\n  }\n\n}\nDefaultQueryExecutionContext.STATES = STATES;","map":{"version":3,"sources":["../../src/queryExecutionContext/defaultQueryExecutionContext.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Constants } from \"../common\";\nimport { logger } from \"../common/logger\";\nimport { ClientSideMetrics, QueryMetrics } from \"../queryMetrics\";\nimport { FeedOptions, Response } from \"../request\";\nimport { getInitialHeader } from \"./headerUtils\";\nimport { ExecutionContext } from \"./index\";\n\n/** @hidden */\nconst log = logger(\"defaultQueryExecutionContext\");\n\n/** @hidden */\nexport type FetchFunctionCallback = (options: FeedOptions) => Promise<Response<any>>;\n\n/** @hidden */\nenum STATES {\n  start = \"start\",\n  inProgress = \"inProgress\",\n  ended = \"ended\"\n}\n\n/** @hidden */\nexport class DefaultQueryExecutionContext implements ExecutionContext {\n  private static readonly STATES = STATES;\n  private resources: any[]; // TODO: any resources\n  private currentIndex: number;\n  private currentPartitionIndex: number;\n  private fetchFunctions: FetchFunctionCallback[];\n  private options: FeedOptions; // TODO: any options\n  public continuationToken: string; // TODO: any continuation\n  public get continuation() {\n    return this.continuationToken;\n  }\n  private state: STATES;\n  private nextFetchFunction: Promise<Response<any>>;\n  /**\n   * Provides the basic Query Execution Context.\n   * This wraps the internal logic query execution using provided fetch functions\n   * @constructor DefaultQueryExecutionContext\n   * @param {ClientContext} clientContext          - Is used to read the partitionKeyRanges for split proofing\n   * @param {SqlQuerySpec | string} query          - A SQL query.\n   * @param {FeedOptions} [options]                - Represents the feed options.\n   * @param {callback | callback[]} fetchFunctions - A function to retrieve each page of data.\n   *                          An array of functions may be used to query more than one partition.\n   * @ignore\n   */\n  constructor(options: any, fetchFunctions: FetchFunctionCallback | FetchFunctionCallback[]) {\n    // TODO: any options\n    this.resources = [];\n    this.currentIndex = 0;\n    this.currentPartitionIndex = 0;\n    this.fetchFunctions = Array.isArray(fetchFunctions) ? fetchFunctions : [fetchFunctions];\n    this.options = options || {};\n    this.continuationToken = this.options.continuationToken || this.options.continuation || null;\n    this.state = DefaultQueryExecutionContext.STATES.start;\n  }\n\n  /**\n   * Execute a provided callback on the next element in the execution context.\n   * @memberof DefaultQueryExecutionContext\n   * @instance\n   */\n  public async nextItem(): Promise<Response<any>> {\n    ++this.currentIndex;\n    const response = await this.current();\n    return response;\n  }\n\n  /**\n   * Retrieve the current element on the execution context.\n   * @memberof DefaultQueryExecutionContext\n   * @instance\n   */\n  public async current(): Promise<Response<any>> {\n    if (this.currentIndex < this.resources.length) {\n      return {\n        result: this.resources[this.currentIndex],\n        headers: getInitialHeader()\n      };\n    }\n\n    if (this._canFetchMore()) {\n      const { result: resources, headers } = await this.fetchMore();\n      this.resources = resources;\n      if (this.resources.length === 0) {\n        if (!this.continuationToken && this.currentPartitionIndex >= this.fetchFunctions.length) {\n          this.state = DefaultQueryExecutionContext.STATES.ended;\n          return { result: undefined, headers };\n        } else {\n          return this.current();\n        }\n      }\n      return { result: this.resources[this.currentIndex], headers };\n    } else {\n      this.state = DefaultQueryExecutionContext.STATES.ended;\n      return { result: undefined, headers: getInitialHeader() };\n    }\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs based on\n   * the value of the continuation token or the elements remaining on the current batch in the execution context.\n   * @memberof DefaultQueryExecutionContext\n   * @instance\n   * @returns {Boolean} true if there is other elements to process in the DefaultQueryExecutionContext.\n   */\n  public hasMoreResults() {\n    return (\n      this.state === DefaultQueryExecutionContext.STATES.start ||\n      this.continuationToken !== undefined ||\n      this.currentIndex < this.resources.length - 1 ||\n      this.currentPartitionIndex < this.fetchFunctions.length\n    );\n  }\n\n  /**\n   * Fetches the next batch of the feed and pass them as an array to a callback\n   * @memberof DefaultQueryExecutionContext\n   * @instance\n   */\n  /**\n   * Fetches the next batch of the feed and pass them as an array to a callback\n   * @memberof DefaultQueryExecutionContext\n   * @instance\n   */\n  public async fetchMore(): Promise<Response<any>> {\n    if (this.currentPartitionIndex >= this.fetchFunctions.length) {\n      return { headers: getInitialHeader(), result: undefined };\n    }\n\n    // Keep to the original continuation and to restore the value after fetchFunction call\n    const originalContinuation = this.options.continuationToken || this.options.continuation;\n    this.options.continuationToken = this.continuationToken;\n\n    // Return undefined if there is no more results\n    if (this.currentPartitionIndex >= this.fetchFunctions.length) {\n      return { headers: getInitialHeader(), result: undefined };\n    }\n\n    let resources;\n    let responseHeaders;\n    try {\n      let p: Promise<Response<any>>;\n      if (this.nextFetchFunction !== undefined) {\n        log.debug(\"using prefetch\");\n        p = this.nextFetchFunction;\n        this.nextFetchFunction = undefined;\n      } else {\n        log.debug(\"using fresh fetch\");\n        p = this.fetchFunctions[this.currentPartitionIndex](this.options);\n      }\n      const response = await p;\n      resources = response.result;\n      responseHeaders = response.headers;\n\n      this.continuationToken = responseHeaders[Constants.HttpHeaders.Continuation];\n      if (!this.continuationToken) {\n        ++this.currentPartitionIndex;\n      }\n\n      if (this.options && this.options.bufferItems === true) {\n        const fetchFunction = this.fetchFunctions[this.currentPartitionIndex];\n        this.nextFetchFunction = fetchFunction\n          ? fetchFunction({ ...this.options, continuationToken: this.continuationToken })\n          : undefined;\n      }\n    } catch (err) {\n      this.state = DefaultQueryExecutionContext.STATES.ended;\n      // return callback(err, undefined, responseHeaders);\n      // TODO: Error and data being returned is an antipattern, this might broken\n      throw err;\n    }\n\n    this.state = DefaultQueryExecutionContext.STATES.inProgress;\n    this.currentIndex = 0;\n    this.options.continuationToken = originalContinuation;\n    this.options.continuation = originalContinuation;\n\n    // deserializing query metrics so that we aren't working with delimited strings in the rest of the code base\n    if (Constants.HttpHeaders.QueryMetrics in responseHeaders) {\n      const delimitedString = responseHeaders[Constants.HttpHeaders.QueryMetrics];\n      let queryMetrics = QueryMetrics.createFromDelimitedString(delimitedString);\n\n      // Add the request charge to the query metrics so that we can have per partition request charge.\n      if (Constants.HttpHeaders.RequestCharge in responseHeaders) {\n        const requestCharge = Number(responseHeaders[Constants.HttpHeaders.RequestCharge]) || 0;\n        queryMetrics = new QueryMetrics(\n          queryMetrics.retrievedDocumentCount,\n          queryMetrics.retrievedDocumentSize,\n          queryMetrics.outputDocumentCount,\n          queryMetrics.outputDocumentSize,\n          queryMetrics.indexHitDocumentCount,\n          queryMetrics.totalQueryExecutionTime,\n          queryMetrics.queryPreparationTimes,\n          queryMetrics.indexLookupTime,\n          queryMetrics.documentLoadTime,\n          queryMetrics.vmExecutionTime,\n          queryMetrics.runtimeExecutionTimes,\n          queryMetrics.documentWriteTime,\n          new ClientSideMetrics(requestCharge)\n        );\n      }\n\n      // Wraping query metrics in a object where the key is '0' just so single partition\n      // and partition queries have the same response schema\n      responseHeaders[Constants.HttpHeaders.QueryMetrics] = {};\n      responseHeaders[Constants.HttpHeaders.QueryMetrics][\"0\"] = queryMetrics;\n    }\n\n    return { result: resources, headers: responseHeaders };\n  }\n\n  private _canFetchMore() {\n    const res =\n      this.state === DefaultQueryExecutionContext.STATES.start ||\n      (this.continuationToken && this.state === DefaultQueryExecutionContext.STATES.inProgress) ||\n      (this.currentPartitionIndex < this.fetchFunctions.length &&\n        this.state === DefaultQueryExecutionContext.STATES.inProgress);\n    return res;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}