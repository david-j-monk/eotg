{"ast":null,"code":"import { __awaiter } from \"tslib\"; // Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport PriorityQueue from \"priorityqueuejs\";\nimport semaphore from \"semaphore\";\nimport { logger } from \"../common/logger\";\nimport { StatusCodes, SubStatusCodes } from \"../common/statusCodes\";\nimport { QueryRange } from \"../routing/QueryRange\";\nimport { SmartRoutingMapProvider } from \"../routing/smartRoutingMapProvider\";\nimport { DocumentProducer } from \"./documentProducer\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\n/** @hidden */\n\nconst log = logger(\"parallelQueryExecutionContextBase\");\n/** @hidden */\n\nexport var ParallelQueryExecutionContextBaseStates;\n\n(function (ParallelQueryExecutionContextBaseStates) {\n  ParallelQueryExecutionContextBaseStates[\"started\"] = \"started\";\n  ParallelQueryExecutionContextBaseStates[\"inProgress\"] = \"inProgress\";\n  ParallelQueryExecutionContextBaseStates[\"ended\"] = \"ended\";\n})(ParallelQueryExecutionContextBaseStates || (ParallelQueryExecutionContextBaseStates = {}));\n/** @hidden */\n\n\nexport class ParallelQueryExecutionContextBase {\n  /**\n   * Provides the ParallelQueryExecutionContextBase.\n   * This is the base class that ParallelQueryExecutionContext and OrderByQueryExecutionContext will derive from.\n   *\n   * When handling a parallelized query, it instantiates one instance of\n   * DocumentProcuder per target partition key range and aggregates the result of each.\n   *\n   * @constructor ParallelQueryExecutionContext\n   * @param {ClientContext} clientContext        - The service endpoint to use to create the client.\n   * @param {string} collectionLink                - The Collection Link\n   * @param {FeedOptions} [options]                - Represents the feed options.\n   * @param {object} partitionedQueryExecutionInfo - PartitionedQueryExecutionInfo\n   * @ignore\n   */\n  constructor(clientContext, collectionLink, query, // TODO: any - It's not SQLQuerySpec\n  options, partitionedQueryExecutionInfo) {\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n    this.err = undefined;\n    this.state = ParallelQueryExecutionContextBase.STATES.started;\n    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);\n    this.sortOrders = this.partitionedQueryExecutionInfo.queryInfo.orderBy;\n    this.requestContinuation = options ? options.continuationToken || options.continuation : null; // response headers of undergoing operation\n\n    this.respHeaders = getInitialHeader(); // Make priority queue for documentProducers\n    // The comparator is supplied by the derived class\n\n    this.orderByPQ = new PriorityQueue((a, b) => this.documentProducerComparator(b, a)); // Creating the documentProducers\n\n    this.sem = semaphore(1); // Creating callback for semaphore\n    // TODO: Code smell\n\n    const createDocumentProducersAndFillUpPriorityQueueFunc = () => __awaiter(this, void 0, void 0, function* () {\n      // ensure the lock is released after finishing up\n      try {\n        const targetPartitionRanges = yield this._onTargetPartitionRanges();\n        this.waitingForInternalExecutionContexts = targetPartitionRanges.length;\n        const maxDegreeOfParallelism = options.maxDegreeOfParallelism === undefined || options.maxDegreeOfParallelism < 1 ? targetPartitionRanges.length : Math.min(options.maxDegreeOfParallelism, targetPartitionRanges.length);\n        log.info(\"Query starting against \" + targetPartitionRanges.length + \" ranges with parallelism of \" + maxDegreeOfParallelism);\n        const parallelismSem = semaphore(maxDegreeOfParallelism);\n        let filteredPartitionKeyRanges = []; // The document producers generated from filteredPartitionKeyRanges\n\n        const targetPartitionQueryExecutionContextList = [];\n\n        if (this.requestContinuation) {\n          throw new Error(\"Continuation tokens are not yet supported for cross partition queries\");\n        } else {\n          filteredPartitionKeyRanges = targetPartitionRanges;\n        } // Create one documentProducer for each partitionTargetRange\n\n\n        filteredPartitionKeyRanges.forEach(partitionTargetRange => {\n          // TODO: any partitionTargetRange\n          // no async callback\n          targetPartitionQueryExecutionContextList.push(this._createTargetPartitionQueryExecutionContext(partitionTargetRange));\n        }); // Fill up our priority queue with documentProducers\n\n        targetPartitionQueryExecutionContextList.forEach(documentProducer => {\n          // has async callback\n          const throttledFunc = () => __awaiter(this, void 0, void 0, function* () {\n            try {\n              const {\n                result: document,\n                headers\n              } = yield documentProducer.current();\n\n              this._mergeWithActiveResponseHeaders(headers);\n\n              if (document === undefined) {\n                // no results on this one\n                return;\n              } // if there are matching results in the target ex range add it to the priority queue\n\n\n              try {\n                this.orderByPQ.enq(documentProducer);\n              } catch (e) {\n                this.err = e;\n              }\n            } catch (err) {\n              this._mergeWithActiveResponseHeaders(err.headers);\n\n              this.err = err;\n            } finally {\n              parallelismSem.leave();\n\n              this._decrementInitiationLock();\n            }\n          });\n\n          parallelismSem.take(throttledFunc);\n        });\n      } catch (err) {\n        this.err = err; // release the lock\n\n        this.sem.leave();\n        return;\n      }\n    });\n\n    this.sem.take(createDocumentProducersAndFillUpPriorityQueueFunc);\n  }\n\n  _decrementInitiationLock() {\n    // decrements waitingForInternalExecutionContexts\n    // if waitingForInternalExecutionContexts reaches 0 releases the semaphore and changes the state\n    this.waitingForInternalExecutionContexts = this.waitingForInternalExecutionContexts - 1;\n\n    if (this.waitingForInternalExecutionContexts === 0) {\n      this.sem.leave();\n\n      if (this.orderByPQ.size() === 0) {\n        this.state = ParallelQueryExecutionContextBase.STATES.inProgress;\n      }\n    }\n  }\n\n  _mergeWithActiveResponseHeaders(headers) {\n    mergeHeaders(this.respHeaders, headers);\n  }\n\n  _getAndResetActiveResponseHeaders() {\n    const ret = this.respHeaders;\n    this.respHeaders = getInitialHeader();\n    return ret;\n  }\n\n  _onTargetPartitionRanges() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // invokes the callback when the target partition ranges are ready\n      const parsedRanges = this.partitionedQueryExecutionInfo.queryRanges;\n      const queryRanges = parsedRanges.map(item => QueryRange.parseFromDict(item));\n      return this.routingProvider.getOverlappingRanges(this.collectionLink, queryRanges);\n    });\n  }\n  /**\n   * Gets the replacement ranges for a partitionkeyrange that has been split\n   * @memberof ParallelQueryExecutionContextBase\n   * @instance\n   */\n\n\n  _getReplacementPartitionKeyRanges(documentProducer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const partitionKeyRange = documentProducer.targetPartitionKeyRange; // Download the new routing map\n\n      this.routingProvider = new SmartRoutingMapProvider(this.clientContext); // Get the queryRange that relates to this partitionKeyRange\n\n      const queryRange = QueryRange.parsePartitionKeyRange(partitionKeyRange);\n      return this.routingProvider.getOverlappingRanges(this.collectionLink, [queryRange]);\n    });\n  } // TODO: P0 Code smell - can barely tell what this is doing\n\n  /**\n   * Removes the current document producer from the priqueue,\n   * replaces that document producer with child document producers,\n   * then reexecutes the originFunction with the corrrected executionContext\n   * @memberof ParallelQueryExecutionContextBase\n   * @instance\n   */\n\n\n  _repairExecutionContext(originFunction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO: any\n      // Get the replacement ranges\n      // Removing the invalid documentProducer from the orderByPQ\n      const parentDocumentProducer = this.orderByPQ.deq();\n\n      try {\n        const replacementPartitionKeyRanges = yield this._getReplacementPartitionKeyRanges(parentDocumentProducer);\n        const replacementDocumentProducers = []; // Create the replacement documentProducers\n\n        replacementPartitionKeyRanges.forEach(partitionKeyRange => {\n          // Create replacment document producers with the parent's continuationToken\n          const replacementDocumentProducer = this._createTargetPartitionQueryExecutionContext(partitionKeyRange, parentDocumentProducer.continuationToken);\n\n          replacementDocumentProducers.push(replacementDocumentProducer);\n        }); // We need to check if the documentProducers even has anything left to fetch from before enqueing them\n\n        const checkAndEnqueueDocumentProducer = (documentProducerToCheck, checkNextDocumentProducerCallback) => __awaiter(this, void 0, void 0, function* () {\n          try {\n            const {\n              result: afterItem\n            } = yield documentProducerToCheck.current();\n\n            if (afterItem === undefined) {// no more results left in this document producer, so we don't enqueue it\n            } else {\n              // Safe to put document producer back in the queue\n              this.orderByPQ.enq(documentProducerToCheck);\n            }\n\n            yield checkNextDocumentProducerCallback();\n          } catch (err) {\n            this.err = err;\n            return;\n          }\n        });\n\n        const checkAndEnqueueDocumentProducers = rdp => __awaiter(this, void 0, void 0, function* () {\n          if (rdp.length > 0) {\n            // We still have a replacementDocumentProducer to check\n            const replacementDocumentProducer = rdp.shift();\n            yield checkAndEnqueueDocumentProducer(replacementDocumentProducer, () => __awaiter(this, void 0, void 0, function* () {\n              yield checkAndEnqueueDocumentProducers(rdp);\n            }));\n          } else {\n            // reexecutes the originFunction with the corrrected executionContext\n            return originFunction();\n          }\n        }); // Invoke the recursive function to get the ball rolling\n\n\n        yield checkAndEnqueueDocumentProducers(replacementDocumentProducers);\n      } catch (err) {\n        this.err = err;\n        throw err;\n      }\n    });\n  }\n\n  static _needPartitionKeyRangeCacheRefresh(error) {\n    // TODO: any error\n    return error.code === StatusCodes.Gone && \"substatus\" in error && error[\"substatus\"] === SubStatusCodes.PartitionKeyRangeGone;\n  }\n  /**\n   * Checks to see if the executionContext needs to be repaired.\n   * if so it repairs the execution context and executes the ifCallback,\n   * else it continues with the current execution context and executes the elseCallback\n   * @memberof ParallelQueryExecutionContextBase\n   * @instance\n   */\n\n\n  _repairExecutionContextIfNeeded(ifCallback, elseCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const documentProducer = this.orderByPQ.peek(); // Check if split happened\n\n      try {\n        yield documentProducer.current();\n        elseCallback();\n      } catch (err) {\n        if (ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {\n          // Split has happened so we need to repair execution context before continueing\n          return this._repairExecutionContext(ifCallback);\n        } else {\n          // Something actually bad happened ...\n          this.err = err;\n          throw err;\n        }\n      }\n    });\n  }\n  /**\n   * Execute a provided function on the next element in the ParallelQueryExecutionContextBase.\n   * @memberof ParallelQueryExecutionContextBase\n   * @instance\n   * @param {callback} callback - Function to execute for each element. the function takes two \\\n   * parameters error, element.\n   */\n\n\n  nextItem() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.err) {\n        // if there is a prior error return error\n        throw this.err;\n      }\n\n      return new Promise((resolve, reject) => {\n        this.sem.take(() => {\n          // NOTE: lock must be released before invoking quitting\n          if (this.err) {\n            // release the lock before invoking callback\n            this.sem.leave(); // if there is a prior error return error\n\n            this.err.headers = this._getAndResetActiveResponseHeaders();\n            reject(this.err);\n            return;\n          }\n\n          if (this.orderByPQ.size() === 0) {\n            // there is no more results\n            this.state = ParallelQueryExecutionContextBase.STATES.ended; // release the lock before invoking callback\n\n            this.sem.leave();\n            return resolve({\n              result: undefined,\n              headers: this._getAndResetActiveResponseHeaders()\n            });\n          }\n\n          const ifCallback = () => {\n            // Release the semaphore to avoid deadlock\n            this.sem.leave(); // Reexcute the function\n\n            return resolve(this.nextItem());\n          };\n\n          const elseCallback = () => __awaiter(this, void 0, void 0, function* () {\n            let documentProducer;\n\n            try {\n              documentProducer = this.orderByPQ.deq();\n            } catch (e) {\n              // if comparing elements of the priority queue throws exception\n              // set that error and return error\n              this.err = e; // release the lock before invoking callback\n\n              this.sem.leave();\n              this.err.headers = this._getAndResetActiveResponseHeaders();\n              reject(this.err);\n              return;\n            }\n\n            let item;\n            let headers;\n\n            try {\n              const response = yield documentProducer.nextItem();\n              item = response.result;\n              headers = response.headers;\n\n              this._mergeWithActiveResponseHeaders(headers);\n\n              if (item === undefined) {\n                // this should never happen\n                // because the documentProducer already has buffered an item\n                // assert item !== undefined\n                this.err = new Error(`Extracted DocumentProducer from the priority queue \\\n                                            doesn't have any buffered item!`); // release the lock before invoking callback\n\n                this.sem.leave();\n                return resolve({\n                  result: undefined,\n                  headers: this._getAndResetActiveResponseHeaders()\n                });\n              }\n            } catch (err) {\n              this.err = new Error(`Extracted DocumentProducer from the priority queue fails to get the \\\n                                    buffered item. Due to ${JSON.stringify(err)}`);\n              this.err.headers = this._getAndResetActiveResponseHeaders(); // release the lock before invoking callback\n\n              this.sem.leave();\n              reject(this.err);\n              return;\n            } // we need to put back the document producer to the queue if it has more elements.\n            // the lock will be released after we know document producer must be put back in the queue or not\n\n\n            try {\n              const {\n                result: afterItem,\n                headers: otherHeaders\n              } = yield documentProducer.current();\n\n              this._mergeWithActiveResponseHeaders(otherHeaders);\n\n              if (afterItem === undefined) {// no more results is left in this document producer\n              } else {\n                try {\n                  const headItem = documentProducer.fetchResults[0];\n\n                  if (typeof headItem === \"undefined\") {\n                    throw new Error(\"Extracted DocumentProducer from PQ is invalid state with no result!\");\n                  }\n\n                  this.orderByPQ.enq(documentProducer);\n                } catch (e) {\n                  // if comparing elements in priority queue throws exception\n                  // set error\n                  this.err = e;\n                }\n              }\n            } catch (err) {\n              if (ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {\n                // We want the document producer enqueued\n                // So that later parts of the code can repair the execution context\n                this.orderByPQ.enq(documentProducer);\n              } else {\n                // Something actually bad happened\n                this.err = err;\n                reject(this.err);\n              }\n            } finally {\n              // release the lock before returning\n              this.sem.leave();\n            } // invoke the callback on the item\n\n\n            return resolve({\n              result: item,\n              headers: this._getAndResetActiveResponseHeaders()\n            });\n          });\n\n          this._repairExecutionContextIfNeeded(ifCallback, elseCallback).catch(reject);\n        });\n      });\n    });\n  }\n  /**\n   * Determine if there are still remaining resources to processs based on the value of the continuation \\\n   * token or the elements remaining on the current batch in the QueryIterator.\n   * @memberof ParallelQueryExecutionContextBase\n   * @instance\n   * @returns {Boolean} true if there is other elements to process in the ParallelQueryExecutionContextBase.\n   */\n\n\n  hasMoreResults() {\n    return !(this.state === ParallelQueryExecutionContextBase.STATES.ended || this.err !== undefined);\n  }\n  /**\n   * Creates document producers\n   */\n\n\n  _createTargetPartitionQueryExecutionContext(partitionKeyTargetRange, continuationToken) {\n    // TODO: any\n    // creates target partition range Query Execution Context\n    let rewrittenQuery = this.partitionedQueryExecutionInfo.queryInfo.rewrittenQuery;\n    let query = this.query;\n\n    if (typeof query === \"string\") {\n      query = {\n        query\n      };\n    }\n\n    const formatPlaceHolder = \"{documentdb-formattableorderbyquery-filter}\";\n\n    if (rewrittenQuery) {\n      query = JSON.parse(JSON.stringify(query)); // We hardcode the formattable filter to true for now\n\n      rewrittenQuery = rewrittenQuery.replace(formatPlaceHolder, \"true\");\n      query[\"query\"] = rewrittenQuery;\n    }\n\n    const options = JSON.parse(JSON.stringify(this.options));\n    options.continuationToken = continuationToken;\n    return new DocumentProducer(this.clientContext, this.collectionLink, query, partitionKeyTargetRange, options);\n  }\n\n}\nParallelQueryExecutionContextBase.STATES = ParallelQueryExecutionContextBaseStates;","map":{"version":3,"sources":["../../src/queryExecutionContext/parallelQueryExecutionContextBase.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport PriorityQueue from \"priorityqueuejs\";\nimport semaphore from \"semaphore\";\nimport { ClientContext } from \"../ClientContext\";\nimport { logger } from \"../common/logger\";\nimport { StatusCodes, SubStatusCodes } from \"../common/statusCodes\";\nimport { FeedOptions, Response } from \"../request\";\nimport { PartitionedQueryExecutionInfo } from \"../request/ErrorResponse\";\nimport { QueryRange } from \"../routing/QueryRange\";\nimport { SmartRoutingMapProvider } from \"../routing/smartRoutingMapProvider\";\nimport { CosmosHeaders } from \"./CosmosHeaders\";\nimport { DocumentProducer } from \"./documentProducer\";\nimport { ExecutionContext } from \"./ExecutionContext\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\n\n/** @hidden */\nconst log = logger(\"parallelQueryExecutionContextBase\");\n\n/** @hidden */\nexport enum ParallelQueryExecutionContextBaseStates {\n  started = \"started\",\n  inProgress = \"inProgress\",\n  ended = \"ended\"\n}\n\n/** @hidden */\nexport abstract class ParallelQueryExecutionContextBase implements ExecutionContext {\n  private err: any;\n  private state: any;\n  private static STATES = ParallelQueryExecutionContextBaseStates;\n  private routingProvider: SmartRoutingMapProvider;\n  protected sortOrders: any;\n  private requestContinuation: any;\n  private respHeaders: CosmosHeaders;\n  private orderByPQ: PriorityQueue<DocumentProducer>;\n  private sem: any;\n  private waitingForInternalExecutionContexts: number;\n  /**\n   * Provides the ParallelQueryExecutionContextBase.\n   * This is the base class that ParallelQueryExecutionContext and OrderByQueryExecutionContext will derive from.\n   *\n   * When handling a parallelized query, it instantiates one instance of\n   * DocumentProcuder per target partition key range and aggregates the result of each.\n   *\n   * @constructor ParallelQueryExecutionContext\n   * @param {ClientContext} clientContext        - The service endpoint to use to create the client.\n   * @param {string} collectionLink                - The Collection Link\n   * @param {FeedOptions} [options]                - Represents the feed options.\n   * @param {object} partitionedQueryExecutionInfo - PartitionedQueryExecutionInfo\n   * @ignore\n   */\n  constructor(\n    private clientContext: ClientContext,\n    private collectionLink: string,\n    private query: any, // TODO: any - It's not SQLQuerySpec\n    private options: FeedOptions,\n    private partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo\n  ) {\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n\n    this.err = undefined;\n    this.state = ParallelQueryExecutionContextBase.STATES.started;\n    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);\n    this.sortOrders = this.partitionedQueryExecutionInfo.queryInfo.orderBy;\n\n    this.requestContinuation = options ? options.continuationToken || options.continuation : null;\n    // response headers of undergoing operation\n    this.respHeaders = getInitialHeader();\n\n    // Make priority queue for documentProducers\n    // The comparator is supplied by the derived class\n    this.orderByPQ = new PriorityQueue<DocumentProducer>(\n      (a: DocumentProducer, b: DocumentProducer) => this.documentProducerComparator(b, a)\n    );\n    // Creating the documentProducers\n    this.sem = semaphore(1);\n    // Creating callback for semaphore\n    // TODO: Code smell\n    const createDocumentProducersAndFillUpPriorityQueueFunc = async () => {\n      // ensure the lock is released after finishing up\n      try {\n        const targetPartitionRanges = await this._onTargetPartitionRanges();\n        this.waitingForInternalExecutionContexts = targetPartitionRanges.length;\n\n        const maxDegreeOfParallelism =\n          options.maxDegreeOfParallelism === undefined || options.maxDegreeOfParallelism < 1\n            ? targetPartitionRanges.length\n            : Math.min(options.maxDegreeOfParallelism, targetPartitionRanges.length);\n\n        log.info(\n          \"Query starting against \" +\n            targetPartitionRanges.length +\n            \" ranges with parallelism of \" +\n            maxDegreeOfParallelism\n        );\n\n        const parallelismSem = semaphore(maxDegreeOfParallelism);\n        let filteredPartitionKeyRanges = [];\n        // The document producers generated from filteredPartitionKeyRanges\n        const targetPartitionQueryExecutionContextList: DocumentProducer[] = [];\n\n        if (this.requestContinuation) {\n          throw new Error(\"Continuation tokens are not yet supported for cross partition queries\");\n        } else {\n          filteredPartitionKeyRanges = targetPartitionRanges;\n        }\n\n        // Create one documentProducer for each partitionTargetRange\n        filteredPartitionKeyRanges.forEach((partitionTargetRange: any) => {\n          // TODO: any partitionTargetRange\n          // no async callback\n          targetPartitionQueryExecutionContextList.push(\n            this._createTargetPartitionQueryExecutionContext(partitionTargetRange)\n          );\n        });\n\n        // Fill up our priority queue with documentProducers\n        targetPartitionQueryExecutionContextList.forEach((documentProducer) => {\n          // has async callback\n          const throttledFunc = async () => {\n            try {\n              const { result: document, headers } = await documentProducer.current();\n              this._mergeWithActiveResponseHeaders(headers);\n              if (document === undefined) {\n                // no results on this one\n                return;\n              }\n              // if there are matching results in the target ex range add it to the priority queue\n              try {\n                this.orderByPQ.enq(documentProducer);\n              } catch (e) {\n                this.err = e;\n              }\n            } catch (err) {\n              this._mergeWithActiveResponseHeaders(err.headers);\n              this.err = err;\n            } finally {\n              parallelismSem.leave();\n              this._decrementInitiationLock();\n            }\n          };\n          parallelismSem.take(throttledFunc);\n        });\n      } catch (err) {\n        this.err = err;\n        // release the lock\n        this.sem.leave();\n        return;\n      }\n    };\n    this.sem.take(createDocumentProducersAndFillUpPriorityQueueFunc);\n  }\n\n  protected abstract documentProducerComparator(\n    dp1: DocumentProducer,\n    dp2: DocumentProducer\n  ): number;\n\n  private _decrementInitiationLock() {\n    // decrements waitingForInternalExecutionContexts\n    // if waitingForInternalExecutionContexts reaches 0 releases the semaphore and changes the state\n    this.waitingForInternalExecutionContexts = this.waitingForInternalExecutionContexts - 1;\n    if (this.waitingForInternalExecutionContexts === 0) {\n      this.sem.leave();\n      if (this.orderByPQ.size() === 0) {\n        this.state = ParallelQueryExecutionContextBase.STATES.inProgress;\n      }\n    }\n  }\n\n  private _mergeWithActiveResponseHeaders(headers: CosmosHeaders) {\n    mergeHeaders(this.respHeaders, headers);\n  }\n\n  private _getAndResetActiveResponseHeaders() {\n    const ret = this.respHeaders;\n    this.respHeaders = getInitialHeader();\n    return ret;\n  }\n\n  private async _onTargetPartitionRanges() {\n    // invokes the callback when the target partition ranges are ready\n    const parsedRanges = this.partitionedQueryExecutionInfo.queryRanges;\n    const queryRanges = parsedRanges.map((item) => QueryRange.parseFromDict(item));\n    return this.routingProvider.getOverlappingRanges(this.collectionLink, queryRanges);\n  }\n\n  /**\n   * Gets the replacement ranges for a partitionkeyrange that has been split\n   * @memberof ParallelQueryExecutionContextBase\n   * @instance\n   */\n  private async _getReplacementPartitionKeyRanges(documentProducer: DocumentProducer) {\n    const partitionKeyRange = documentProducer.targetPartitionKeyRange;\n    // Download the new routing map\n    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);\n    // Get the queryRange that relates to this partitionKeyRange\n    const queryRange = QueryRange.parsePartitionKeyRange(partitionKeyRange);\n    return this.routingProvider.getOverlappingRanges(this.collectionLink, [queryRange]);\n  }\n\n  // TODO: P0 Code smell - can barely tell what this is doing\n  /**\n   * Removes the current document producer from the priqueue,\n   * replaces that document producer with child document producers,\n   * then reexecutes the originFunction with the corrrected executionContext\n   * @memberof ParallelQueryExecutionContextBase\n   * @instance\n   */\n  private async _repairExecutionContext(originFunction: any) {\n    // TODO: any\n    // Get the replacement ranges\n    // Removing the invalid documentProducer from the orderByPQ\n    const parentDocumentProducer = this.orderByPQ.deq();\n    try {\n      const replacementPartitionKeyRanges: any[] = await this._getReplacementPartitionKeyRanges(\n        parentDocumentProducer\n      );\n      const replacementDocumentProducers: DocumentProducer[] = [];\n      // Create the replacement documentProducers\n      replacementPartitionKeyRanges.forEach((partitionKeyRange) => {\n        // Create replacment document producers with the parent's continuationToken\n        const replacementDocumentProducer = this._createTargetPartitionQueryExecutionContext(\n          partitionKeyRange,\n          parentDocumentProducer.continuationToken\n        );\n        replacementDocumentProducers.push(replacementDocumentProducer);\n      });\n      // We need to check if the documentProducers even has anything left to fetch from before enqueing them\n      const checkAndEnqueueDocumentProducer = async (\n        documentProducerToCheck: DocumentProducer,\n        checkNextDocumentProducerCallback: any\n      ) => {\n        try {\n          const { result: afterItem } = await documentProducerToCheck.current();\n          if (afterItem === undefined) {\n            // no more results left in this document producer, so we don't enqueue it\n          } else {\n            // Safe to put document producer back in the queue\n            this.orderByPQ.enq(documentProducerToCheck);\n          }\n\n          await checkNextDocumentProducerCallback();\n        } catch (err) {\n          this.err = err;\n          return;\n        }\n      };\n      const checkAndEnqueueDocumentProducers = async (rdp: DocumentProducer[]) => {\n        if (rdp.length > 0) {\n          // We still have a replacementDocumentProducer to check\n          const replacementDocumentProducer = rdp.shift();\n          await checkAndEnqueueDocumentProducer(replacementDocumentProducer, async () => {\n            await checkAndEnqueueDocumentProducers(rdp);\n          });\n        } else {\n          // reexecutes the originFunction with the corrrected executionContext\n          return originFunction();\n        }\n      };\n      // Invoke the recursive function to get the ball rolling\n      await checkAndEnqueueDocumentProducers(replacementDocumentProducers);\n    } catch (err) {\n      this.err = err;\n      throw err;\n    }\n  }\n\n  private static _needPartitionKeyRangeCacheRefresh(error: any) {\n    // TODO: any error\n    return (\n      error.code === StatusCodes.Gone &&\n      \"substatus\" in error &&\n      error[\"substatus\"] === SubStatusCodes.PartitionKeyRangeGone\n    );\n  }\n\n  /**\n   * Checks to see if the executionContext needs to be repaired.\n   * if so it repairs the execution context and executes the ifCallback,\n   * else it continues with the current execution context and executes the elseCallback\n   * @memberof ParallelQueryExecutionContextBase\n   * @instance\n   */\n  private async _repairExecutionContextIfNeeded(ifCallback: any, elseCallback: any) {\n    const documentProducer = this.orderByPQ.peek();\n    // Check if split happened\n    try {\n      await documentProducer.current();\n      elseCallback();\n    } catch (err) {\n      if (ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {\n        // Split has happened so we need to repair execution context before continueing\n        return this._repairExecutionContext(ifCallback);\n      } else {\n        // Something actually bad happened ...\n        this.err = err;\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Execute a provided function on the next element in the ParallelQueryExecutionContextBase.\n   * @memberof ParallelQueryExecutionContextBase\n   * @instance\n   * @param {callback} callback - Function to execute for each element. the function takes two \\\n   * parameters error, element.\n   */\n  public async nextItem(): Promise<Response<any>> {\n    if (this.err) {\n      // if there is a prior error return error\n      throw this.err;\n    }\n    return new Promise<Response<any>>((resolve, reject) => {\n      this.sem.take(() => {\n        // NOTE: lock must be released before invoking quitting\n        if (this.err) {\n          // release the lock before invoking callback\n          this.sem.leave();\n          // if there is a prior error return error\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(this.err);\n          return;\n        }\n\n        if (this.orderByPQ.size() === 0) {\n          // there is no more results\n          this.state = ParallelQueryExecutionContextBase.STATES.ended;\n          // release the lock before invoking callback\n          this.sem.leave();\n          return resolve({\n            result: undefined,\n            headers: this._getAndResetActiveResponseHeaders()\n          });\n        }\n\n        const ifCallback = () => {\n          // Release the semaphore to avoid deadlock\n          this.sem.leave();\n          // Reexcute the function\n          return resolve(this.nextItem());\n        };\n        const elseCallback = async () => {\n          let documentProducer: DocumentProducer;\n          try {\n            documentProducer = this.orderByPQ.deq();\n          } catch (e) {\n            // if comparing elements of the priority queue throws exception\n            // set that error and return error\n            this.err = e;\n            // release the lock before invoking callback\n            this.sem.leave();\n            this.err.headers = this._getAndResetActiveResponseHeaders();\n            reject(this.err);\n            return;\n          }\n\n          let item: any;\n          let headers: CosmosHeaders;\n          try {\n            const response = await documentProducer.nextItem();\n            item = response.result;\n            headers = response.headers;\n            this._mergeWithActiveResponseHeaders(headers);\n            if (item === undefined) {\n              // this should never happen\n              // because the documentProducer already has buffered an item\n              // assert item !== undefined\n              this.err = new Error(\n                `Extracted DocumentProducer from the priority queue \\\n                                            doesn't have any buffered item!`\n              );\n              // release the lock before invoking callback\n              this.sem.leave();\n              return resolve({\n                result: undefined,\n                headers: this._getAndResetActiveResponseHeaders()\n              });\n            }\n          } catch (err) {\n            this.err = new Error(\n              `Extracted DocumentProducer from the priority queue fails to get the \\\n                                    buffered item. Due to ${JSON.stringify(err)}`\n            );\n            this.err.headers = this._getAndResetActiveResponseHeaders();\n            // release the lock before invoking callback\n            this.sem.leave();\n            reject(this.err);\n            return;\n          }\n\n          // we need to put back the document producer to the queue if it has more elements.\n          // the lock will be released after we know document producer must be put back in the queue or not\n          try {\n            const { result: afterItem, headers: otherHeaders } = await documentProducer.current();\n            this._mergeWithActiveResponseHeaders(otherHeaders);\n            if (afterItem === undefined) {\n              // no more results is left in this document producer\n            } else {\n              try {\n                const headItem = documentProducer.fetchResults[0];\n                if (typeof headItem === \"undefined\") {\n                  throw new Error(\n                    \"Extracted DocumentProducer from PQ is invalid state with no result!\"\n                  );\n                }\n                this.orderByPQ.enq(documentProducer);\n              } catch (e) {\n                // if comparing elements in priority queue throws exception\n                // set error\n                this.err = e;\n              }\n            }\n          } catch (err) {\n            if (ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {\n              // We want the document producer enqueued\n              // So that later parts of the code can repair the execution context\n              this.orderByPQ.enq(documentProducer);\n            } else {\n              // Something actually bad happened\n              this.err = err;\n              reject(this.err);\n            }\n          } finally {\n            // release the lock before returning\n            this.sem.leave();\n          }\n          // invoke the callback on the item\n          return resolve({\n            result: item,\n            headers: this._getAndResetActiveResponseHeaders()\n          });\n        };\n        this._repairExecutionContextIfNeeded(ifCallback, elseCallback).catch(reject);\n      });\n    });\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs based on the value of the continuation \\\n   * token or the elements remaining on the current batch in the QueryIterator.\n   * @memberof ParallelQueryExecutionContextBase\n   * @instance\n   * @returns {Boolean} true if there is other elements to process in the ParallelQueryExecutionContextBase.\n   */\n  public hasMoreResults() {\n    return !(\n      this.state === ParallelQueryExecutionContextBase.STATES.ended || this.err !== undefined\n    );\n  }\n\n  /**\n   * Creates document producers\n   */\n  private _createTargetPartitionQueryExecutionContext(\n    partitionKeyTargetRange: any,\n    continuationToken?: any\n  ) {\n    // TODO: any\n    // creates target partition range Query Execution Context\n    let rewrittenQuery = this.partitionedQueryExecutionInfo.queryInfo.rewrittenQuery;\n    let query = this.query;\n    if (typeof query === \"string\") {\n      query = { query };\n    }\n\n    const formatPlaceHolder = \"{documentdb-formattableorderbyquery-filter}\";\n    if (rewrittenQuery) {\n      query = JSON.parse(JSON.stringify(query));\n      // We hardcode the formattable filter to true for now\n      rewrittenQuery = rewrittenQuery.replace(formatPlaceHolder, \"true\");\n      query[\"query\"] = rewrittenQuery;\n    }\n\n    const options = JSON.parse(JSON.stringify(this.options));\n    options.continuationToken = continuationToken;\n\n    return new DocumentProducer(\n      this.clientContext,\n      this.collectionLink,\n      query,\n      partitionKeyTargetRange,\n      options\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}