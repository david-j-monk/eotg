{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Constants } from \"../common/constants\";\nimport { InMemoryCollectionRoutingMap } from \"./inMemoryCollectionRoutingMap\";\n/**\n * @ignore\n */\n\nfunction compareRanges(a, b) {\n  const aVal = a[0][Constants.PartitionKeyRange.MinInclusive];\n  const bVal = b[0][Constants.PartitionKeyRange.MinInclusive];\n\n  if (aVal > bVal) {\n    return 1;\n  }\n\n  if (aVal < bVal) {\n    return -1;\n  }\n\n  return 0;\n}\n/** @hidden */\n\n\nexport function createCompleteRoutingMap(partitionKeyRangeInfoTuppleList) {\n  const rangeById = {}; // TODO: any\n\n  const rangeByInfo = {}; // TODO: any\n\n  let sortedRanges = []; // the for loop doesn't invoke any async callback\n\n  for (const r of partitionKeyRangeInfoTuppleList) {\n    rangeById[r[0][Constants.PartitionKeyRange.Id]] = r;\n    rangeByInfo[r[1]] = r[0];\n    sortedRanges.push(r);\n  }\n\n  sortedRanges = sortedRanges.sort(compareRanges);\n  const partitionKeyOrderedRange = sortedRanges.map(r => r[0]);\n  const orderedPartitionInfo = sortedRanges.map(r => r[1]);\n\n  if (!isCompleteSetOfRange(partitionKeyOrderedRange)) {\n    return undefined;\n  }\n\n  return new InMemoryCollectionRoutingMap(partitionKeyOrderedRange, orderedPartitionInfo);\n}\n/**\n * @ignore\n */\n\nfunction isCompleteSetOfRange(partitionKeyOrderedRange) {\n  // TODO: any\n  let isComplete = false;\n\n  if (partitionKeyOrderedRange.length > 0) {\n    const firstRange = partitionKeyOrderedRange[0];\n    const lastRange = partitionKeyOrderedRange[partitionKeyOrderedRange.length - 1];\n    isComplete = firstRange[Constants.PartitionKeyRange.MinInclusive] === Constants.EffectiveParitionKeyConstants.MinimumInclusiveEffectivePartitionKey;\n    isComplete = isComplete && lastRange[Constants.PartitionKeyRange.MaxExclusive] === Constants.EffectiveParitionKeyConstants.MaximumExclusiveEffectivePartitionKey;\n\n    for (let i = 1; i < partitionKeyOrderedRange.length; i++) {\n      const previousRange = partitionKeyOrderedRange[i - 1];\n      const currentRange = partitionKeyOrderedRange[i];\n      isComplete = isComplete && previousRange[Constants.PartitionKeyRange.MaxExclusive] === currentRange[Constants.PartitionKeyRange.MinInclusive];\n\n      if (!isComplete) {\n        if (previousRange[Constants.PartitionKeyRange.MaxExclusive] > currentRange[Constants.PartitionKeyRange.MinInclusive]) {\n          throw Error(\"Ranges overlap\");\n        }\n\n        break;\n      }\n    }\n  }\n\n  return isComplete;\n}","map":{"version":3,"sources":["../../src/routing/CollectionRoutingMapFactory.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Constants } from \"../common/constants\";\nimport { InMemoryCollectionRoutingMap } from \"./inMemoryCollectionRoutingMap\";\n\n/**\n * @ignore\n */\nfunction compareRanges(a: any, b: any) {\n  const aVal = a[0][Constants.PartitionKeyRange.MinInclusive];\n  const bVal = b[0][Constants.PartitionKeyRange.MinInclusive];\n  if (aVal > bVal) {\n    return 1;\n  }\n  if (aVal < bVal) {\n    return -1;\n  }\n  return 0;\n}\n\n/** @hidden */\nexport function createCompleteRoutingMap(partitionKeyRangeInfoTuppleList: any[]) {\n  const rangeById: any = {}; // TODO: any\n  const rangeByInfo: any = {}; // TODO: any\n\n  let sortedRanges = [];\n\n  // the for loop doesn't invoke any async callback\n  for (const r of partitionKeyRangeInfoTuppleList) {\n    rangeById[r[0][Constants.PartitionKeyRange.Id]] = r;\n    rangeByInfo[r[1]] = r[0];\n    sortedRanges.push(r);\n  }\n\n  sortedRanges = sortedRanges.sort(compareRanges);\n  const partitionKeyOrderedRange = sortedRanges.map((r) => r[0]);\n  const orderedPartitionInfo = sortedRanges.map((r) => r[1]);\n\n  if (!isCompleteSetOfRange(partitionKeyOrderedRange)) {\n    return undefined;\n  }\n  return new InMemoryCollectionRoutingMap(partitionKeyOrderedRange, orderedPartitionInfo);\n}\n\n/**\n * @ignore\n */\nfunction isCompleteSetOfRange(partitionKeyOrderedRange: any) {\n  // TODO: any\n  let isComplete = false;\n  if (partitionKeyOrderedRange.length > 0) {\n    const firstRange = partitionKeyOrderedRange[0];\n    const lastRange = partitionKeyOrderedRange[partitionKeyOrderedRange.length - 1];\n    isComplete =\n      firstRange[Constants.PartitionKeyRange.MinInclusive] ===\n      Constants.EffectiveParitionKeyConstants.MinimumInclusiveEffectivePartitionKey;\n    isComplete =\n      isComplete &&\n      lastRange[Constants.PartitionKeyRange.MaxExclusive] ===\n        Constants.EffectiveParitionKeyConstants.MaximumExclusiveEffectivePartitionKey;\n\n    for (let i = 1; i < partitionKeyOrderedRange.length; i++) {\n      const previousRange = partitionKeyOrderedRange[i - 1];\n      const currentRange = partitionKeyOrderedRange[i];\n      isComplete =\n        isComplete &&\n        previousRange[Constants.PartitionKeyRange.MaxExclusive] ===\n          currentRange[Constants.PartitionKeyRange.MinInclusive];\n\n      if (!isComplete) {\n        if (\n          previousRange[Constants.PartitionKeyRange.MaxExclusive] >\n          currentRange[Constants.PartitionKeyRange.MinInclusive]\n        ) {\n          throw Error(\"Ranges overlap\");\n        }\n        break;\n      }\n    }\n  }\n  return isComplete;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}