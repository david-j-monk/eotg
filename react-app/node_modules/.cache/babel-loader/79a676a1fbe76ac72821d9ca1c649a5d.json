{"ast":null,"code":"import { doubleToByteArrayJSBI } from \"./encoding/number\";\nimport { BytePrefix } from \"./encoding/prefix\";\nimport MurmurHash from \"./murmurHash\";\nexport function hashV2PartitionKey(partitionKey) {\n  const toHash = prefixKeyByType(partitionKey);\n  const hash = MurmurHash.x64.hash128(toHash);\n  const reverseBuff = reverse(Buffer.from(hash, \"hex\"));\n  reverseBuff[0] &= 0x3f;\n  return reverseBuff.toString(\"hex\").toUpperCase();\n}\n\nfunction prefixKeyByType(key) {\n  let bytes;\n\n  switch (typeof key) {\n    case \"string\":\n      bytes = Buffer.concat([Buffer.from(BytePrefix.String, \"hex\"), Buffer.from(key), Buffer.from(BytePrefix.Infinity, \"hex\")]);\n      return bytes;\n\n    case \"number\":\n      const numberBytes = doubleToByteArrayJSBI(key);\n      bytes = Buffer.concat([Buffer.from(BytePrefix.Number, \"hex\"), numberBytes]);\n      return bytes;\n\n    case \"boolean\":\n      const prefix = key ? BytePrefix.True : BytePrefix.False;\n      return Buffer.from(prefix, \"hex\");\n\n    case \"object\":\n      if (key === null) {\n        return Buffer.from(BytePrefix.Null, \"hex\");\n      }\n\n      return Buffer.from(BytePrefix.Undefined, \"hex\");\n\n    case \"undefined\":\n      return Buffer.from(BytePrefix.Undefined, \"hex\");\n  }\n}\n\nexport function reverse(buff) {\n  const buffer = Buffer.allocUnsafe(buff.length);\n\n  for (let i = 0, j = buff.length - 1; i <= j; ++i, --j) {\n    buffer[i] = buff[j];\n    buffer[j] = buff[i];\n  }\n\n  return buffer;\n}","map":{"version":3,"sources":["../../../src/utils/hashing/v2.ts"],"names":[],"mappings":"AAAA,SAAS,qBAAT,QAAsC,mBAAtC;AACA,SAAS,UAAT,QAA2B,mBAA3B;AACA,OAAO,UAAP,MAAuB,cAAvB;AAIA,OAAM,SAAU,kBAAV,CAA6B,YAA7B,EAAgD;AACpD,QAAM,MAAM,GAAG,eAAe,CAAC,YAAD,CAA9B;AACA,QAAM,IAAI,GAAG,UAAU,CAAC,GAAX,CAAe,OAAf,CAAuB,MAAvB,CAAb;AACA,QAAM,WAAW,GAAW,OAAO,CAAC,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,KAAlB,CAAD,CAAnC;AACA,EAAA,WAAW,CAAC,CAAD,CAAX,IAAkB,IAAlB;AACA,SAAO,WAAW,CAAC,QAAZ,CAAqB,KAArB,EAA4B,WAA5B,EAAP;AACD;;AAED,SAAS,eAAT,CAAyB,GAAzB,EAAmC;AACjC,MAAI,KAAJ;;AACA,UAAQ,OAAO,GAAf;AACE,SAAK,QAAL;AACE,MAAA,KAAK,GAAG,MAAM,CAAC,MAAP,CAAc,CACpB,MAAM,CAAC,IAAP,CAAY,UAAU,CAAC,MAAvB,EAA+B,KAA/B,CADoB,EAEpB,MAAM,CAAC,IAAP,CAAY,GAAZ,CAFoB,EAGpB,MAAM,CAAC,IAAP,CAAY,UAAU,CAAC,QAAvB,EAAiC,KAAjC,CAHoB,CAAd,CAAR;AAKA,aAAO,KAAP;;AACF,SAAK,QAAL;AACE,YAAM,WAAW,GAAG,qBAAqB,CAAC,GAAD,CAAzC;AACA,MAAA,KAAK,GAAG,MAAM,CAAC,MAAP,CAAc,CAAC,MAAM,CAAC,IAAP,CAAY,UAAU,CAAC,MAAvB,EAA+B,KAA/B,CAAD,EAAwC,WAAxC,CAAd,CAAR;AACA,aAAO,KAAP;;AACF,SAAK,SAAL;AACE,YAAM,MAAM,GAAG,GAAG,GAAG,UAAU,CAAC,IAAd,GAAqB,UAAU,CAAC,KAAlD;AACA,aAAO,MAAM,CAAC,IAAP,CAAY,MAAZ,EAAoB,KAApB,CAAP;;AACF,SAAK,QAAL;AACE,UAAI,GAAG,KAAK,IAAZ,EAAkB;AAChB,eAAO,MAAM,CAAC,IAAP,CAAY,UAAU,CAAC,IAAvB,EAA6B,KAA7B,CAAP;AACD;;AACD,aAAO,MAAM,CAAC,IAAP,CAAY,UAAU,CAAC,SAAvB,EAAkC,KAAlC,CAAP;;AACF,SAAK,WAAL;AACE,aAAO,MAAM,CAAC,IAAP,CAAY,UAAU,CAAC,SAAvB,EAAkC,KAAlC,CAAP;AArBJ;AAuBD;;AAED,OAAM,SAAU,OAAV,CAAkB,IAAlB,EAA8B;AAClC,QAAM,MAAM,GAAG,MAAM,CAAC,WAAP,CAAmB,IAAI,CAAC,MAAxB,CAAf;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,CAAC,GAAG,IAAI,CAAC,MAAL,GAAc,CAAlC,EAAqC,CAAC,IAAI,CAA1C,EAA6C,EAAE,CAAF,EAAK,EAAE,CAApD,EAAuD;AACrD,IAAA,MAAM,CAAC,CAAD,CAAN,GAAY,IAAI,CAAC,CAAD,CAAhB;AACA,IAAA,MAAM,CAAC,CAAD,CAAN,GAAY,IAAI,CAAC,CAAD,CAAhB;AACD;;AACD,SAAO,MAAP;AACD","sourcesContent":["import { doubleToByteArrayJSBI } from \"./encoding/number\";\nimport { BytePrefix } from \"./encoding/prefix\";\nimport MurmurHash from \"./murmurHash\";\n\ntype v2Key = string | number | null | {} | undefined;\n\nexport function hashV2PartitionKey(partitionKey: v2Key): string {\n  const toHash = prefixKeyByType(partitionKey);\n  const hash = MurmurHash.x64.hash128(toHash);\n  const reverseBuff: Buffer = reverse(Buffer.from(hash, \"hex\"));\n  reverseBuff[0] &= 0x3f;\n  return reverseBuff.toString(\"hex\").toUpperCase();\n}\n\nfunction prefixKeyByType(key: v2Key) {\n  let bytes: Buffer;\n  switch (typeof key) {\n    case \"string\":\n      bytes = Buffer.concat([\n        Buffer.from(BytePrefix.String, \"hex\"),\n        Buffer.from(key),\n        Buffer.from(BytePrefix.Infinity, \"hex\")\n      ]);\n      return bytes;\n    case \"number\":\n      const numberBytes = doubleToByteArrayJSBI(key);\n      bytes = Buffer.concat([Buffer.from(BytePrefix.Number, \"hex\"), numberBytes]);\n      return bytes;\n    case \"boolean\":\n      const prefix = key ? BytePrefix.True : BytePrefix.False;\n      return Buffer.from(prefix, \"hex\");\n    case \"object\":\n      if (key === null) {\n        return Buffer.from(BytePrefix.Null, \"hex\");\n      }\n      return Buffer.from(BytePrefix.Undefined, \"hex\");\n    case \"undefined\":\n      return Buffer.from(BytePrefix.Undefined, \"hex\");\n  }\n}\n\nexport function reverse(buff: Buffer) {\n  const buffer = Buffer.allocUnsafe(buff.length);\n\n  for (let i = 0, j = buff.length - 1; i <= j; ++i, --j) {\n    buffer[i] = buff[j];\n    buffer[j] = buff[i];\n  }\n  return buffer;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}