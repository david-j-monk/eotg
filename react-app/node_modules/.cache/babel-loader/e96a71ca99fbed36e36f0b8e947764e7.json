{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Constants } from \"../common\";\nimport { QueryRange } from \"./QueryRange\";\n/** @hidden */\n\nexport class InMemoryCollectionRoutingMap {\n  /**\n   * Represents a InMemoryCollectionRoutingMap Object,\n   * Stores partition key ranges in an efficient way with some additional information and provides\n   * convenience methods for working with set of ranges.\n   */\n  constructor(orderedPartitionKeyRanges, orderedPartitionInfo) {\n    this.orderedPartitionKeyRanges = orderedPartitionKeyRanges;\n    this.orderedRanges = orderedPartitionKeyRanges.map(pkr => {\n      return new QueryRange(pkr[Constants.PartitionKeyRange.MinInclusive], pkr[Constants.PartitionKeyRange.MaxExclusive], true, false);\n    });\n    this.orderedPartitionInfo = orderedPartitionInfo;\n  }\n\n  getOrderedParitionKeyRanges() {\n    return this.orderedPartitionKeyRanges;\n  }\n\n  getOverlappingRanges(providedQueryRanges) {\n    // TODO This code has all kinds of smells. Multiple iterations and sorts just to grab overlapping ranges\n    // stfaul attempted to bring it down to one for-loop and failed\n    const pqr = Array.isArray(providedQueryRanges) ? providedQueryRanges : [providedQueryRanges];\n    const minToPartitionRange = {}; // TODO: any\n    // this for loop doesn't invoke any async callback\n\n    for (const queryRange of pqr) {\n      if (queryRange.isEmpty()) {\n        continue;\n      }\n\n      if (queryRange.isFullRange()) {\n        return this.orderedPartitionKeyRanges;\n      }\n\n      const minIndex = this.orderedRanges.findIndex(range => {\n        if (queryRange.min > range.min && queryRange.min < range.max) {\n          return true;\n        }\n\n        if (queryRange.min === range.min) {\n          return true;\n        }\n\n        if (queryRange.min === range.max) {\n          return true;\n        }\n      });\n\n      if (minIndex < 0) {\n        throw new Error(\"error in collection routing map, queried value is less than the start range.\");\n      } // Start at the end and work backwards\n\n\n      let maxIndex;\n\n      for (let i = this.orderedRanges.length - 1; i >= 0; i--) {\n        const range = this.orderedRanges[i];\n\n        if (queryRange.max > range.min && queryRange.max < range.max) {\n          maxIndex = i;\n          break;\n        }\n\n        if (queryRange.max === range.min) {\n          maxIndex = i;\n          break;\n        }\n\n        if (queryRange.max === range.max) {\n          maxIndex = i;\n          break;\n        }\n      }\n\n      if (maxIndex > this.orderedRanges.length) {\n        throw new Error(\"error in collection routing map, queried value is greater than the end range.\");\n      }\n\n      for (let j = minIndex; j < maxIndex + 1; j++) {\n        if (queryRange.overlaps(this.orderedRanges[j])) {\n          minToPartitionRange[this.orderedPartitionKeyRanges[j][Constants.PartitionKeyRange.MinInclusive]] = this.orderedPartitionKeyRanges[j];\n        }\n      }\n    }\n\n    const overlappingPartitionKeyRanges = Object.keys(minToPartitionRange).map(k => minToPartitionRange[k]);\n    return overlappingPartitionKeyRanges.sort((a, b) => {\n      return a[Constants.PartitionKeyRange.MinInclusive].localeCompare(b[Constants.PartitionKeyRange.MinInclusive]);\n    });\n  }\n\n}","map":{"version":3,"sources":["../../src/routing/inMemoryCollectionRoutingMap.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Constants } from \"../common\";\nimport { QueryRange } from \"./QueryRange\";\n\n/** @hidden */\nexport class InMemoryCollectionRoutingMap {\n  private orderedPartitionKeyRanges: any[];\n  private orderedRanges: QueryRange[];\n  // TODO: chrande made this public, even though it is implementation detail for a test\n  public orderedPartitionInfo: any;\n\n  /**\n   * Represents a InMemoryCollectionRoutingMap Object,\n   * Stores partition key ranges in an efficient way with some additional information and provides\n   * convenience methods for working with set of ranges.\n   */\n  constructor(orderedPartitionKeyRanges: any[], orderedPartitionInfo: any) {\n    this.orderedPartitionKeyRanges = orderedPartitionKeyRanges;\n    this.orderedRanges = orderedPartitionKeyRanges.map((pkr) => {\n      return new QueryRange(\n        pkr[Constants.PartitionKeyRange.MinInclusive],\n        pkr[Constants.PartitionKeyRange.MaxExclusive],\n        true,\n        false\n      );\n    });\n    this.orderedPartitionInfo = orderedPartitionInfo;\n  }\n  public getOrderedParitionKeyRanges() {\n    return this.orderedPartitionKeyRanges;\n  }\n\n  public getOverlappingRanges(providedQueryRanges: QueryRange | QueryRange[]) {\n    // TODO This code has all kinds of smells. Multiple iterations and sorts just to grab overlapping ranges\n    // stfaul attempted to bring it down to one for-loop and failed\n    const pqr: QueryRange[] = Array.isArray(providedQueryRanges)\n      ? providedQueryRanges\n      : [providedQueryRanges];\n    const minToPartitionRange: any = {}; // TODO: any\n\n    // this for loop doesn't invoke any async callback\n    for (const queryRange of pqr) {\n      if (queryRange.isEmpty()) {\n        continue;\n      }\n\n      if (queryRange.isFullRange()) {\n        return this.orderedPartitionKeyRanges;\n      }\n\n      const minIndex = this.orderedRanges.findIndex((range) => {\n        if (queryRange.min > range.min && queryRange.min < range.max) {\n          return true;\n        }\n        if (queryRange.min === range.min) {\n          return true;\n        }\n        if (queryRange.min === range.max) {\n          return true;\n        }\n      });\n\n      if (minIndex < 0) {\n        throw new Error(\n          \"error in collection routing map, queried value is less than the start range.\"\n        );\n      }\n\n      // Start at the end and work backwards\n      let maxIndex: number;\n      for (let i = this.orderedRanges.length - 1; i >= 0; i--) {\n        const range = this.orderedRanges[i];\n        if (queryRange.max > range.min && queryRange.max < range.max) {\n          maxIndex = i;\n          break;\n        }\n        if (queryRange.max === range.min) {\n          maxIndex = i;\n          break;\n        }\n        if (queryRange.max === range.max) {\n          maxIndex = i;\n          break;\n        }\n      }\n\n      if (maxIndex > this.orderedRanges.length) {\n        throw new Error(\n          \"error in collection routing map, queried value is greater than the end range.\"\n        );\n      }\n\n      for (let j = minIndex; j < maxIndex + 1; j++) {\n        if (queryRange.overlaps(this.orderedRanges[j])) {\n          minToPartitionRange[\n            this.orderedPartitionKeyRanges[j][Constants.PartitionKeyRange.MinInclusive]\n          ] = this.orderedPartitionKeyRanges[j];\n        }\n      }\n    }\n\n    const overlappingPartitionKeyRanges = Object.keys(minToPartitionRange).map(\n      (k) => minToPartitionRange[k]\n    );\n\n    return overlappingPartitionKeyRanges.sort((a, b) => {\n      return a[Constants.PartitionKeyRange.MinInclusive].localeCompare(\n        b[Constants.PartitionKeyRange.MinInclusive]\n      );\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}