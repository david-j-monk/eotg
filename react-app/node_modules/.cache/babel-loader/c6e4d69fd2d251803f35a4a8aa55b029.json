{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { getInitialHeader, mergeHeaders } from \"../headerUtils\";\n/** @hidden */\n\nexport class OffsetLimitEndpointComponent {\n  constructor(executionContext, offset, limit) {\n    this.executionContext = executionContext;\n    this.offset = offset;\n    this.limit = limit;\n  }\n\n  nextItem() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const aggregateHeaders = getInitialHeader();\n\n      while (this.offset > 0) {\n        // Grab next item but ignore the result. We only need the headers\n        const {\n          headers\n        } = yield this.executionContext.nextItem();\n        this.offset--;\n        mergeHeaders(aggregateHeaders, headers);\n      }\n\n      if (this.limit > 0) {\n        const {\n          result,\n          headers\n        } = yield this.executionContext.nextItem();\n        this.limit--;\n        mergeHeaders(aggregateHeaders, headers);\n        return {\n          result,\n          headers: aggregateHeaders\n        };\n      } // If both limit and offset are 0, return nothing\n\n\n      return {\n        result: undefined,\n        headers: getInitialHeader()\n      };\n    });\n  }\n\n  hasMoreResults() {\n    return (this.offset > 0 || this.limit > 0) && this.executionContext.hasMoreResults();\n  }\n\n}","map":{"version":3,"sources":["../../../src/queryExecutionContext/EndpointComponent/OffsetLimitEndpointComponent.ts"],"names":[],"mappings":";AAIA,SAAS,gBAAT,EAA2B,YAA3B,QAA+C,gBAA/C;AAEA;;AACA,OAAM,MAAO,4BAAP,CAAmC;AACvC,EAAA,WAAA,CACU,gBADV,EAEU,MAFV,EAGU,KAHV,EAGuB;AAFb,SAAA,gBAAA,GAAA,gBAAA;AACA,SAAA,MAAA,GAAA,MAAA;AACA,SAAA,KAAA,GAAA,KAAA;AACN;;AAES,EAAA,QAAQ,GAAA;;AACnB,YAAM,gBAAgB,GAAG,gBAAgB,EAAzC;;AACA,aAAO,KAAK,MAAL,GAAc,CAArB,EAAwB;AACtB;AACA,cAAM;AAAE,UAAA;AAAF,YAAc,MAAM,KAAK,gBAAL,CAAsB,QAAtB,EAA1B;AACA,aAAK,MAAL;AACA,QAAA,YAAY,CAAC,gBAAD,EAAmB,OAAnB,CAAZ;AACD;;AACD,UAAI,KAAK,KAAL,GAAa,CAAjB,EAAoB;AAClB,cAAM;AAAE,UAAA,MAAF;AAAU,UAAA;AAAV,YAAsB,MAAM,KAAK,gBAAL,CAAsB,QAAtB,EAAlC;AACA,aAAK,KAAL;AACA,QAAA,YAAY,CAAC,gBAAD,EAAmB,OAAnB,CAAZ;AACA,eAAO;AAAE,UAAA,MAAF;AAAU,UAAA,OAAO,EAAE;AAAnB,SAAP;AACD,O,CACD;;;AACA,aAAO;AAAE,QAAA,MAAM,EAAE,SAAV;AAAqB,QAAA,OAAO,EAAE,gBAAgB;AAA9C,OAAP;AACD,K;AAAA;;AAEM,EAAA,cAAc,GAAA;AACnB,WAAO,CAAC,KAAK,MAAL,GAAc,CAAd,IAAmB,KAAK,KAAL,GAAa,CAAjC,KAAuC,KAAK,gBAAL,CAAsB,cAAtB,EAA9C;AACD;;AA3BsC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Response } from \"../../request\";\nimport { ExecutionContext } from \"../ExecutionContext\";\nimport { getInitialHeader, mergeHeaders } from \"../headerUtils\";\n\n/** @hidden */\nexport class OffsetLimitEndpointComponent implements ExecutionContext {\n  constructor(\n    private executionContext: ExecutionContext,\n    private offset: number,\n    private limit: number\n  ) {}\n\n  public async nextItem(): Promise<Response<any>> {\n    const aggregateHeaders = getInitialHeader();\n    while (this.offset > 0) {\n      // Grab next item but ignore the result. We only need the headers\n      const { headers } = await this.executionContext.nextItem();\n      this.offset--;\n      mergeHeaders(aggregateHeaders, headers);\n    }\n    if (this.limit > 0) {\n      const { result, headers } = await this.executionContext.nextItem();\n      this.limit--;\n      mergeHeaders(aggregateHeaders, headers);\n      return { result, headers: aggregateHeaders };\n    }\n    // If both limit and offset are 0, return nothing\n    return { result: undefined, headers: getInitialHeader() };\n  }\n\n  public hasMoreResults() {\n    return (this.offset > 0 || this.limit > 0) && this.executionContext.hasMoreResults();\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}